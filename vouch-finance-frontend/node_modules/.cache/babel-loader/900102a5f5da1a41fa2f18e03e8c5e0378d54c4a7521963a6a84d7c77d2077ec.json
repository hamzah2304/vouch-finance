{"ast":null,"code":"import { useCallback, useState, useEffect } from \"react\";\nconst error = message => {\n  throw new Error(\"[Score error] \" + message);\n};\nconst n = _ => _ ? +_ : undefined;\nconst dataToScore = data => {\n  const score = {};\n  Object.entries(data).filter(_ref => {\n    let [_] = _ref;\n    return _.includes(\"score\");\n  }).forEach(_ref2 => {\n    let [key, value] = _ref2;\n    return score[key] = value;\n  });\n  return score;\n};\nexport const useScore = (bundle, auth, api) => {\n  var _a, _b, _c;\n  const [accountsScore, setAccountsScore] = useState({});\n  const [accountsRank, setAccountsRank] = useState({});\n  const [accountsPreviewId, setAccountsPreviewId] = useState({});\n  const b = ((_a = bundle.account) === null || _a === void 0 ? void 0 : _a.bundle) || {};\n  const a = accountsScore[bundle.account.address] || {};\n  const isAddress = !((_c = (_b = bundle.account) === null || _b === void 0 ? void 0 : _b.bundle) === null || _c === void 0 ? void 0 : _c.isMinted);\n  const setAccountData = useCallback(data => {\n    setAccountsScore(Object.assign(Object.assign({}, accountsScore), {\n      [bundle.account.address]: dataToScore(data)\n    }));\n    setAccountsRank(Object.assign(Object.assign({}, accountsRank), {\n      [bundle.account.address]: data.rankNo\n    }));\n    setAccountsPreviewId(Object.assign(Object.assign({}, accountsPreviewId), {\n      [bundle.account.address]: data.previewId\n    }));\n  }, [bundle.account.address, accountsScore, accountsRank, accountsPreviewId]);\n  const getWalletScore = useCallback(() => {\n    const address = bundle.account.address;\n    if (address && !a.scoreStatus) {\n      return new Promise((resolve, reject) => {\n        api.skipImpersonationOnNextRequest();\n        api.calculateAddressScore(address).then(() => {\n          let count = 10;\n          let interval; // eslint-disable-line\n          const check = () => {\n            api.skipImpersonationOnNextRequest();\n            api.getAddressData(address).then(_ => {\n              if (!count--) {\n                clearInterval(interval);\n                error(\"Calculation timeout\");\n              }\n              if (_.score) {\n                clearInterval(interval);\n                setAccountData(_);\n                resolve(undefined);\n              }\n            });\n          };\n          setTimeout(check, 1 * 1000);\n          setTimeout(check, 6 * 1000);\n          interval = setInterval(check, 20 * 1000);\n        }).catch(reject);\n      });\n    }\n  }, [bundle.account.address, setAccountData]);\n  useEffect(() => {\n    if (!bundle.account.address || !auth.account.logged) return;\n    api.skipImpersonationOnNextRequest();\n    api.getAddressData(bundle.account.address).then(data => {\n      if (data.score) {\n        setAccountData(data);\n      }\n    });\n  }, [bundle.account.address, auth.account.logged]);\n  return {\n    account: {\n      address: bundle.account.address,\n      score: isAddress ? a : b,\n      scoreIsPreview: isAddress,\n      rank: accountsRank[bundle.account.address],\n      scorePreviewId: accountsPreviewId[bundle.account.address]\n    },\n    isAddressScore: isAddress,\n    score: isAddress ? n(a.score) : n(b.score),\n    scoreTimestamp: isAddress ? a.scoreTimestamp : b.scoreTimestamp,\n    scoreStatus: isAddress ? a.scoreStatus : b.scoreStatus,\n    scoreIngredients: isAddress ? a.scoreIngredients : b.scoreIngredients,\n    scoreRecommendations: isAddress ? a.scoreRecommendations : b.scoreRecommendations,\n    getWalletScore\n  };\n};\n//# sourceMappingURL=score.hook.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}