{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletSDKConnection = void 0;\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst Session_1 = require(\"../relay/Session\");\nconst types_1 = require(\"../types\");\nconst ClientMessage_1 = require(\"./ClientMessage\");\nconst DiagnosticLogger_1 = require(\"./DiagnosticLogger\");\nconst RxWebSocket_1 = require(\"./RxWebSocket\");\nconst ServerMessage_1 = require(\"./ServerMessage\");\nconst HEARTBEAT_INTERVAL = 10000;\nconst REQUEST_TIMEOUT = 60000;\n/**\n * Coinbase Wallet Connection\n */\nclass WalletSDKConnection {\n  /**\n   * Constructor\n   * @param sessionId Session ID\n   * @param sessionKey Session Key\n   * @param linkAPIUrl Coinbase Wallet link server URL\n   * @param [WebSocketClass] Custom WebSocket implementation\n   */\n  constructor(sessionId, sessionKey, linkAPIUrl, diagnostic) {\n    let WebSocketClass = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : WebSocket;\n    this.sessionId = sessionId;\n    this.sessionKey = sessionKey;\n    this.diagnostic = diagnostic;\n    this.subscriptions = new rxjs_1.Subscription();\n    this.destroyed = false;\n    this.lastHeartbeatResponse = 0;\n    this.nextReqId = (0, types_1.IntNumber)(1);\n    this.connectedSubject = new rxjs_1.BehaviorSubject(false);\n    this.linkedSubject = new rxjs_1.BehaviorSubject(false);\n    this.sessionConfigSubject = new rxjs_1.ReplaySubject(1);\n    const ws = new RxWebSocket_1.RxWebSocket(linkAPIUrl + \"/rpc\", WebSocketClass);\n    this.ws = ws;\n    // attempt to reconnect every 5 seconds when disconnected\n    this.subscriptions.add(ws.connectionState$.pipe((0, operators_1.tap)(state => {\n      var _a;\n      return (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.CONNECTED_STATE_CHANGE, {\n        state,\n        sessionIdHash: Session_1.Session.hash(sessionId)\n      });\n    }),\n    // ignore initial DISCONNECTED state\n    (0, operators_1.skip)(1),\n    // if DISCONNECTED and not destroyed\n    (0, operators_1.filter)(cs => cs === RxWebSocket_1.ConnectionState.DISCONNECTED && !this.destroyed),\n    // wait 5 seconds\n    (0, operators_1.delay)(5000),\n    // check whether it's destroyed again\n    (0, operators_1.filter)(_ => !this.destroyed),\n    // reconnect\n    (0, operators_1.flatMap)(_ => ws.connect()), (0, operators_1.retry)()).subscribe());\n    // perform authentication upon connection\n    this.subscriptions.add(ws.connectionState$.pipe(\n    // ignore initial DISCONNECTED and CONNECTING states\n    (0, operators_1.skip)(2), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED,\n    // if CONNECTED, authenticate, and then check link status\n    this.authenticate().pipe((0, operators_1.tap)(_ => this.sendIsLinked()), (0, operators_1.tap)(_ => this.sendGetSessionConfig()), (0, operators_1.map)(_ => true)),\n    // if not CONNECTED, emit false immediately\n    (0, rxjs_1.of)(false))), (0, operators_1.distinctUntilChanged)(), (0, operators_1.catchError)(_ => (0, rxjs_1.of)(false))).subscribe(connected => this.connectedSubject.next(connected)));\n    // send heartbeat every n seconds while connected\n    this.subscriptions.add(ws.connectionState$.pipe(\n    // ignore initial DISCONNECTED state\n    (0, operators_1.skip)(1), (0, operators_1.switchMap)(cs => (0, rxjs_1.iif)(() => cs === RxWebSocket_1.ConnectionState.CONNECTED,\n    // if CONNECTED, start the heartbeat timer\n    (0, rxjs_1.timer)(0, HEARTBEAT_INTERVAL)))).subscribe(i =>\n    // first timer event updates lastHeartbeat timestamp\n    // subsequent calls send heartbeat message\n    i === 0 ? this.updateLastHeartbeat() : this.heartbeat()));\n    // handle server's heartbeat responses\n    this.subscriptions.add(ws.incomingData$.pipe((0, operators_1.filter)(m => m === \"h\")).subscribe(_ => this.updateLastHeartbeat()));\n    // handle link status updates\n    this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)(m => [\"IsLinkedOK\", \"Linked\"].includes(m.type))).subscribe(m => {\n      var _a;\n      const msg = m;\n      (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.LINKED, {\n        sessionIdHash: Session_1.Session.hash(sessionId),\n        linked: msg.linked,\n        type: m.type,\n        onlineGuests: msg.onlineGuests\n      });\n      this.linkedSubject.next(msg.linked || msg.onlineGuests > 0);\n    }));\n    // handle session config updates\n    this.subscriptions.add(ws.incomingJSONData$.pipe((0, operators_1.filter)(m => [\"GetSessionConfigOK\", \"SessionConfigUpdated\"].includes(m.type))).subscribe(m => {\n      var _a;\n      const msg = m;\n      (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.SESSION_CONFIG_RECEIVED, {\n        sessionIdHash: Session_1.Session.hash(sessionId),\n        metadata_keys: msg && msg.metadata ? Object.keys(msg.metadata) : undefined\n      });\n      this.sessionConfigSubject.next({\n        webhookId: msg.webhookId,\n        webhookUrl: msg.webhookUrl,\n        metadata: msg.metadata\n      });\n    }));\n  }\n  /**\n   * Make a connection to the server\n   */\n  connect() {\n    var _a;\n    if (this.destroyed) {\n      throw new Error(\"instance is destroyed\");\n    }\n    (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.STARTED_CONNECTING, {\n      sessionIdHash: Session_1.Session.hash(this.sessionId)\n    });\n    this.ws.connect().subscribe();\n  }\n  /**\n   * Terminate connection, and mark as destroyed. To reconnect, create a new\n   * instance of WalletSDKConnection\n   */\n  destroy() {\n    var _a;\n    this.subscriptions.unsubscribe();\n    this.ws.disconnect();\n    (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.DISCONNECTED, {\n      sessionIdHash: Session_1.Session.hash(this.sessionId)\n    });\n    this.destroyed = true;\n  }\n  get isDestroyed() {\n    return this.destroyed;\n  }\n  /**\n   * Emit true if connected and authenticated, else false\n   * @returns an Observable\n   */\n  get connected$() {\n    return this.connectedSubject.asObservable();\n  }\n  /**\n   * Emit once connected\n   * @returns an Observable\n   */\n  get onceConnected$() {\n    return this.connected$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\n  }\n  /**\n   * Emit true if linked (a guest has joined before)\n   * @returns an Observable\n   */\n  get linked$() {\n    return this.linkedSubject.asObservable();\n  }\n  /**\n   * Emit once when linked\n   * @returns an Observable\n   */\n  get onceLinked$() {\n    return this.linked$.pipe((0, operators_1.filter)(v => v), (0, operators_1.take)(1), (0, operators_1.map)(() => void 0));\n  }\n  /**\n   * Emit current session config if available, and subsequent updates\n   * @returns an Observable for the session config\n   */\n  get sessionConfig$() {\n    return this.sessionConfigSubject.asObservable();\n  }\n  /**\n   * Emit incoming Event messages\n   * @returns an Observable for the messages\n   */\n  get incomingEvent$() {\n    return this.ws.incomingJSONData$.pipe((0, operators_1.filter)(m => {\n      if (m.type !== \"Event\") {\n        return false;\n      }\n      const sme = m;\n      return typeof sme.sessionId === \"string\" && typeof sme.eventId === \"string\" && typeof sme.event === \"string\" && typeof sme.data === \"string\";\n    }), (0, operators_1.map)(m => m));\n  }\n  /**\n   * Set session metadata in SessionConfig object\n   * @param key\n   * @param value\n   * @returns an Observable that completes when successful\n   */\n  setSessionMetadata(key, value) {\n    const message = (0, ClientMessage_1.ClientMessageSetSessionConfig)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId,\n      metadata: {\n        [key]: value\n      }\n    });\n    return this.onceConnected$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\n      if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n        throw new Error(res.error || \"failed to set session metadata\");\n      }\n    }));\n  }\n  /**\n   * Publish an event and emit event ID when successful\n   * @param event event name\n   * @param data event data\n   * @param callWebhook whether the webhook should be invoked\n   * @returns an Observable that emits event ID when successful\n   */\n  publishEvent(event, data) {\n    let callWebhook = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const message = (0, ClientMessage_1.ClientMessagePublishEvent)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId,\n      event,\n      data,\n      callWebhook\n    });\n    return this.onceLinked$.pipe((0, operators_1.flatMap)(_ => this.makeRequest(message)), (0, operators_1.map)(res => {\n      if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n        throw new Error(res.error || \"failed to publish event\");\n      }\n      return res.eventId;\n    }));\n  }\n  sendData(message) {\n    this.ws.sendData(JSON.stringify(message));\n  }\n  updateLastHeartbeat() {\n    this.lastHeartbeatResponse = Date.now();\n  }\n  heartbeat() {\n    if (Date.now() - this.lastHeartbeatResponse > HEARTBEAT_INTERVAL * 2) {\n      this.ws.disconnect();\n      return;\n    }\n    try {\n      this.ws.sendData(\"h\");\n    } catch (_a) {}\n  }\n  makeRequest(message) {\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : REQUEST_TIMEOUT;\n    const reqId = message.id;\n    try {\n      this.sendData(message);\n    } catch (err) {\n      return (0, rxjs_1.throwError)(err);\n    }\n    // await server message with corresponding id\n    return this.ws.incomingJSONData$.pipe((0, operators_1.timeoutWith)(timeout, (0, rxjs_1.throwError)(new Error(`request ${reqId} timed out`))), (0, operators_1.filter)(m => m.id === reqId), (0, operators_1.take)(1));\n  }\n  authenticate() {\n    const msg = (0, ClientMessage_1.ClientMessageHostSession)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId,\n      sessionKey: this.sessionKey\n    });\n    return this.makeRequest(msg).pipe((0, operators_1.map)(res => {\n      if ((0, ServerMessage_1.isServerMessageFail)(res)) {\n        throw new Error(res.error || \"failed to authentcate\");\n      }\n    }));\n  }\n  sendIsLinked() {\n    const msg = (0, ClientMessage_1.ClientMessageIsLinked)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId\n    });\n    this.sendData(msg);\n  }\n  sendGetSessionConfig() {\n    const msg = (0, ClientMessage_1.ClientMessageGetSessionConfig)({\n      id: (0, types_1.IntNumber)(this.nextReqId++),\n      sessionId: this.sessionId\n    });\n    this.sendData(msg);\n  }\n}\nexports.WalletSDKConnection = WalletSDKConnection;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}