{"ast":null,"code":"import { WINDOW } from '@sentry/browser';\nimport { logger, getNumberOfUrlSegments } from '@sentry/utils';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport React__default from 'react';\nconst _jsxFileName = \"/home/runner/work/sentry-javascript/sentry-javascript/packages/react/src/reactrouterv6.tsx\"; // Inspired from Donnie McNeal's solution:\n\nlet activeTransaction;\nlet _useEffect;\nlet _useLocation;\nlet _useNavigationType;\nlet _createRoutesFromChildren;\nlet _matchRoutes;\nlet _customStartTransaction;\nlet _startTransactionOnLocationChange;\nconst SENTRY_TAGS = {\n  'routing.instrumentation': 'react-router-v6'\n};\nfunction reactRouterV6Instrumentation(useEffect, useLocation, useNavigationType, createRoutesFromChildren, matchRoutes) {\n  return function (customStartTransaction) {\n    let startTransactionOnPageLoad = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let startTransactionOnLocationChange = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    const initPathName = WINDOW && WINDOW.location && WINDOW.location.pathname;\n    if (startTransactionOnPageLoad && initPathName) {\n      activeTransaction = customStartTransaction({\n        name: initPathName,\n        op: 'pageload',\n        tags: SENTRY_TAGS,\n        metadata: {\n          source: 'url'\n        }\n      });\n    }\n    _useEffect = useEffect;\n    _useLocation = useLocation;\n    _useNavigationType = useNavigationType;\n    _matchRoutes = matchRoutes;\n    _createRoutesFromChildren = createRoutesFromChildren;\n    _customStartTransaction = customStartTransaction;\n    _startTransactionOnLocationChange = startTransactionOnLocationChange;\n  };\n}\nfunction getNormalizedName(routes, location, branches) {\n  if (!routes || routes.length === 0) {\n    return [location.pathname, 'url'];\n  }\n  let pathBuilder = '';\n  if (branches) {\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let x = 0; x < branches.length; x++) {\n      const branch = branches[x];\n      const route = branch.route;\n      if (route) {\n        // Early return if index route\n        if (route.index) {\n          return [branch.pathname, 'route'];\n        }\n        const path = route.path;\n        if (path) {\n          const newPath = path[0] === '/' || pathBuilder[pathBuilder.length - 1] === '/' ? path : `/${path}`;\n          pathBuilder += newPath;\n          if (branch.pathname === location.pathname) {\n            if (\n            // If the route defined on the element is something like\n            // <Route path=\"/stores/:storeId/products/:productId\" element={<div>Product</div>} />\n            // We should check against the branch.pathname for the number of / seperators\n            getNumberOfUrlSegments(pathBuilder) !== getNumberOfUrlSegments(branch.pathname) &&\n            // We should not count wildcard operators in the url segments calculation\n            pathBuilder.slice(-2) !== '/*') {\n              return [newPath, 'route'];\n            }\n            return [pathBuilder, 'route'];\n          }\n        }\n      }\n    }\n  }\n  return [location.pathname, 'url'];\n}\nfunction updatePageloadTransaction(location, routes, matches) {\n  const branches = Array.isArray(matches) ? matches : _matchRoutes(routes, location);\n  if (activeTransaction && branches) {\n    activeTransaction.setName(...getNormalizedName(routes, location, branches));\n  }\n}\nfunction handleNavigation(location, routes, navigationType, matches) {\n  const branches = Array.isArray(matches) ? matches : _matchRoutes(routes, location);\n  if (_startTransactionOnLocationChange && (navigationType === 'PUSH' || navigationType === 'POP') && branches) {\n    if (activeTransaction) {\n      activeTransaction.finish();\n    }\n    const [name, source] = getNormalizedName(routes, location, branches);\n    activeTransaction = _customStartTransaction({\n      name,\n      op: 'navigation',\n      tags: SENTRY_TAGS,\n      metadata: {\n        source\n      }\n    });\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction withSentryReactRouterV6Routing(Routes) {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_createRoutesFromChildren || !_matchRoutes || !_customStartTransaction) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`reactRouterV6Instrumentation was unable to wrap Routes because of one or more missing parameters.\n      useEffect: ${_useEffect}. useLocation: ${_useLocation}. useNavigationType: ${_useNavigationType}.\n      createRoutesFromChildren: ${_createRoutesFromChildren}. matchRoutes: ${_matchRoutes}. customStartTransaction: ${_customStartTransaction}.`);\n    return Routes;\n  }\n  let isMountRenderPass = true;\n  const SentryRoutes = props => {\n    const location = _useLocation();\n    const navigationType = _useNavigationType();\n    _useEffect(() => {\n      const routes = _createRoutesFromChildren(props.children);\n      if (isMountRenderPass) {\n        updatePageloadTransaction(location, routes);\n        isMountRenderPass = false;\n      } else {\n        handleNavigation(location, routes, navigationType);\n      }\n    },\n    // `props.children` is purpusely not included in the dependency array, because we do not want to re-run this effect\n    // when the children change. We only want to start transactions when the location or navigation type change.\n    [location, navigationType]);\n\n    // @ts-ignore Setting more specific React Component typing for `R` generic above\n    // will break advanced type inference done by react router params\n    return React__default.createElement(Routes, {\n      ...props,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 197\n      }\n    });\n  };\n  hoistNonReactStatics(SentryRoutes, Routes);\n\n  // @ts-ignore Setting more specific React Component typing for `R` generic above\n  // will break advanced type inference done by react router params\n  return SentryRoutes;\n}\nfunction wrapUseRoutes(origUseRoutes) {\n  if (!_useEffect || !_useLocation || !_useNavigationType || !_matchRoutes || !_customStartTransaction) {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('reactRouterV6Instrumentation was unable to wrap `useRoutes` because of one or more missing parameters.');\n    return origUseRoutes;\n  }\n  let isMountRenderPass = true;\n\n  // eslint-disable-next-line react/display-name\n  return (routes, locationArg) => {\n    const SentryRoutes = () => {\n      const Routes = origUseRoutes(routes, locationArg);\n      const location = _useLocation();\n      const navigationType = _useNavigationType();\n\n      // A value with stable identity to either pick `locationArg` if available or `location` if not\n      const stableLocationParam = typeof locationArg === 'string' || locationArg && locationArg.pathname ? locationArg : location;\n      _useEffect(() => {\n        const normalizedLocation = typeof stableLocationParam === 'string' ? {\n          pathname: stableLocationParam\n        } : stableLocationParam;\n        if (isMountRenderPass) {\n          updatePageloadTransaction(normalizedLocation, routes);\n          isMountRenderPass = false;\n        } else {\n          handleNavigation(normalizedLocation, routes, navigationType);\n        }\n      }, [navigationType, stableLocationParam]);\n      return Routes;\n    };\n    return React__default.createElement(SentryRoutes, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 248\n      }\n    });\n  };\n}\nfunction wrapCreateBrowserRouter(createRouterFunction) {\n  // `opts` for createBrowserHistory and createMemoryHistory are different, but also not relevant for us at the moment.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return function (routes, opts) {\n    const router = createRouterFunction(routes, opts);\n\n    // The initial load ends when `createBrowserRouter` is called.\n    // This is the earliest convenient time to update the transaction name.\n    // Callbacks to `router.subscribe` are not called for the initial load.\n    if (router.state.historyAction === 'POP' && activeTransaction) {\n      updatePageloadTransaction(router.state.location, routes);\n    }\n    router.subscribe(state => {\n      const location = state.location;\n      if (_startTransactionOnLocationChange && (state.historyAction === 'PUSH' || state.historyAction === 'POP') && activeTransaction) {\n        handleNavigation(location, routes, state.historyAction);\n      }\n    });\n    return router;\n  };\n}\nexport { reactRouterV6Instrumentation, withSentryReactRouterV6Routing, wrapCreateBrowserRouter, wrapUseRoutes };\n//# sourceMappingURL=reactrouterv6.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}