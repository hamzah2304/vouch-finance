{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar dnsRecordsError_1 = __importStar(require(\"../errors/dnsRecordsError\"));\nvar publicTypes_1 = require(\"../types/publicTypes\");\nvar DnsUtils = /** @class */function () {\n  function DnsUtils() {}\n  DnsUtils.prototype.toList = function (record) {\n    var _a;\n    var _this = this;\n    var dnsTypes = this.getAllDnsTypes(record);\n    return (_a = []).concat.apply(_a, dnsTypes.map(function (type) {\n      return _this.constructDnsRecords(record, type);\n    }));\n  };\n  DnsUtils.prototype.toCrypto = function (records) {\n    var cryptoRecords = {};\n    for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {\n      var record = records_1[_i];\n      var type = record.type,\n        TTL = record.TTL,\n        data = record.data;\n      var ttlInRecord = this.getJsonNumber(cryptoRecords[\"dns.\".concat(type, \".ttl\")]);\n      var dnsInRecord = this.getJsonArray(cryptoRecords, \"dns.\".concat(type));\n      if (dnsInRecord) {\n        dnsInRecord.push(data);\n        cryptoRecords[\"dns.\".concat(type)] = JSON.stringify(dnsInRecord);\n      } else {\n        cryptoRecords[\"dns.\".concat(type)] = JSON.stringify([data]);\n        cryptoRecords[\"dns.\".concat(type, \".ttl\")] = TTL.toString(10);\n      }\n      if (!!ttlInRecord && ttlInRecord !== TTL) {\n        throw new dnsRecordsError_1.default(dnsRecordsError_1.DnsRecordsErrorCode.InconsistentTtl, {\n          recordType: type\n        });\n      }\n    }\n    return cryptoRecords;\n  };\n  DnsUtils.prototype.protectFromCorruptRecord = function (rawRecord, type) {\n    try {\n      return rawRecord ? JSON.parse(rawRecord) : undefined;\n    } catch (err) {\n      if (err instanceof SyntaxError) {\n        throw new dnsRecordsError_1.default(dnsRecordsError_1.DnsRecordsErrorCode.DnsRecordCorrupted, {\n          recordType: type\n        });\n      }\n      throw err;\n    }\n  };\n  DnsUtils.prototype.getJsonArray = function (cryptoRecrods, key) {\n    var rawRecord = cryptoRecrods[key];\n    var type = key.split('.')[1];\n    return this.protectFromCorruptRecord(rawRecord, type);\n  };\n  DnsUtils.prototype.getJsonNumber = function (rawRecord) {\n    return rawRecord ? parseInt(rawRecord, 10) : undefined;\n  };\n  DnsUtils.prototype.getAllDnsTypes = function (records) {\n    var keys = new Set();\n    Object.keys(records).forEach(function (key) {\n      var chunks = key.split('.');\n      var type = chunks[1] && chunks[1] !== 'ttl';\n      if (type) {\n        keys.add(publicTypes_1.DnsRecordType[chunks[1]]);\n      }\n    });\n    return Array.from(keys);\n  };\n  DnsUtils.prototype.constructDnsRecords = function (cryptoData, type) {\n    var TTL = this.parseTtl(cryptoData, type);\n    var jsonValueString = cryptoData[\"dns.\".concat(type)];\n    if (!jsonValueString) {\n      return [];\n    }\n    var typeData = this.protectFromCorruptRecord(jsonValueString, type);\n    if (!this.isStringArray(typeData)) {\n      return [];\n    }\n    return typeData.map(function (data) {\n      return {\n        TTL: TTL,\n        data: data,\n        type: type\n      };\n    });\n  };\n  DnsUtils.prototype.parseTtl = function (data, type) {\n    var defaultTtl = data['dns.ttl'];\n    var recordTtl = data[\"dns.\".concat(type, \".ttl\")];\n    if (recordTtl) {\n      var parsedInt = this.parseIfNumber(recordTtl);\n      if (parsedInt) {\n        return parsedInt;\n      }\n    }\n    if (defaultTtl) {\n      var parsedInt = this.parseIfNumber(defaultTtl);\n      if (parsedInt) {\n        return parsedInt;\n      }\n    }\n    return DnsUtils.DefaultTtl;\n  };\n  DnsUtils.prototype.parseIfNumber = function (str) {\n    var parsedInt = parseInt(str, 10);\n    if (!isNaN(parsedInt)) {\n      return parsedInt;\n    }\n  };\n  DnsUtils.prototype.isStringArray = function (value) {\n    if (value instanceof Array) {\n      return value.every(function (item) {\n        return typeof item === 'string';\n      });\n    }\n    return false;\n  };\n  DnsUtils.DefaultTtl = 300; // 5 minutes\n  return DnsUtils;\n}();\nexports.default = DnsUtils;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}