{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MetaMask = exports.NoMetaMaskError = void 0;\nconst types_1 = require(\"@web3-react/types\");\nclass NoMetaMaskError extends Error {\n  constructor() {\n    super('MetaMask not installed');\n    this.name = NoMetaMaskError.name;\n    Object.setPrototypeOf(this, NoMetaMaskError.prototype);\n  }\n}\nexports.NoMetaMaskError = NoMetaMaskError;\nfunction parseChainId(chainId) {\n  return Number.parseInt(chainId, 16);\n}\nclass MetaMask extends types_1.Connector {\n  constructor(_ref) {\n    let {\n      actions,\n      options,\n      onError\n    } = _ref;\n    super(actions, onError);\n    this.options = options;\n  }\n  isomorphicInitialize() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.eagerConnection) return;\n      return this.eagerConnection = Promise.resolve().then(() => __importStar(require('@metamask/detect-provider'))).then(m => __awaiter(this, void 0, void 0, function* () {\n        var _a, _b;\n        const provider = yield m.default(this.options);\n        if (provider) {\n          this.provider = provider;\n          // handle the case when e.g. metamask and coinbase wallet are both installed\n          if ((_a = this.provider.providers) === null || _a === void 0 ? void 0 : _a.length) {\n            this.provider = (_b = this.provider.providers.find(p => p.isMetaMask)) !== null && _b !== void 0 ? _b : this.provider.providers[0];\n          }\n          this.provider.on('connect', _ref2 => {\n            let {\n              chainId\n            } = _ref2;\n            this.actions.update({\n              chainId: parseChainId(chainId)\n            });\n          });\n          this.provider.on('disconnect', error => {\n            var _a;\n            this.actions.resetState();\n            (_a = this.onError) === null || _a === void 0 ? void 0 : _a.call(this, error);\n          });\n          this.provider.on('chainChanged', chainId => {\n            this.actions.update({\n              chainId: parseChainId(chainId)\n            });\n          });\n          this.provider.on('accountsChanged', accounts => {\n            if (accounts.length === 0) {\n              // handle this edge case by disconnecting\n              this.actions.resetState();\n            } else {\n              this.actions.update({\n                accounts\n              });\n            }\n          });\n        }\n      }));\n    });\n  }\n  /** {@inheritdoc Connector.connectEagerly} */\n  connectEagerly() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const cancelActivation = this.actions.startActivation();\n      yield this.isomorphicInitialize();\n      if (!this.provider) return cancelActivation();\n      return Promise.all([this.provider.request({\n        method: 'eth_chainId'\n      }), this.provider.request({\n        method: 'eth_accounts'\n      })]).then(_ref3 => {\n        let [chainId, accounts] = _ref3;\n        if (accounts.length) {\n          this.actions.update({\n            chainId: parseChainId(chainId),\n            accounts\n          });\n        } else {\n          throw new Error('No accounts returned');\n        }\n      }).catch(error => {\n        console.debug('Could not connect eagerly', error);\n        // we should be able to use `cancelActivation` here, but on mobile, metamask emits a 'connect'\n        // event, meaning that chainId is updated, and cancelActivation doesn't work because an intermediary\n        // update has occurred, so we reset state instead\n        this.actions.resetState();\n      });\n    });\n  }\n  /**\n   * Initiates a connection.\n   *\n   * @param desiredChainIdOrChainParameters - If defined, indicates the desired chain to connect to. If the user is\n   * already connected to this chain, no additional steps will be taken. Otherwise, the user will be prompted to switch\n   * to the chain, if one of two conditions is met: either they already have it added in their extension, or the\n   * argument is of type AddEthereumChainParameter, in which case the user will be prompted to add the chain with the\n   * specified parameters first, before being prompted to switch.\n   */\n  activate(desiredChainIdOrChainParameters) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      let cancelActivation;\n      if (!((_b = (_a = this.provider) === null || _a === void 0 ? void 0 : _a.isConnected) === null || _b === void 0 ? void 0 : _b.call(_a))) cancelActivation = this.actions.startActivation();\n      return this.isomorphicInitialize().then(() => __awaiter(this, void 0, void 0, function* () {\n        if (!this.provider) throw new NoMetaMaskError();\n        return Promise.all([this.provider.request({\n          method: 'eth_chainId'\n        }), this.provider.request({\n          method: 'eth_requestAccounts'\n        })]).then(_ref4 => {\n          let [chainId, accounts] = _ref4;\n          const receivedChainId = parseChainId(chainId);\n          const desiredChainId = typeof desiredChainIdOrChainParameters === 'number' ? desiredChainIdOrChainParameters : desiredChainIdOrChainParameters === null || desiredChainIdOrChainParameters === void 0 ? void 0 : desiredChainIdOrChainParameters.chainId;\n          // if there's no desired chain, or it's equal to the received, update\n          if (!desiredChainId || receivedChainId === desiredChainId) return this.actions.update({\n            chainId: receivedChainId,\n            accounts\n          });\n          const desiredChainIdHex = `0x${desiredChainId.toString(16)}`;\n          // if we're here, we can try to switch networks\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          return this.provider.request({\n            method: 'wallet_switchEthereumChain',\n            params: [{\n              chainId: desiredChainIdHex\n            }]\n          }).catch(error => {\n            if (error.code === 4902 && typeof desiredChainIdOrChainParameters !== 'number') {\n              // if we're here, we can try to add a new network\n              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n              return this.provider.request({\n                method: 'wallet_addEthereumChain',\n                params: [Object.assign(Object.assign({}, desiredChainIdOrChainParameters), {\n                  chainId: desiredChainIdHex\n                })]\n              });\n            }\n            throw error;\n          }).then(() => this.activate(desiredChainId));\n        });\n      })).catch(error => {\n        cancelActivation === null || cancelActivation === void 0 ? void 0 : cancelActivation();\n        throw error;\n      });\n    });\n  }\n  watchAsset(_ref5) {\n    let {\n      address,\n      symbol,\n      decimals,\n      image\n    } = _ref5;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.provider) throw new Error('No provider');\n      return this.provider.request({\n        method: 'wallet_watchAsset',\n        params: {\n          type: 'ERC20',\n          options: {\n            address,\n            symbol,\n            decimals,\n            image // A string url of the token logo\n          }\n        }\n      }).then(success => {\n        if (!success) throw new Error('Rejected');\n        return true;\n      });\n    });\n  }\n}\nexports.MetaMask = MetaMask;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}