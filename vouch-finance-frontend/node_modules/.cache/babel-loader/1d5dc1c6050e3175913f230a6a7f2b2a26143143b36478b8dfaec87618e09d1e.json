{"ast":null,"code":"// Extracted from https://github.com/ethereumjs/ethereumjs-abi and stripped out irrelevant code\n// Original code licensed under the MIT License - Copyright (c) 2015 Alex Beregszaszi\n\nconst util = require('./util');\nconst BN = require('bn.js');\n\n// Convert from short to canonical names\n// FIXME: optimise or make this nicer?\nfunction elementaryName(name) {\n  if (name.startsWith('int[')) {\n    return 'int256' + name.slice(3);\n  } else if (name === 'int') {\n    return 'int256';\n  } else if (name.startsWith('uint[')) {\n    return 'uint256' + name.slice(4);\n  } else if (name === 'uint') {\n    return 'uint256';\n  } else if (name.startsWith('fixed[')) {\n    return 'fixed128x128' + name.slice(5);\n  } else if (name === 'fixed') {\n    return 'fixed128x128';\n  } else if (name.startsWith('ufixed[')) {\n    return 'ufixed128x128' + name.slice(6);\n  } else if (name === 'ufixed') {\n    return 'ufixed128x128';\n  }\n  return name;\n}\n\n// Parse N from type<N>\nfunction parseTypeN(type) {\n  return parseInt(/^\\D+(\\d+)$/.exec(type)[1], 10);\n}\n\n// Parse N,M from type<N>x<M>\nfunction parseTypeNxM(type) {\n  var tmp = /^\\D+(\\d+)x(\\d+)$/.exec(type);\n  return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];\n}\n\n// Parse N in type[<N>] where \"type\" can itself be an array type.\nfunction parseTypeArray(type) {\n  var tmp = type.match(/(.*)\\[(.*?)\\]$/);\n  if (tmp) {\n    return tmp[2] === '' ? 'dynamic' : parseInt(tmp[2], 10);\n  }\n  return null;\n}\nfunction parseNumber(arg) {\n  var type = typeof arg;\n  if (type === 'string') {\n    if (util.isHexString(arg)) {\n      return new BN(util.stripHexPrefix(arg), 16);\n    } else {\n      return new BN(arg, 10);\n    }\n  } else if (type === 'number') {\n    return new BN(arg);\n  } else if (arg.toArray) {\n    // assume this is a BN for the moment, replace with BN.isBN soon\n    return arg;\n  } else {\n    throw new Error('Argument is not a number');\n  }\n}\n\n// Encodes a single item (can be dynamic array)\n// @returns: Buffer\nfunction encodeSingle(type, arg) {\n  var size, num, ret, i;\n  if (type === 'address') {\n    return encodeSingle('uint160', parseNumber(arg));\n  } else if (type === 'bool') {\n    return encodeSingle('uint8', arg ? 1 : 0);\n  } else if (type === 'string') {\n    return encodeSingle('bytes', new Buffer(arg, 'utf8'));\n  } else if (isArray(type)) {\n    // this part handles fixed-length ([2]) and variable length ([]) arrays\n    // NOTE: we catch here all calls to arrays, that simplifies the rest\n    if (typeof arg.length === 'undefined') {\n      throw new Error('Not an array?');\n    }\n    size = parseTypeArray(type);\n    if (size !== 'dynamic' && size !== 0 && arg.length > size) {\n      throw new Error('Elements exceed array size: ' + size);\n    }\n    ret = [];\n    type = type.slice(0, type.lastIndexOf('['));\n    if (typeof arg === 'string') {\n      arg = JSON.parse(arg);\n    }\n    for (i in arg) {\n      ret.push(encodeSingle(type, arg[i]));\n    }\n    if (size === 'dynamic') {\n      var length = encodeSingle('uint256', arg.length);\n      ret.unshift(length);\n    }\n    return Buffer.concat(ret);\n  } else if (type === 'bytes') {\n    arg = new Buffer(arg);\n    ret = Buffer.concat([encodeSingle('uint256', arg.length), arg]);\n    if (arg.length % 32 !== 0) {\n      ret = Buffer.concat([ret, util.zeros(32 - arg.length % 32)]);\n    }\n    return ret;\n  } else if (type.startsWith('bytes')) {\n    size = parseTypeN(type);\n    if (size < 1 || size > 32) {\n      throw new Error('Invalid bytes<N> width: ' + size);\n    }\n    return util.setLengthRight(arg, 32);\n  } else if (type.startsWith('uint')) {\n    size = parseTypeN(type);\n    if (size % 8 || size < 8 || size > 256) {\n      throw new Error('Invalid uint<N> width: ' + size);\n    }\n    num = parseNumber(arg);\n    if (num.bitLength() > size) {\n      throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength());\n    }\n    if (num < 0) {\n      throw new Error('Supplied uint is negative');\n    }\n    return num.toArrayLike(Buffer, 'be', 32);\n  } else if (type.startsWith('int')) {\n    size = parseTypeN(type);\n    if (size % 8 || size < 8 || size > 256) {\n      throw new Error('Invalid int<N> width: ' + size);\n    }\n    num = parseNumber(arg);\n    if (num.bitLength() > size) {\n      throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength());\n    }\n    return num.toTwos(256).toArrayLike(Buffer, 'be', 32);\n  } else if (type.startsWith('ufixed')) {\n    size = parseTypeNxM(type);\n    num = parseNumber(arg);\n    if (num < 0) {\n      throw new Error('Supplied ufixed is negative');\n    }\n    return encodeSingle('uint256', num.mul(new BN(2).pow(new BN(size[1]))));\n  } else if (type.startsWith('fixed')) {\n    size = parseTypeNxM(type);\n    return encodeSingle('int256', parseNumber(arg).mul(new BN(2).pow(new BN(size[1]))));\n  }\n  throw new Error('Unsupported or invalid type: ' + type);\n}\n\n// Is a type dynamic?\nfunction isDynamic(type) {\n  // FIXME: handle all types? I don't think anything is missing now\n  return type === 'string' || type === 'bytes' || parseTypeArray(type) === 'dynamic';\n}\n\n// Is a type an array?\nfunction isArray(type) {\n  return type.lastIndexOf(']') === type.length - 1;\n}\n\n// Encode a method/event with arguments\n// @types an array of string type names\n// @args  an array of the appropriate values\nfunction rawEncode(types, values) {\n  var output = [];\n  var data = [];\n  var headLength = 32 * types.length;\n  for (var i in types) {\n    var type = elementaryName(types[i]);\n    var value = values[i];\n    var cur = encodeSingle(type, value);\n\n    // Use the head/tail method for storing dynamic data\n    if (isDynamic(type)) {\n      output.push(encodeSingle('uint256', headLength));\n      data.push(cur);\n      headLength += cur.length;\n    } else {\n      output.push(cur);\n    }\n  }\n  return Buffer.concat(output.concat(data));\n}\nfunction solidityPack(types, values) {\n  if (types.length !== values.length) {\n    throw new Error('Number of types are not matching the values');\n  }\n  var size, num;\n  var ret = [];\n  for (var i = 0; i < types.length; i++) {\n    var type = elementaryName(types[i]);\n    var value = values[i];\n    if (type === 'bytes') {\n      ret.push(value);\n    } else if (type === 'string') {\n      ret.push(new Buffer(value, 'utf8'));\n    } else if (type === 'bool') {\n      ret.push(new Buffer(value ? '01' : '00', 'hex'));\n    } else if (type === 'address') {\n      ret.push(util.setLength(value, 20));\n    } else if (type.startsWith('bytes')) {\n      size = parseTypeN(type);\n      if (size < 1 || size > 32) {\n        throw new Error('Invalid bytes<N> width: ' + size);\n      }\n      ret.push(util.setLengthRight(value, size));\n    } else if (type.startsWith('uint')) {\n      size = parseTypeN(type);\n      if (size % 8 || size < 8 || size > 256) {\n        throw new Error('Invalid uint<N> width: ' + size);\n      }\n      num = parseNumber(value);\n      if (num.bitLength() > size) {\n        throw new Error('Supplied uint exceeds width: ' + size + ' vs ' + num.bitLength());\n      }\n      ret.push(num.toArrayLike(Buffer, 'be', size / 8));\n    } else if (type.startsWith('int')) {\n      size = parseTypeN(type);\n      if (size % 8 || size < 8 || size > 256) {\n        throw new Error('Invalid int<N> width: ' + size);\n      }\n      num = parseNumber(value);\n      if (num.bitLength() > size) {\n        throw new Error('Supplied int exceeds width: ' + size + ' vs ' + num.bitLength());\n      }\n      ret.push(num.toTwos(size).toArrayLike(Buffer, 'be', size / 8));\n    } else {\n      // FIXME: support all other types\n      throw new Error('Unsupported or invalid type: ' + type);\n    }\n  }\n  return Buffer.concat(ret);\n}\nfunction soliditySHA3(types, values) {\n  return util.keccak(solidityPack(types, values));\n}\nmodule.exports = {\n  rawEncode,\n  solidityPack,\n  soliditySHA3\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}