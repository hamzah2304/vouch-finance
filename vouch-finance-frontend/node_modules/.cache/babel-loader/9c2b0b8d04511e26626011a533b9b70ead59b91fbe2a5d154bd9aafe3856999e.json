{"ast":null,"code":"import { isHexString } from './index.js';\n// methods that require user interaction\nconst methods = ['eth_sendTransaction', 'eth_signTransaction', 'personal_sign', 'eth_sign', 'eth_signTypedData', 'eth_signTypedData_v4'];\nfunction walletConnect(options) {\n  const projectId = options && options.version == 2 ? options.projectId : undefined;\n  if (!projectId) {\n    throw new Error('WalletConnect requires a projectId. Please visit https://cloud.walletconnect.com to get one.');\n  }\n  return () => {\n    return {\n      label: 'WalletConnect',\n      getIcon: async () => (await import('./icon.js')).default,\n      getInterface: async _ref => {\n        let {\n          chains,\n          EventEmitter,\n          appMetadata\n        } = _ref;\n        const {\n          ProviderRpcError,\n          ProviderRpcErrorCode\n        } = await import('@web3-onboard/common');\n        const {\n          default: EthereumProvider\n        } = await import('@walletconnect/ethereum-provider');\n        const {\n          Subject,\n          fromEvent\n        } = await import('rxjs');\n        const {\n          takeUntil,\n          take\n        } = await import('rxjs/operators');\n        const getMetaData = () => {\n          if (!appMetadata) return undefined;\n          const wcMetaData = {\n            name: appMetadata.name,\n            description: appMetadata.description || '',\n            url: appMetadata.explore || appMetadata.gettingStartedGuide || '',\n            icons: []\n          };\n          if (appMetadata.icon !== undefined && appMetadata.icon.length) {\n            wcMetaData.icons = [appMetadata.icon];\n          }\n          if (appMetadata.logo !== undefined && appMetadata.logo.length) {\n            wcMetaData.icons = wcMetaData.icons.length ? [...wcMetaData.icons, appMetadata.logo] : [appMetadata.logo];\n          }\n          return wcMetaData;\n        };\n        const connector = await EthereumProvider.init({\n          projectId,\n          metadata: getMetaData(),\n          chains: [1],\n          optionalChains: chains.map(_ref2 => {\n            let {\n              id\n            } = _ref2;\n            return parseInt(id, 16);\n          }),\n          optionalMethods: methods,\n          rpcMap: chains.map(_ref3 => {\n            let {\n              id,\n              rpcUrl\n            } = _ref3;\n            return {\n              id,\n              rpcUrl\n            };\n          }).reduce((rpcMap, _ref4) => {\n            let {\n              id,\n              rpcUrl\n            } = _ref4;\n            rpcMap[parseInt(id, 16)] = rpcUrl;\n            return rpcMap;\n          }, {})\n        });\n        const emitter = new EventEmitter();\n        class EthProvider {\n          constructor(_ref5) {\n            let {\n              connector,\n              chains\n            } = _ref5;\n            this.emit = emitter.emit.bind(emitter);\n            this.on = emitter.on.bind(emitter);\n            this.removeListener = emitter.removeListener.bind(emitter);\n            this.connector = connector;\n            this.chains = chains;\n            this.disconnected$ = new Subject();\n            // listen for accountsChanged\n            fromEvent(this.connector, 'accountsChanged', payload => payload).pipe(takeUntil(this.disconnected$)).subscribe({\n              next: accounts => {\n                this.emit('accountsChanged', accounts);\n              },\n              error: console.warn\n            });\n            // listen for chainChanged\n            fromEvent(this.connector, 'chainChanged', payload => payload).pipe(takeUntil(this.disconnected$)).subscribe({\n              next: chainId => {\n                const hexChainId = `0x${chainId.toString(16)}`;\n                this.emit('chainChanged', hexChainId);\n              },\n              error: console.warn\n            });\n            // listen for disconnect event\n            fromEvent(this.connector, 'session_delete', payload => payload).pipe(takeUntil(this.disconnected$)).subscribe({\n              next: () => {\n                this.emit('accountsChanged', []);\n                this.disconnected$.next(true);\n                typeof localStorage !== 'undefined' && localStorage.removeItem('walletconnect');\n              },\n              error: console.warn\n            });\n            this.disconnect = () => {\n              if (this.connector.session) this.connector.disconnect();\n            };\n            if (options && options.handleUri) {\n              // listen for uri event\n              fromEvent(this.connector, 'display_uri', payload => payload).pipe(takeUntil(this.disconnected$)).subscribe(async uri => {\n                try {\n                  options.handleUri && (await options.handleUri(uri));\n                } catch (error) {\n                  throw `An error occurred when handling the URI. Error: ${error}`;\n                }\n              });\n            }\n            (() => {\n              const session = this.connector.session;\n              if (session) {\n                this.emit('accountsChanged', this.connector.accounts);\n                this.emit('chainChanged', this.connector.chainId);\n              }\n            })();\n            this.request = async _ref6 => {\n              let {\n                method,\n                params\n              } = _ref6;\n              if (method === 'eth_chainId') {\n                return isHexString(this.connector.chainId) ? this.connector.chainId : `0x${this.connector.chainId.toString(16)}`;\n              }\n              if (method === 'eth_requestAccounts') {\n                return new Promise((resolve, reject) => {\n                  // Check if connection is already established\n                  if (!this.connector.session) {\n                    // create new session\n                    this.connector.connect().catch(err => {\n                      console.error('err: ', err);\n                      reject(new ProviderRpcError({\n                        code: 4001,\n                        message: 'User rejected the request.'\n                      }));\n                    });\n                  } else {\n                    // update ethereum provider to load accounts & chainId\n                    const accounts = this.connector.accounts;\n                    const chainId = this.connector.chainId;\n                    const hexChainId = `0x${chainId.toString(16)}`;\n                    this.emit('chainChanged', hexChainId);\n                    return resolve(accounts);\n                  }\n                  // Subscribe to connection events\n                  fromEvent(this.connector, 'connect', payload => payload).pipe(take(1)).subscribe({\n                    next: _ref7 => {\n                      let {\n                        accounts,\n                        chainId\n                      } = _ref7;\n                      this.emit('accountsChanged', accounts);\n                      const hexChainId = isHexString(chainId) ? chainId : `0x${chainId.toString(16)}`;\n                      this.emit('chainChanged', hexChainId);\n                      resolve(accounts);\n                    },\n                    error: reject\n                  });\n                });\n              }\n              if (method === 'eth_selectAccounts') {\n                throw new ProviderRpcError({\n                  code: ProviderRpcErrorCode.UNSUPPORTED_METHOD,\n                  message: `The Provider does not support the requested method: ${method}`\n                });\n              }\n              if (method == 'wallet_switchEthereumChain') {\n                if (!params) {\n                  throw new ProviderRpcError({\n                    code: ProviderRpcErrorCode.INVALID_PARAMS,\n                    message: `The Provider requires a chainId to be passed in as an argument`\n                  });\n                }\n                const chainIdObj = params[0];\n                if (!chainIdObj.hasOwnProperty('chainId') || typeof chainIdObj['chainId'] === 'undefined') {\n                  throw new ProviderRpcError({\n                    code: ProviderRpcErrorCode.INVALID_PARAMS,\n                    message: `The Provider requires a chainId to be passed in as an argument`\n                  });\n                }\n                return this.connector.request({\n                  method: 'wallet_switchEthereumChain',\n                  params: [{\n                    chainId: chainIdObj.chainId\n                  }]\n                });\n              }\n              return this.connector.request({\n                method,\n                params\n              });\n            };\n          }\n        }\n        return {\n          provider: new EthProvider({\n            chains,\n            connector\n          })\n        };\n      }\n    };\n  };\n}\nexport default walletConnect;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}