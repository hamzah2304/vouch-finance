{"ast":null,"code":"import { isHexString } from './index.js';\nfunction walletConnect() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    version: 1\n  };\n  const {\n    bridge = 'https://bridge.walletconnect.org',\n    qrcodeModalOptions,\n    connectFirstChainId,\n    handleUri\n  } = options || {};\n  return () => {\n    return {\n      label: 'WalletConnect',\n      getIcon: async () => (await import('./icon.js')).default,\n      getInterface: async _ref => {\n        let {\n          chains,\n          EventEmitter\n        } = _ref;\n        const {\n          StaticJsonRpcProvider\n        } = await import('@ethersproject/providers');\n        const {\n          ProviderRpcError,\n          ProviderRpcErrorCode\n        } = await import('@web3-onboard/common');\n        const {\n          default: WalletConnect\n        } = await import('@walletconnect/client');\n        // This is a cjs module and therefor depending on build tooling\n        // sometimes it will be nested in the { default } object and\n        // other times it will be the actual import\n        // @ts-ignore - It thinks it is missing properties since it expect it to be nested under default\n        let QRCodeModal = await import('@walletconnect/qrcode-modal');\n        // @ts-ignore - TS thinks that there is no default property on the `QRCodeModal` but sometimes there is\n        QRCodeModal = QRCodeModal.default || QRCodeModal;\n        const {\n          Subject,\n          fromEvent\n        } = await import('rxjs');\n        const {\n          takeUntil,\n          take\n        } = await import('rxjs/operators');\n        const connector = new WalletConnect({\n          bridge\n        });\n        if (handleUri) {\n          try {\n            await handleUri(connector.uri || '');\n          } catch (error) {\n            throw `An error occurred when handling the URI. Error: ${error}`;\n          }\n        }\n        const emitter = new EventEmitter();\n        class EthProvider {\n          constructor(_ref2) {\n            let {\n              connector,\n              chains\n            } = _ref2;\n            this.emit = emitter.emit.bind(emitter);\n            this.on = emitter.on.bind(emitter);\n            this.removeListener = emitter.removeListener.bind(emitter);\n            this.connector = connector;\n            this.chains = chains;\n            this.disconnected$ = new Subject();\n            this.providers = {};\n            // listen for session updates\n            fromEvent(this.connector, 'session_update', (error, payload) => {\n              if (error) {\n                throw error;\n              }\n              return payload;\n            }).pipe(takeUntil(this.disconnected$)).subscribe({\n              next: _ref3 => {\n                let {\n                  params\n                } = _ref3;\n                const [{\n                  accounts,\n                  chainId\n                }] = params;\n                this.emit('accountsChanged', accounts);\n                const hexChainId = isHexString(chainId) ? chainId : `0x${chainId.toString(16)}`;\n                this.emit('chainChanged', hexChainId);\n              },\n              error: console.warn\n            });\n            // listen for disconnect event\n            fromEvent(this.connector, 'disconnect', (error, payload) => {\n              if (error) {\n                throw error;\n              }\n              return payload;\n            }).pipe(takeUntil(this.disconnected$)).subscribe({\n              next: () => {\n                this.emit('accountsChanged', []);\n                this.disconnected$.next(true);\n                typeof localStorage !== 'undefined' && localStorage.removeItem('walletconnect');\n              },\n              error: console.warn\n            });\n            this.disconnect = () => this.connector.killSession();\n            this.request = async _ref4 => {\n              let {\n                method,\n                params\n              } = _ref4;\n              if (method === 'eth_chainId') {\n                return isHexString(this.connector.chainId) ? this.connector.chainId : `0x${this.connector.chainId.toString(16)}`;\n              }\n              if (method === 'eth_requestAccounts') {\n                return new Promise((resolve, reject) => {\n                  // Check if connection is already established\n                  if (!this.connector.connected) {\n                    // create new session\n                    this.connector.createSession(connectFirstChainId ? {\n                      chainId: parseInt(chains[0].id, 16)\n                    } : undefined).then(() => {\n                      QRCodeModal.open(this.connector.uri, () => reject(new ProviderRpcError({\n                        code: 4001,\n                        message: 'User rejected the request.'\n                      })), qrcodeModalOptions);\n                    });\n                  } else {\n                    const {\n                      accounts,\n                      chainId\n                    } = this.connector.session;\n                    const hexChainId = isHexString(chainId) ? chainId : `0x${chainId.toString(16)}`;\n                    this.emit('chainChanged', hexChainId);\n                    return resolve(accounts);\n                  }\n                  // Subscribe to connection events\n                  fromEvent(this.connector, 'connect', (error, payload) => {\n                    if (error) {\n                      throw error;\n                    }\n                    return payload;\n                  }).pipe(take(1)).subscribe({\n                    next: _ref5 => {\n                      let {\n                        params\n                      } = _ref5;\n                      const [{\n                        accounts,\n                        chainId\n                      }] = params;\n                      this.emit('accountsChanged', accounts);\n                      const hexChainId = isHexString(chainId) ? chainId : `0x${chainId.toString(16)}`;\n                      this.emit('chainChanged', hexChainId);\n                      QRCodeModal.close();\n                      resolve(accounts);\n                    },\n                    error: reject\n                  });\n                });\n              }\n              if (method === 'eth_selectAccounts') {\n                throw new ProviderRpcError({\n                  code: ProviderRpcErrorCode.UNSUPPORTED_METHOD,\n                  message: `The Provider does not support the requested method: ${method}`\n                });\n              }\n              if (method == 'wallet_switchEthereumChain') {\n                if (!params) {\n                  throw new ProviderRpcError({\n                    code: ProviderRpcErrorCode.INVALID_PARAMS,\n                    message: `The Provider requires a chainId to be passed in as an argument`\n                  });\n                }\n                const chainIdObj = params[0];\n                if (!chainIdObj.hasOwnProperty('chainId') || typeof chainIdObj['chainId'] === 'undefined') {\n                  throw new ProviderRpcError({\n                    code: ProviderRpcErrorCode.INVALID_PARAMS,\n                    message: `The Provider requires a chainId to be passed in as an argument`\n                  });\n                }\n                return this.connector.sendCustomRequest({\n                  method: 'wallet_switchEthereumChain',\n                  params: [{\n                    chainId: chainIdObj.chainId\n                  }]\n                });\n              }\n              // @ts-ignore\n              if (method === 'eth_sendTransaction') {\n                // @ts-ignore\n                return this.connector.sendTransaction(params[0]);\n              }\n              // @ts-ignore\n              if (method === 'eth_signTransaction') {\n                // @ts-ignore\n                return this.connector.signTransaction(params[0]);\n              }\n              // @ts-ignore\n              if (method === 'personal_sign') {\n                // @ts-ignore\n                return this.connector.signPersonalMessage(params);\n              }\n              // @ts-ignore\n              if (method === 'eth_sign') {\n                // @ts-ignore\n                return this.connector.signMessage(params);\n              }\n              // @ts-ignore\n              if (method.includes('eth_signTypedData')) {\n                // @ts-ignore\n                return this.connector.signTypedData(params);\n              }\n              if (method === 'eth_accounts') {\n                return this.connector.sendCustomRequest({\n                  id: 1337,\n                  jsonrpc: '2.0',\n                  method,\n                  params\n                });\n              }\n              const chainId = await this.request({\n                method: 'eth_chainId'\n              });\n              if (!this.providers[chainId]) {\n                const currentChain = chains.find(_ref6 => {\n                  let {\n                    id\n                  } = _ref6;\n                  return id === chainId;\n                });\n                if (!currentChain) {\n                  throw new ProviderRpcError({\n                    code: ProviderRpcErrorCode.CHAIN_NOT_ADDED,\n                    message: `The Provider does not have a rpcUrl to make a request for the requested method: ${method}`\n                  });\n                }\n                this.providers[chainId] = new StaticJsonRpcProvider(currentChain.rpcUrl);\n              }\n              return this.providers[chainId].send(method,\n              // @ts-ignore\n              params);\n            };\n          }\n        }\n        return {\n          provider: new EthProvider({\n            chains,\n            connector\n          })\n        };\n      }\n    };\n  };\n}\nexport default walletConnect;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}