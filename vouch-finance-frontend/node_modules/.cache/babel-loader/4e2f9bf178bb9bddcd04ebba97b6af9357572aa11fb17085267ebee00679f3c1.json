{"ast":null,"code":"import { Subject, take, firstValueFrom } from 'rxjs';\nimport { v as validateUserEmail } from './index-455620ef.js';\nimport { SofiaProRegular, SofiaProLight } from '@web3-onboard/common';\nimport 'joi';\nfunction noop() {}\nconst identity = x => x;\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || a && typeof a === 'object' || typeof a === 'function';\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nconst is_client = typeof window !== 'undefined';\nlet now = is_client ? () => window.performance.now() : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\nconst tasks = new Set();\nfunction run_tasks(now) {\n  tasks.forEach(task => {\n    if (!task.c(now)) {\n      tasks.delete(task);\n      task.f();\n    }\n  });\n  if (tasks.size !== 0) raf(run_tasks);\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n  let task;\n  if (tasks.size === 0) raf(run_tasks);\n  return {\n    promise: new Promise(fulfill => {\n      tasks.add(task = {\n        c: callback,\n        f: fulfill\n      });\n    }),\n    abort() {\n      tasks.delete(task);\n    }\n  };\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element('style');\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node) return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n  const style_element = element('style');\n  append_stylesheet(get_root_for_style(node), style_element);\n  return style_element.sheet;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  node.parentNode.removeChild(node);\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(' ');\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n}\nfunction children(element) {\n  return Array.from(element.childNodes);\n}\nfunction set_data(text, data) {\n  data = '' + data;\n  if (text.wholeText !== data) text.data = data;\n}\nfunction set_input_value(input, value) {\n  input.value = value == null ? '' : value;\n}\nfunction custom_event(type, detail) {\n  let {\n    bubbles = false,\n    cancelable = false\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const e = document.createEvent('CustomEvent');\n  e.initCustomEvent(type, bubbles, cancelable, detail);\n  return e;\n}\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\nconst managed_styles = new Map();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n  let hash = 5381;\n  let i = str.length;\n  while (i--) hash = (hash << 5) - hash ^ str.charCodeAt(i);\n  return hash >>> 0;\n}\nfunction create_style_information(doc, node) {\n  const info = {\n    stylesheet: append_empty_stylesheet(node),\n    rules: {}\n  };\n  managed_styles.set(doc, info);\n  return info;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn) {\n  let uid = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n  const step = 16.666 / duration;\n  let keyframes = '{\\n';\n  for (let p = 0; p <= 1; p += step) {\n    const t = a + (b - a) * ease(p);\n    keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n  }\n  const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n  const name = `__svelte_${hash(rule)}_${uid}`;\n  const doc = get_root_for_style(node);\n  const {\n    stylesheet,\n    rules\n  } = managed_styles.get(doc) || create_style_information(doc, node);\n  if (!rules[name]) {\n    rules[name] = true;\n    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n  }\n  const animation = node.style.animation || '';\n  node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n  active += 1;\n  return name;\n}\nfunction delete_rule(node, name) {\n  const previous = (node.style.animation || '').split(', ');\n  const next = previous.filter(name ? anim => anim.indexOf(name) < 0 // remove specific animation\n  : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n  );\n\n  const deleted = previous.length - next.length;\n  if (deleted) {\n    node.style.animation = next.join(', ');\n    active -= deleted;\n    if (!active) clear_rules();\n  }\n}\nfunction clear_rules() {\n  raf(() => {\n    if (active) return;\n    managed_styles.forEach(info => {\n      const {\n        ownerNode\n      } = info.stylesheet;\n      // there is no ownerNode if it runs on jsdom.\n      if (ownerNode) detach(ownerNode);\n    });\n    managed_styles.clear();\n  });\n}\nlet current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nconst dirty_components = [];\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n  const saved_component = current_component;\n  do {\n    // first, call beforeUpdate functions\n    // and update components\n    while (flushidx < dirty_components.length) {\n      const component = dirty_components[flushidx];\n      flushidx++;\n      set_current_component(component);\n      update(component.$$);\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length) binding_callbacks.pop()();\n    // then, once components are updated, call\n    // afterUpdate functions. This may cause\n    // subsequent updates...\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        // ...so guard against infinite loops\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nlet promise;\nfunction wait() {\n  if (!promise) {\n    promise = Promise.resolve();\n    promise.then(() => {\n      promise = null;\n    });\n  }\n  return promise;\n}\nfunction dispatch(node, direction, kind) {\n  node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n  outros = {\n    r: 0,\n    c: [],\n    p: outros // parent group\n  };\n}\n\nfunction check_outros() {\n  if (!outros.r) {\n    run_all(outros.c);\n  }\n  outros = outros.p;\n}\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach, callback) {\n  if (block && block.o) {\n    if (outroing.has(block)) return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach) block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nconst null_transition = {\n  duration: 0\n};\nfunction create_bidirectional_transition(node, fn, params, intro) {\n  let config = fn(node, params);\n  let t = intro ? 0 : 1;\n  let running_program = null;\n  let pending_program = null;\n  let animation_name = null;\n  function clear_animation() {\n    if (animation_name) delete_rule(node, animation_name);\n  }\n  function init(program, duration) {\n    const d = program.b - t;\n    duration *= Math.abs(d);\n    return {\n      a: t,\n      b: program.b,\n      d,\n      duration,\n      start: program.start,\n      end: program.start + duration,\n      group: program.group\n    };\n  }\n  function go(b) {\n    const {\n      delay = 0,\n      duration = 300,\n      easing = identity,\n      tick = noop,\n      css\n    } = config || null_transition;\n    const program = {\n      start: now() + delay,\n      b\n    };\n    if (!b) {\n      // @ts-ignore todo: improve typings\n      program.group = outros;\n      outros.r += 1;\n    }\n    if (running_program || pending_program) {\n      pending_program = program;\n    } else {\n      // if this is an intro, and there's a delay, we need to do\n      // an initial tick and/or apply CSS animation immediately\n      if (css) {\n        clear_animation();\n        animation_name = create_rule(node, t, b, duration, delay, easing, css);\n      }\n      if (b) tick(0, 1);\n      running_program = init(program, duration);\n      add_render_callback(() => dispatch(node, b, 'start'));\n      loop(now => {\n        if (pending_program && now > pending_program.start) {\n          running_program = init(pending_program, duration);\n          pending_program = null;\n          dispatch(node, running_program.b, 'start');\n          if (css) {\n            clear_animation();\n            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n          }\n        }\n        if (running_program) {\n          if (now >= running_program.end) {\n            tick(t = running_program.b, 1 - t);\n            dispatch(node, running_program.b, 'end');\n            if (!pending_program) {\n              // we're done\n              if (running_program.b) {\n                // intro — we can tidy up immediately\n                clear_animation();\n              } else {\n                // outro — needs to be coordinated\n                if (! --running_program.group.r) run_all(running_program.group.c);\n              }\n            }\n            running_program = null;\n          } else if (now >= running_program.start) {\n            const p = now - running_program.start;\n            t = running_program.a + running_program.d * easing(p / running_program.duration);\n            tick(t, 1 - t);\n          }\n        }\n        return !!(running_program || pending_program);\n      });\n    }\n  }\n  return {\n    run(b) {\n      if (is_function(config)) {\n        wait().then(() => {\n          // @ts-ignore\n          config = config();\n          go(b);\n        });\n      } else {\n        go(b);\n      }\n    },\n    end() {\n      clear_animation();\n      running_program = pending_program = null;\n    }\n  };\n}\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const {\n    fragment,\n    on_mount,\n    on_destroy,\n    after_update\n  } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    // onMount happens before the initial afterUpdate\n    add_render_callback(() => {\n      const new_on_destroy = on_mount.map(run).filter(is_function);\n      if (on_destroy) {\n        on_destroy.push(...new_on_destroy);\n      } else {\n        // Edge case - component was destroyed immediately,\n        // most likely as a result of a binding initialising\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    // TODO null out other refs, including component.$$ (but need to\n    // preserve final state?)\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles) {\n  let dirty = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [-1];\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: null,\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles && append_styles($$.root);\n  let ready = false;\n  $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {\n    const value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n      if (ready) make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  // `false` as a special case of no DOM component\n  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      const nodes = children(options.target);\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro) transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    flush();\n  }\n  set_current_component(parent_component);\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1) callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n}\nfunction fade(node) {\n  let {\n    delay = 0,\n    duration = 400,\n    easing = identity\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const o = +getComputedStyle(node).opacity;\n  return {\n    delay,\n    duration,\n    easing,\n    css: t => `opacity: ${t * o}`\n  };\n}\nvar closeIcon = `\n  <svg width=\"100%\" height=\"100%\" viewBox=\"0 0 12 12\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M11.6569 1.75736L7.41429 6L11.6569 10.2426L10.2427 11.6569L6.00008 7.41421L1.75744 11.6569L0.343227 10.2426L4.58587 6L0.343227 1.75736L1.75744 0.343146L6.00008 4.58579L10.2427 0.343146L11.6569 1.75736Z\" fill=\"currentColor\"/>\n  </svg>\n`;\n\n/* src/elements/CloseButton.svelte generated by Svelte v3.50.1 */\n\nfunction add_css$2(target) {\n  append_styles(target, \"svelte-h7wb50\", \".close-button-container.svelte-h7wb50{cursor:pointer;display:flex;justify-content:center;align-items:center}.close-button.svelte-h7wb50{width:2rem;height:2rem;box-sizing:border-box;display:flex;justify-content:center;align-items:center;padding:0.4rem;border-radius:40px;color:var(--onboard-gray-400, var(--gray-400));background:var(--onboard-white, var(--white))}.close-icon.svelte-h7wb50{width:14px;display:flex;align-items:center}\");\n}\nfunction create_fragment$2(ctx) {\n  let div2;\n  let div1;\n  let div0;\n  return {\n    c() {\n      div2 = element(\"div\");\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      attr(div0, \"class\", \"close-icon svelte-h7wb50\");\n      attr(div1, \"class\", \"close-button svelte-h7wb50\");\n      attr(div2, \"class\", \"close-button-container svelte-h7wb50\");\n    },\n    m(target, anchor) {\n      insert(target, div2, anchor);\n      append(div2, div1);\n      append(div1, div0);\n      div0.innerHTML = closeIcon;\n    },\n    p: noop,\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) detach(div2);\n    }\n  };\n}\nclass CloseButton extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment$2, safe_not_equal, {}, add_css$2);\n  }\n}\n\n/* src/elements/Spinner.svelte generated by Svelte v3.50.1 */\n\nfunction add_css$1(target) {\n  append_styles(target, \"svelte-febrzt\", \".loading-container.svelte-febrzt.svelte-febrzt{display:flex;flex-direction:column;align-items:center;justify-content:center;font-family:inherit;font-size:inherit;color:inherit;margin:auto}span.svelte-febrzt.svelte-febrzt{font-family:inherit;font-size:0.889em;margin-top:1rem}.loading.svelte-febrzt.svelte-febrzt{display:inline-block;position:relative}.loading.svelte-febrzt div.svelte-febrzt{box-sizing:border-box;font-size:inherit;display:block;position:absolute;border:3px solid;border-radius:50%;animation:svelte-febrzt-bn-loading 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;border-color:currentColor transparent transparent transparent}.loading.svelte-febrzt .loading-first.svelte-febrzt{animation-delay:-0.45s}.loading.svelte-febrzt .loading-second.svelte-febrzt{animation-delay:-0.3s}.loading.svelte-febrzt .loading-third.svelte-febrzt{animation-delay:-0.15s}@keyframes svelte-febrzt-bn-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}\");\n}\n\n// (68:2) {#if description}\nfunction create_if_block$1(ctx) {\n  let span;\n  let t;\n  return {\n    c() {\n      span = element(\"span\");\n      t = text( /*description*/ctx[0]);\n      attr(span, \"class\", \"svelte-febrzt\");\n    },\n    m(target, anchor) {\n      insert(target, span, anchor);\n      append(span, t);\n    },\n    p(ctx, dirty) {\n      if (dirty & /*description*/1) set_data(t, /*description*/ctx[0]);\n    },\n    d(detaching) {\n      if (detaching) detach(span);\n    }\n  };\n}\nfunction create_fragment$1(ctx) {\n  let div4;\n  let div3;\n  let div0;\n  let div0_style_value;\n  let t0;\n  let div1;\n  let div1_style_value;\n  let t1;\n  let div2;\n  let div2_style_value;\n  let div3_style_value;\n  let t2;\n  let if_block = /*description*/ctx[0] && create_if_block$1(ctx);\n  return {\n    c() {\n      div4 = element(\"div\");\n      div3 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      div1 = element(\"div\");\n      t1 = space();\n      div2 = element(\"div\");\n      t2 = space();\n      if (if_block) if_block.c();\n      attr(div0, \"class\", \"loading-first svelte-febrzt\");\n      attr(div0, \"style\", div0_style_value = `height: ${/*size*/ctx[1]}; width: ${/*size*/ctx[1]};`);\n      attr(div1, \"class\", \"loading-second svelte-febrzt\");\n      attr(div1, \"style\", div1_style_value = `height: ${/*size*/ctx[1]}; width: ${/*size*/ctx[1]};`);\n      attr(div2, \"class\", \"loading-third svelte-febrzt\");\n      attr(div2, \"style\", div2_style_value = `height: ${/*size*/ctx[1]}; width: ${/*size*/ctx[1]};`);\n      attr(div3, \"class\", \"loading svelte-febrzt\");\n      attr(div3, \"style\", div3_style_value = `height: ${/*size*/ctx[1]}; width: ${/*size*/ctx[1]};`);\n      attr(div4, \"class\", \"loading-container svelte-febrzt\");\n    },\n    m(target, anchor) {\n      insert(target, div4, anchor);\n      append(div4, div3);\n      append(div3, div0);\n      append(div3, t0);\n      append(div3, div1);\n      append(div3, t1);\n      append(div3, div2);\n      append(div4, t2);\n      if (if_block) if_block.m(div4, null);\n    },\n    p(ctx, _ref) {\n      let [dirty] = _ref;\n      if (dirty & /*size*/2 && div0_style_value !== (div0_style_value = `height: ${/*size*/ctx[1]}; width: ${/*size*/ctx[1]};`)) {\n        attr(div0, \"style\", div0_style_value);\n      }\n      if (dirty & /*size*/2 && div1_style_value !== (div1_style_value = `height: ${/*size*/ctx[1]}; width: ${/*size*/ctx[1]};`)) {\n        attr(div1, \"style\", div1_style_value);\n      }\n      if (dirty & /*size*/2 && div2_style_value !== (div2_style_value = `height: ${/*size*/ctx[1]}; width: ${/*size*/ctx[1]};`)) {\n        attr(div2, \"style\", div2_style_value);\n      }\n      if (dirty & /*size*/2 && div3_style_value !== (div3_style_value = `height: ${/*size*/ctx[1]}; width: ${/*size*/ctx[1]};`)) {\n        attr(div3, \"style\", div3_style_value);\n      }\n      if ( /*description*/ctx[0]) {\n        if (if_block) {\n          if_block.p(ctx, dirty);\n        } else {\n          if_block = create_if_block$1(ctx);\n          if_block.c();\n          if_block.m(div4, null);\n        }\n      } else if (if_block) {\n        if_block.d(1);\n        if_block = null;\n      }\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) detach(div4);\n      if (if_block) if_block.d();\n    }\n  };\n}\nfunction instance$1($$self, $$props, $$invalidate) {\n  let {\n    description = ''\n  } = $$props;\n  let {\n    size = '2rem'\n  } = $$props;\n  $$self.$$set = $$props => {\n    if ('description' in $$props) $$invalidate(0, description = $$props.description);\n    if ('size' in $$props) $$invalidate(1, size = $$props.size);\n  };\n  return [description, size];\n}\nclass Spinner extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance$1, create_fragment$1, safe_not_equal, {\n      description: 0,\n      size: 1\n    }, add_css$1);\n  }\n}\n\n/* src/view/LoginModal.svelte generated by Svelte v3.50.1 */\n\nfunction add_css(target) {\n  append_styles(target, \"svelte-1y81jlz\", \"input[type='text'].svelte-1y81jlz{display:block;margin:0;-moz-appearance:none;-webkit-appearance:none;appearance:none;scrollbar-width:none;width:32rem;padding:0.5rem 2.6rem 0.5rem 1rem;border-radius:8px;font-size:var(\\n      --login-modal-font-size-5,\\n      var(--onboard-font-size-5, var(--font-size-5))\\n    );line-height:var(\\n      --login-modal-font-line-height-1,\\n      var(--font-line-height-1)\\n    );color:var(\\n      --login-modal-gray-500,\\n      var(--onboard-gray-500, var(--gray-500))\\n    );transition:all 200ms ease-in-out;border:2px solid\\n      var(--login-modal-gray-200, var(--onboard-gray-200, var(--gray-200)));box-sizing:border-box;height:3rem;-ms-overflow-style:none}.close-action-container.svelte-1y81jlz{position:absolute;right:0;padding:0.5rem 0.75rem}button.svelte-1y81jlz{align-items:center;padding:0.75rem 1.5rem;color:var(--login-modal-white, var(--onboard-white, var(--white)));border-radius:1.5rem;font-family:var(\\n      --login-modal-font-family-normal,\\n      var(--font-family-normal)\\n    );font-style:normal;font-weight:bold;font-size:var(\\n      --login-modal-font-size-5,\\n      var(--onboard-font-size-5, var(--font-size-5))\\n    );line-height:var(\\n      --login-modal-font-line-height-1,\\n      var(--onboard-line-height-1, var(--line-height-1))\\n    );border:none}.login-btn.svelte-1y81jlz:disabled{background:var(\\n      --login-modal-primary-300,\\n      var(--onboard-primary-300, var(--primary-300))\\n    );cursor:default}.login-btn.svelte-1y81jlz{background:var(\\n      --login-modal-primary-500,\\n      var(--onboard-primary-500, var(--primary-500))\\n    );cursor:pointer;display:inline-flex;justify-content:space-around;width:6rem}.close.svelte-1y81jlz{cursor:pointer}.form-element.svelte-1y81jlz{margin:1rem 0}.container.svelte-1y81jlz{font-family:var(\\n      --login-modal-font-family-normal,\\n      var(--onboard-font-family-normal, var(--font-family-normal))\\n    );color:var(--login-modal-black, var(--onboard-black, var(--black)));top:0;right:0;z-index:var(--onboard-login-modal-z-index, var(--login-modal-z-index));position:absolute;display:flex;align-items:center;justify-content:center;width:100vw;height:100vh;backdrop-filter:blur(4px);background:rgba(0, 0, 0, 0.2)}.onboard-magic-login-modal.svelte-1y81jlz{min-width:36rem;max-height:51.75rem;display:table;background:var(--login-modal-white, var(--onboard-white, var(--white)));box-shadow:var(\\n      --login-modal-shadow-1,\\n      var(--onboard-shadow-1, var(--shadow-1))\\n    );border-radius:1.5rem;text-align:center;background:var(\\n      --login-modal-white,\\n      var(--onboard-white, var(--white))\\n    );color:var(--login-modal-black, var(--onboard-black, var(--black)))}.login-modal-position.svelte-1y81jlz{position:absolute;top:var(--onboard-login-modal-top, var(--login-modal-top));bottom:var(--onboard-login-modal-bottom, var(--login-modal-bottom));left:var(--onboard-login-modal-left, var(--login-modal-left));right:var(--onboard-login-modal-right, var(--login-modal-right))}.modal-controls.svelte-1y81jlz{display:flex;justify-content:space-between;align-items:center;padding:1rem;padding-top:0;flex-direction:column}.branding.svelte-1y81jlz{margin:var(\\n      --login-modal-margin-5,\\n      var(--onboard-margin-5, var(--margin-5))\\n    );display:flex;align-items:center;justify-content:center}.error-msg.svelte-1y81jlz{color:var(\\n      --login-modal-danger-500,\\n      var(--onboard-danger-500, var(--danger-500))\\n    );font-family:var(\\n      --login-modal-font-family-light,\\n      var(--onboard-font-family-light, var(--font-family-light))\\n    )}@media all and (max-width: 520px){.onboard-magic-login-modal.svelte-1y81jlz{min-width:22rem;width:98vw}input[type='text'].svelte-1y81jlz{width:21rem}}\");\n}\n\n// (228:6) {#if errorInEmail}\nfunction create_if_block_1(ctx) {\n  let span;\n  return {\n    c() {\n      span = element(\"span\");\n      span.textContent = \"Please enter a valid email address\";\n      attr(span, \"class\", \"error-msg svelte-1y81jlz\");\n    },\n    m(target, anchor) {\n      insert(target, span, anchor);\n    },\n    d(detaching) {\n      if (detaching) detach(span);\n    }\n  };\n}\n\n// (240:8) {:else}\nfunction create_else_block(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Login\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) detach(t);\n    }\n  };\n}\n\n// (238:8) {#if loading}\nfunction create_if_block(ctx) {\n  let spinner;\n  let current;\n  spinner = new Spinner({\n    props: {\n      size: \"1.5rem\"\n    }\n  });\n  return {\n    c() {\n      create_component(spinner.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(spinner, target, anchor);\n      current = true;\n    },\n    i(local) {\n      if (current) return;\n      transition_in(spinner.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(spinner.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(spinner, detaching);\n    }\n  };\n}\nfunction create_fragment(ctx) {\n  let div3;\n  let div2;\n  let div0;\n  let closebutton;\n  let t0;\n  let h2;\n  let t3;\n  let section;\n  let input;\n  let t4;\n  let t5;\n  let button;\n  let current_block_type_index;\n  let if_block1;\n  let button_disabled_value;\n  let t6;\n  let div1;\n  let div2_transition;\n  let current;\n  let mounted;\n  let dispose;\n  closebutton = new CloseButton({});\n  let if_block0 = /*errorInEmail*/ctx[1] && create_if_block_1();\n  const if_block_creators = [create_if_block, create_else_block];\n  const if_blocks = [];\n  function select_block_type(ctx, dirty) {\n    if ( /*loading*/ctx[2]) return 0;\n    return 1;\n  }\n  current_block_type_index = select_block_type(ctx);\n  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n  return {\n    c() {\n      div3 = element(\"div\");\n      div2 = element(\"div\");\n      div0 = element(\"div\");\n      create_component(closebutton.$$.fragment);\n      t0 = space();\n      h2 = element(\"h2\");\n      h2.textContent = `${/*walletName*/ctx[3]} Login`;\n      t3 = space();\n      section = element(\"section\");\n      input = element(\"input\");\n      t4 = space();\n      if (if_block0) if_block0.c();\n      t5 = space();\n      button = element(\"button\");\n      if_block1.c();\n      t6 = space();\n      div1 = element(\"div\");\n      attr(div0, \"class\", \"close-action-container close svelte-1y81jlz\");\n      attr(input, \"type\", \"text\");\n      attr(input, \"class\", \"login-credentials form-element svelte-1y81jlz\");\n      attr(input, \"placeholder\", \"Email address\");\n      attr(button, \"class\", \"login-btn form-element svelte-1y81jlz\");\n      attr(button, \"id\", \"connect-accounts\");\n      button.disabled = button_disabled_value = ! /*credentials*/ctx[0];\n      attr(section, \"class\", \"modal-controls svelte-1y81jlz\");\n      attr(div1, \"class\", \"branding svelte-1y81jlz\");\n      attr(div2, \"class\", \"onboard-magic-login-modal login-modal-position svelte-1y81jlz\");\n      attr(div3, \"class\", \"container svelte-1y81jlz\");\n    },\n    m(target, anchor) {\n      insert(target, div3, anchor);\n      append(div3, div2);\n      append(div2, div0);\n      mount_component(closebutton, div0, null);\n      append(div2, t0);\n      append(div2, h2);\n      append(div2, t3);\n      append(div2, section);\n      append(section, input);\n      set_input_value(input, /*credentials*/ctx[0]);\n      append(section, t4);\n      if (if_block0) if_block0.m(section, null);\n      append(section, t5);\n      append(section, button);\n      if_blocks[current_block_type_index].m(button, null);\n      append(div2, t6);\n      append(div2, div1);\n      div1.innerHTML = /*brandingHTMLString*/ctx[4];\n      current = true;\n      if (!mounted) {\n        dispose = [listen(div0, \"click\", /*dismiss*/ctx[7]), listen(input, \"input\", /*input_input_handler*/ctx[11]), listen(input, \"input\", /*input_handler*/ctx[12]), listen(input, \"keydown\", /*submitOnEnter*/ctx[8]), listen(button, \"click\", /*click_handler*/ctx[13])];\n        mounted = true;\n      }\n    },\n    p(ctx, _ref2) {\n      let [dirty] = _ref2;\n      if (dirty & /*credentials*/1 && input.value !== /*credentials*/ctx[0]) {\n        set_input_value(input, /*credentials*/ctx[0]);\n      }\n      if ( /*errorInEmail*/ctx[1]) {\n        if (if_block0) ;else {\n          if_block0 = create_if_block_1();\n          if_block0.c();\n          if_block0.m(section, t5);\n        }\n      } else if (if_block0) {\n        if_block0.d(1);\n        if_block0 = null;\n      }\n      let previous_block_index = current_block_type_index;\n      current_block_type_index = select_block_type(ctx);\n      if (current_block_type_index !== previous_block_index) {\n        group_outros();\n        transition_out(if_blocks[previous_block_index], 1, 1, () => {\n          if_blocks[previous_block_index] = null;\n        });\n        check_outros();\n        if_block1 = if_blocks[current_block_type_index];\n        if (!if_block1) {\n          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n          if_block1.c();\n        }\n        transition_in(if_block1, 1);\n        if_block1.m(button, null);\n      }\n      if (!current || dirty & /*credentials*/1 && button_disabled_value !== (button_disabled_value = ! /*credentials*/ctx[0])) {\n        button.disabled = button_disabled_value;\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(closebutton.$$.fragment, local);\n      transition_in(if_block1);\n      add_render_callback(() => {\n        if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fade, {}, true);\n        div2_transition.run(1);\n      });\n      current = true;\n    },\n    o(local) {\n      transition_out(closebutton.$$.fragment, local);\n      transition_out(if_block1);\n      if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fade, {}, false);\n      div2_transition.run(0);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) detach(div3);\n      destroy_component(closebutton);\n      if (if_block0) if_block0.d();\n      if_blocks[current_block_type_index].d();\n      if (detaching && div2_transition) div2_transition.end();\n      mounted = false;\n      run_all(dispose);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let credentials = '';\n  let {\n    loginOptions\n  } = $$props;\n  let {\n    loggedIn$\n  } = $$props;\n  const {\n    walletName,\n    brandingHTMLString,\n    emailLoginFunction\n  } = loginOptions;\n  let errorInEmail = false;\n  let loading = false;\n  const setErrorInEmail = () => {\n    if (!errorInEmail) return;\n    $$invalidate(1, errorInEmail = false);\n  };\n  const validateEmail = value => {\n    return validateUserEmail(value);\n  };\n  const login = async () => {\n    $$invalidate(2, loading = true);\n    if (validateEmail(credentials)) {\n      $$invalidate(1, errorInEmail = true);\n      $$invalidate(2, loading = false);\n      return;\n    }\n    const loginResponse = await emailLoginFunction(credentials);\n    $$invalidate(2, loading = false);\n    loggedIn$.next(loginResponse);\n  };\n  const dismiss = () => {\n    loggedIn$.next(false);\n    $$invalidate(2, loading = false);\n  };\n  const submitOnEnter = e => {\n    if (e.key === 'Enter') {\n      login();\n    }\n  };\n  function input_input_handler() {\n    credentials = this.value;\n    $$invalidate(0, credentials);\n  }\n  const input_handler = () => setErrorInEmail();\n  const click_handler = () => login();\n  $$self.$$set = $$props => {\n    if ('loginOptions' in $$props) $$invalidate(9, loginOptions = $$props.loginOptions);\n    if ('loggedIn$' in $$props) $$invalidate(10, loggedIn$ = $$props.loggedIn$);\n  };\n  return [credentials, errorInEmail, loading, walletName, brandingHTMLString, setErrorInEmail, login, dismiss, submitOnEnter, loginOptions, loggedIn$, input_input_handler, input_handler, click_handler];\n}\nclass LoginModal extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {\n      loginOptions: 9,\n      loggedIn$: 10\n    }, add_css);\n  }\n}\nconst loggedIn$ = new Subject();\n\n// eslint-disable-next-line max-len\nconst loginModal = async options => {\n  if (options) {\n    const error = !options;\n    if (error) {\n      throw error;\n    }\n  }\n  const app = mountLoginModal(options, loggedIn$);\n  loggedIn$.pipe(take(1)).subscribe(() => {\n    app.$destroy();\n    const modalEl = document.body.querySelector('onboard-magic-login-modal');\n    modalEl && document.body.removeChild(modalEl);\n  });\n  return firstValueFrom(loggedIn$);\n};\n// eslint-disable-next-line max-len\nconst mountLoginModal = (loginOptions, loggedIn$) => {\n  class loginModalEl extends HTMLElement {\n    constructor() {\n      super();\n    }\n  }\n  if (!customElements.get('onboard-magic-login-modal')) {\n    customElements.define('onboard-magic-login-modal', loginModalEl);\n  }\n  // Add Fonts to main page\n  const styleEl = document.createElement('style');\n  styleEl.innerHTML = `\n    ${SofiaProRegular}\n    ${SofiaProLight}\n  `;\n  document.body.appendChild(styleEl);\n  // add to DOM\n  const loginModalDomElement = document.createElement('onboard-magic-login-modal');\n  const target = loginModalDomElement.attachShadow({\n    mode: 'open'\n  });\n  loginModalDomElement.style.all = 'initial';\n  target.innerHTML = `\n    <style>\n      :host {  \n        /* COLORS */\n        --white: white;\n        --black: black;\n        --primary-300: #b1b8f2;\n        --primary-500: #6370e5;\n        --gray-200: #c2c4c9;\n        --gray-500: #33394b;\n        --danger-500: #ff4f4f;\n\n        /* FONTS */\n        --font-family-normal: Sofia Pro;\n        --font-family-light: Sofia Pro Light;\n        --font-size-5: 1rem;\n        --font-line-height-1: 24px;\n\n        /* SPACING */\n        --margin-4: 1rem;\n        --margin-5: 0.5rem;\n\n        /* MODAL POSITION */\n        --login-modal-z-index: 25;\n        --login-modal-top: unset;\n        --login-modal-right: unset;\n        --login-modal-bottom: unset;\n        --login-modal-left: unset;\n      }\n\n    </style>\n  `;\n  document.body.appendChild(loginModalDomElement);\n  const app = new LoginModal({\n    target: target,\n    props: {\n      loginOptions,\n      loggedIn$\n    }\n  });\n  return app;\n};\nexport { loginModal as default };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}