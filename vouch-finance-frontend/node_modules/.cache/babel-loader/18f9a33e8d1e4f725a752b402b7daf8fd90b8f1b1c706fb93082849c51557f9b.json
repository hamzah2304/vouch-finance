{"ast":null,"code":"import { writable as e, derived as n } from \"svelte/store\";\nimport t from \"deepmerge\";\nimport o from \"intl-messageformat\";\nconst i = {},\n  r = (e, n, t) => t ? (n in i || (i[n] = {}), e in i[n] || (i[n][e] = t), t) : t,\n  s = (e, n) => {\n    if (null == n) return;\n    if (n in i && e in i[n]) return i[n][e];\n    const t = E(n);\n    for (let o = 0; o < t.length; o++) {\n      const i = c(t[o], e);\n      if (i) return r(e, n, i);\n    }\n  };\nlet l;\nconst a = e({});\nfunction u(e) {\n  return e in l;\n}\nfunction c(e, n) {\n  if (!u(e)) return null;\n  const t = function (e) {\n    return l[e] || null;\n  }(e);\n  return function (e, n) {\n    if (null == n) return;\n    if (n in e) return e[n];\n    const t = n.split(\".\");\n    let o = e;\n    for (let e = 0; e < t.length; e++) if (\"object\" == typeof o) {\n      if (e > 0) {\n        const n = t.slice(e, t.length).join(\".\");\n        if (n in o) {\n          o = o[n];\n          break;\n        }\n      }\n      o = o[t[e]];\n    } else o = void 0;\n    return o;\n  }(t, n);\n}\nfunction m(e) {\n  for (var _len = arguments.length, n = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    n[_key - 1] = arguments[_key];\n  }\n  delete i[e], a.update(o => (o[e] = t.all([o[e] || {}, ...n]), o));\n}\nconst f = n([a], _ref => {\n  let [e] = _ref;\n  return Object.keys(e);\n});\na.subscribe(e => l = e);\nconst d = {};\nfunction g(e) {\n  return d[e];\n}\nfunction h(e) {\n  return null != e && E(e).some(e => {\n    var n;\n    return null === (n = g(e)) || void 0 === n ? void 0 : n.size;\n  });\n}\nfunction w(e, n) {\n  const t = Promise.all(n.map(n => (function (e, n) {\n    d[e].delete(n), 0 === d[e].size && delete d[e];\n  }(e, n), n().then(e => e.default || e))));\n  return t.then(n => m(e, ...n));\n}\nconst p = {};\nfunction b(e) {\n  if (!h(e)) return e in p ? p[e] : Promise.resolve();\n  const n = function (e) {\n    return E(e).map(e => {\n      const n = g(e);\n      return [e, n ? [...n] : []];\n    }).filter(_ref2 => {\n      let [, e] = _ref2;\n      return e.length > 0;\n    });\n  }(e);\n  return p[e] = Promise.all(n.map(_ref3 => {\n    let [e, n] = _ref3;\n    return w(e, n);\n  })).then(() => {\n    if (h(e)) return b(e);\n    delete p[e];\n  }), p[e];\n}\nfunction y(e, n) {\n  g(e) || function (e) {\n    d[e] = new Set();\n  }(e);\n  const t = g(e);\n  g(e).has(n) || (u(e) || a.update(n => (n[e] = {}, n)), t.add(n));\n}\nfunction v(_ref4) {\n  let {\n    locale: e,\n    id: n\n  } = _ref4;\n  console.warn(`[svelte-i18n] The message \"${n}\" was not found in \"${E(e).join('\", \"')}\".${h(D()) ? \"\\n\\nNote: there are at least one loader still registered to this locale that wasn't executed.\" : \"\"}`);\n}\nconst M = {\n  fallbackLocale: null,\n  loadingDelay: 200,\n  formats: {\n    number: {\n      scientific: {\n        notation: \"scientific\"\n      },\n      engineering: {\n        notation: \"engineering\"\n      },\n      compactLong: {\n        notation: \"compact\",\n        compactDisplay: \"long\"\n      },\n      compactShort: {\n        notation: \"compact\",\n        compactDisplay: \"short\"\n      }\n    },\n    date: {\n      short: {\n        month: \"numeric\",\n        day: \"numeric\",\n        year: \"2-digit\"\n      },\n      medium: {\n        month: \"short\",\n        day: \"numeric\",\n        year: \"numeric\"\n      },\n      long: {\n        month: \"long\",\n        day: \"numeric\",\n        year: \"numeric\"\n      },\n      full: {\n        weekday: \"long\",\n        month: \"long\",\n        day: \"numeric\",\n        year: \"numeric\"\n      }\n    },\n    time: {\n      short: {\n        hour: \"numeric\",\n        minute: \"numeric\"\n      },\n      medium: {\n        hour: \"numeric\",\n        minute: \"numeric\",\n        second: \"numeric\"\n      },\n      long: {\n        hour: \"numeric\",\n        minute: \"numeric\",\n        second: \"numeric\",\n        timeZoneName: \"short\"\n      },\n      full: {\n        hour: \"numeric\",\n        minute: \"numeric\",\n        second: \"numeric\",\n        timeZoneName: \"short\"\n      }\n    }\n  },\n  warnOnMissingMessages: !0,\n  handleMissingMessage: void 0,\n  ignoreTag: !0\n};\nfunction j() {\n  return M;\n}\nfunction O(e) {\n  const {\n      formats: n,\n      ...t\n    } = e,\n    o = e.initialLocale || e.fallbackLocale;\n  return t.warnOnMissingMessages && (delete t.warnOnMissingMessages, null == t.handleMissingMessage ? t.handleMissingMessage = v : console.warn('[svelte-i18n] The \"warnOnMissingMessages\" option is deprecated. Please use the \"handleMissingMessage\" option instead.')), Object.assign(M, t, {\n    initialLocale: o\n  }), n && (\"number\" in n && Object.assign(M.formats.number, n.number), \"date\" in n && Object.assign(M.formats.date, n.date), \"time\" in n && Object.assign(M.formats.time, n.time)), x.set(o);\n}\nconst $ = e(!1);\nlet k;\nconst T = e(null);\nfunction L(e) {\n  return e.split(\"-\").map((e, n, t) => t.slice(0, n + 1).join(\"-\")).reverse();\n}\nfunction E(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : j().fallbackLocale;\n  const t = L(e);\n  return n ? [...new Set([...t, ...L(n)])] : t;\n}\nfunction D() {\n  return null != k ? k : void 0;\n}\nT.subscribe(e => {\n  k = null != e ? e : void 0, \"undefined\" != typeof window && null != e && document.documentElement.setAttribute(\"lang\", e);\n});\nconst x = {\n    ...T,\n    set: e => {\n      if (e && function (e) {\n        if (null == e) return;\n        const n = E(e);\n        for (let e = 0; e < n.length; e++) {\n          const t = n[e];\n          if (u(t)) return t;\n        }\n      }(e) && h(e)) {\n        const {\n          loadingDelay: n\n        } = j();\n        let t;\n        return \"undefined\" != typeof window && null != D() && n ? t = window.setTimeout(() => $.set(!0), n) : $.set(!0), b(e).then(() => {\n          T.set(e);\n        }).finally(() => {\n          clearTimeout(t), $.set(!1);\n        });\n      }\n      return T.set(e);\n    }\n  },\n  N = (e, n) => {\n    const t = e.split(\"&\").find(e => 0 === e.indexOf(`${n}=`));\n    return t ? t.split(\"=\").pop() : null;\n  },\n  A = (e, n) => {\n    const t = n.exec(e);\n    return t && t[1] || null;\n  },\n  P = e => \"undefined\" == typeof window ? null : A(window.location.hostname, e),\n  S = e => \"undefined\" == typeof window ? null : A(window.location.pathname, e),\n  z = () => \"undefined\" == typeof window ? null : window.navigator.language || window.navigator.languages[0],\n  F = e => \"undefined\" == typeof window ? null : N(window.location.search.substr(1), e),\n  I = e => \"undefined\" == typeof window ? null : N(window.location.hash.substr(1), e),\n  Z = e => {\n    const n = Object.create(null);\n    return t => {\n      const o = JSON.stringify(t);\n      return o in n ? n[o] : n[o] = e(t);\n    };\n  },\n  C = (e, n) => {\n    const {\n      formats: t\n    } = j();\n    if (e in t && n in t[e]) return t[e][n];\n    throw new Error(`[svelte-i18n] Unknown \"${n}\" ${e} format.`);\n  },\n  G = Z(_ref5 => {\n    let {\n      locale: e,\n      format: n,\n      ...t\n    } = _ref5;\n    if (null == e) throw new Error('[svelte-i18n] A \"locale\" must be set to format numbers');\n    return n && (t = C(\"number\", n)), new Intl.NumberFormat(e, t);\n  }),\n  J = Z(_ref6 => {\n    let {\n      locale: e,\n      format: n,\n      ...t\n    } = _ref6;\n    if (null == e) throw new Error('[svelte-i18n] A \"locale\" must be set to format dates');\n    return n ? t = C(\"date\", n) : 0 === Object.keys(t).length && (t = C(\"date\", \"short\")), new Intl.DateTimeFormat(e, t);\n  }),\n  U = Z(_ref7 => {\n    let {\n      locale: e,\n      format: n,\n      ...t\n    } = _ref7;\n    if (null == e) throw new Error('[svelte-i18n] A \"locale\" must be set to format time values');\n    return n ? t = C(\"time\", n) : 0 === Object.keys(t).length && (t = C(\"time\", \"short\")), new Intl.DateTimeFormat(e, t);\n  }),\n  V = function () {\n    let {\n      locale: e = D(),\n      ...n\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return G({\n      locale: e,\n      ...n\n    });\n  },\n  _ = function () {\n    let {\n      locale: e = D(),\n      ...n\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return J({\n      locale: e,\n      ...n\n    });\n  },\n  q = function () {\n    let {\n      locale: e = D(),\n      ...n\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return U({\n      locale: e,\n      ...n\n    });\n  },\n  B = Z(function (e) {\n    let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : D();\n    return new o(e, n, j().formats, {\n      ignoreTag: j().ignoreTag\n    });\n  }),\n  H = function (e) {\n    let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var t, o, i, r;\n    let l = n;\n    \"object\" == typeof e && (l = e, e = l.id);\n    const {\n      values: a,\n      locale: u = D(),\n      default: c\n    } = l;\n    if (null == u) throw new Error(\"[svelte-i18n] Cannot format a message without first setting the initial locale.\");\n    let m = s(e, u);\n    if (m) {\n      if (\"string\" != typeof m) return console.warn(`[svelte-i18n] Message with id \"${e}\" must be of type \"string\", found: \"${typeof m}\". Gettin its value through the \"$format\" method is deprecated; use the \"json\" method instead.`), m;\n    } else m = null !== (r = null !== (i = null === (o = (t = j()).handleMissingMessage) || void 0 === o ? void 0 : o.call(t, {\n      locale: u,\n      id: e,\n      defaultValue: c\n    })) && void 0 !== i ? i : c) && void 0 !== r ? r : e;\n    if (!a) return m;\n    let f = m;\n    try {\n      f = B(m, u).format(a);\n    } catch (n) {\n      n instanceof Error && console.warn(`[svelte-i18n] Message \"${e}\" has syntax error:`, n.message);\n    }\n    return f;\n  },\n  K = (e, n) => q(n).format(e),\n  Q = (e, n) => _(n).format(e),\n  R = (e, n) => V(n).format(e),\n  W = function (e) {\n    let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : D();\n    return s(e, n);\n  },\n  X = n([x, a], () => H),\n  Y = n([x], () => K),\n  ee = n([x], () => Q),\n  ne = n([x], () => R),\n  te = n([x, a], () => W);\nfunction oe(e) {\n  let n;\n  const t = e.subscribe(e => n = e),\n    o = function () {\n      return n(...arguments);\n    };\n  return o.freeze = t, o;\n}\nfunction ie(e) {\n  return e;\n}\nfunction re(e) {\n  return b(e || D() || j().initialLocale);\n}\nexport { X as _, m as addMessages, ee as date, ie as defineMessages, a as dictionary, X as format, _ as getDateFormatter, I as getLocaleFromHash, P as getLocaleFromHostname, z as getLocaleFromNavigator, S as getLocaleFromPathname, F as getLocaleFromQueryString, B as getMessageFormatter, V as getNumberFormatter, q as getTimeFormatter, O as init, $ as isLoading, te as json, x as locale, f as locales, ne as number, y as register, X as t, Y as time, oe as unwrapFunctionStore, re as waitLocale };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}