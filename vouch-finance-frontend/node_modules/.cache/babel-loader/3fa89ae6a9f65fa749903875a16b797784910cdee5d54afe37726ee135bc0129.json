{"ast":null,"code":"import { isBrowser, getLocation, getQueryString, detectEnv, appendToQueryString } from \"@walletconnect/utils\";\nimport NetworkMonitor from \"./network\";\nconst WS = typeof global.WebSocket !== \"undefined\" ? global.WebSocket : require(\"ws\");\nclass SocketTransport {\n  constructor(opts) {\n    this.opts = opts;\n    this._queue = [];\n    this._events = [];\n    this._subscriptions = [];\n    this._protocol = opts.protocol;\n    this._version = opts.version;\n    this._url = \"\";\n    this._netMonitor = null;\n    this._socket = null;\n    this._nextSocket = null;\n    this._subscriptions = opts.subscriptions || [];\n    this._netMonitor = opts.netMonitor || new NetworkMonitor();\n    if (!opts.url || typeof opts.url !== \"string\") {\n      throw new Error(\"Missing or invalid WebSocket url\");\n    }\n    this._url = opts.url;\n    this._netMonitor.on(\"online\", () => this._socketCreate());\n  }\n  set readyState(value) {}\n  get readyState() {\n    return this._socket ? this._socket.readyState : -1;\n  }\n  set connecting(value) {}\n  get connecting() {\n    return this.readyState === 0;\n  }\n  set connected(value) {}\n  get connected() {\n    return this.readyState === 1;\n  }\n  set closing(value) {}\n  get closing() {\n    return this.readyState === 2;\n  }\n  set closed(value) {}\n  get closed() {\n    return this.readyState === 3;\n  }\n  open() {\n    this._socketCreate();\n  }\n  close() {\n    this._socketClose();\n  }\n  send(message, topic, silent) {\n    if (!topic || typeof topic !== \"string\") {\n      throw new Error(\"Missing or invalid topic field\");\n    }\n    this._socketSend({\n      topic: topic,\n      type: \"pub\",\n      payload: message,\n      silent: !!silent\n    });\n  }\n  subscribe(topic) {\n    this._socketSend({\n      topic: topic,\n      type: \"sub\",\n      payload: \"\",\n      silent: true\n    });\n  }\n  on(event, callback) {\n    this._events.push({\n      event,\n      callback\n    });\n  }\n  _socketCreate() {\n    if (this._nextSocket) {\n      return;\n    }\n    const url = getWebSocketUrl(this._url, this._protocol, this._version);\n    this._nextSocket = new WS(url);\n    if (!this._nextSocket) {\n      throw new Error(\"Failed to create socket\");\n    }\n    this._nextSocket.onmessage = event => this._socketReceive(event);\n    this._nextSocket.onopen = () => this._socketOpen();\n    this._nextSocket.onerror = event => this._socketError(event);\n    this._nextSocket.onclose = () => {\n      setTimeout(() => {\n        this._nextSocket = null;\n        this._socketCreate();\n      }, 1000);\n    };\n  }\n  _socketOpen() {\n    this._socketClose();\n    this._socket = this._nextSocket;\n    this._nextSocket = null;\n    this._queueSubscriptions();\n    this._pushQueue();\n  }\n  _socketClose() {\n    if (this._socket) {\n      this._socket.onclose = () => {};\n      this._socket.close();\n    }\n  }\n  _socketSend(socketMessage) {\n    const message = JSON.stringify(socketMessage);\n    if (this._socket && this._socket.readyState === 1) {\n      this._socket.send(message);\n    } else {\n      this._setToQueue(socketMessage);\n      this._socketCreate();\n    }\n  }\n  async _socketReceive(event) {\n    let socketMessage;\n    try {\n      socketMessage = JSON.parse(event.data);\n    } catch (error) {\n      return;\n    }\n    this._socketSend({\n      topic: socketMessage.topic,\n      type: \"ack\",\n      payload: \"\",\n      silent: true\n    });\n    if (this._socket && this._socket.readyState === 1) {\n      const events = this._events.filter(event => event.event === \"message\");\n      if (events && events.length) {\n        events.forEach(event => event.callback(socketMessage));\n      }\n    }\n  }\n  _socketError(e) {\n    const events = this._events.filter(event => event.event === \"error\");\n    if (events && events.length) {\n      events.forEach(event => event.callback(e));\n    }\n  }\n  _queueSubscriptions() {\n    const subscriptions = this._subscriptions;\n    subscriptions.forEach(topic => this._queue.push({\n      topic: topic,\n      type: \"sub\",\n      payload: \"\",\n      silent: true\n    }));\n    this._subscriptions = this.opts.subscriptions || [];\n  }\n  _setToQueue(socketMessage) {\n    this._queue.push(socketMessage);\n  }\n  _pushQueue() {\n    const queue = this._queue;\n    queue.forEach(socketMessage => this._socketSend(socketMessage));\n    this._queue = [];\n  }\n}\nfunction getWebSocketUrl(_url, protocol, version) {\n  var _a, _b;\n  const url = _url.startsWith(\"https\") ? _url.replace(\"https\", \"wss\") : _url.startsWith(\"http\") ? _url.replace(\"http\", \"ws\") : _url;\n  const splitUrl = url.split(\"?\");\n  const params = isBrowser() ? {\n    protocol,\n    version,\n    env: \"browser\",\n    host: ((_a = getLocation()) === null || _a === void 0 ? void 0 : _a.host) || \"\"\n  } : {\n    protocol,\n    version,\n    env: ((_b = detectEnv()) === null || _b === void 0 ? void 0 : _b.name) || \"\"\n  };\n  const queryString = appendToQueryString(getQueryString(splitUrl[1] || \"\"), params);\n  return splitUrl[0] + \"?\" + queryString;\n}\nexport default SocketTransport;\n//# sourceMappingURL=index.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}