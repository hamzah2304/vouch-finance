{"ast":null,"code":"const util = require('./util');\nconst abi = require('./abi');\nconst TYPED_MESSAGE_SCHEMA = {\n  type: 'object',\n  properties: {\n    types: {\n      type: 'object',\n      additionalProperties: {\n        type: 'array',\n        items: {\n          type: 'object',\n          properties: {\n            name: {\n              type: 'string'\n            },\n            type: {\n              type: 'string'\n            }\n          },\n          required: ['name', 'type']\n        }\n      }\n    },\n    primaryType: {\n      type: 'string'\n    },\n    domain: {\n      type: 'object'\n    },\n    message: {\n      type: 'object'\n    }\n  },\n  required: ['types', 'primaryType', 'domain', 'message']\n};\n\n/**\n * A collection of utility functions used for signing typed data\n */\nconst TypedDataUtils = {\n  /**\n   * Encodes an object by encoding and concatenating each of its members\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of an object\n   */\n  encodeData(primaryType, data, types) {\n    let useV4 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    const encodedTypes = ['bytes32'];\n    const encodedValues = [this.hashType(primaryType, types)];\n    if (useV4) {\n      const encodeField = (name, type, value) => {\n        if (types[type] !== undefined) {\n          return ['bytes32', value == null ? '0x0000000000000000000000000000000000000000000000000000000000000000' : util.keccak(this.encodeData(type, value, types, useV4))];\n        }\n        if (value === undefined) throw new Error(`missing value for field ${name} of type ${type}`);\n        if (type === 'bytes') {\n          return ['bytes32', util.keccak(value)];\n        }\n        if (type === 'string') {\n          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n          if (typeof value === 'string') {\n            value = Buffer.from(value, 'utf8');\n          }\n          return ['bytes32', util.keccak(value)];\n        }\n        if (type.lastIndexOf(']') === type.length - 1) {\n          const parsedType = type.slice(0, type.lastIndexOf('['));\n          const typeValuePairs = value.map(item => encodeField(name, parsedType, item));\n          return ['bytes32', util.keccak(abi.rawEncode(typeValuePairs.map(_ref => {\n            let [type] = _ref;\n            return type;\n          }), typeValuePairs.map(_ref2 => {\n            let [, value] = _ref2;\n            return value;\n          })))];\n        }\n        return [type, value];\n      };\n      for (const field of types[primaryType]) {\n        const [type, value] = encodeField(field.name, field.type, data[field.name]);\n        encodedTypes.push(type);\n        encodedValues.push(value);\n      }\n    } else {\n      for (const field of types[primaryType]) {\n        let value = data[field.name];\n        if (value !== undefined) {\n          if (field.type === 'bytes') {\n            encodedTypes.push('bytes32');\n            value = util.keccak(value);\n            encodedValues.push(value);\n          } else if (field.type === 'string') {\n            encodedTypes.push('bytes32');\n            // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex\n            if (typeof value === 'string') {\n              value = Buffer.from(value, 'utf8');\n            }\n            value = util.keccak(value);\n            encodedValues.push(value);\n          } else if (types[field.type] !== undefined) {\n            encodedTypes.push('bytes32');\n            value = util.keccak(this.encodeData(field.type, value, types, useV4));\n            encodedValues.push(value);\n          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {\n            throw new Error('Arrays currently unimplemented in encodeData');\n          } else {\n            encodedTypes.push(field.type);\n            encodedValues.push(value);\n          }\n        }\n      }\n    }\n    return abi.rawEncode(encodedTypes, encodedValues);\n  },\n  /**\n   * Encodes the type of an object by encoding a comma delimited list of its members\n   *\n   * @param {string} primaryType - Root type to encode\n   * @param {Object} types - Type definitions\n   * @returns {string} - Encoded representation of the type of an object\n   */\n  encodeType(primaryType, types) {\n    let result = '';\n    let deps = this.findTypeDependencies(primaryType, types).filter(dep => dep !== primaryType);\n    deps = [primaryType].concat(deps.sort());\n    for (const type of deps) {\n      const children = types[type];\n      if (!children) {\n        throw new Error('No type definition specified: ' + type);\n      }\n      result += type + '(' + types[type].map(_ref3 => {\n        let {\n          name,\n          type\n        } = _ref3;\n        return type + ' ' + name;\n      }).join(',') + ')';\n    }\n    return result;\n  },\n  /**\n   * Finds all types within a type defintion object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} types - Type definitions\n   * @param {Array} results - current set of accumulated types\n   * @returns {Array} - Set of all types found in the type definition\n   */\n  findTypeDependencies(primaryType, types) {\n    let results = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    primaryType = primaryType.match(/^\\w*/)[0];\n    if (results.includes(primaryType) || types[primaryType] === undefined) {\n      return results;\n    }\n    results.push(primaryType);\n    for (const field of types[primaryType]) {\n      for (const dep of this.findTypeDependencies(field.type, types, results)) {\n        !results.includes(dep) && results.push(dep);\n      }\n    }\n    return results;\n  },\n  /**\n   * Hashes an object\n   *\n   * @param {string} primaryType - Root type\n   * @param {Object} data - Object to hash\n   * @param {Object} types - Type definitions\n   * @returns {string} - Hash of an object\n   */\n  hashStruct(primaryType, data, types) {\n    let useV4 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    return util.keccak(this.encodeData(primaryType, data, types, useV4));\n  },\n  /**\n   * Hashes the type of an object\n   *\n   * @param {string} primaryType - Root type to hash\n   * @param {Object} types - Type definitions\n   * @returns {string} - Hash of an object\n   */\n  hashType(primaryType, types) {\n    return util.keccak(this.encodeType(primaryType, types));\n  },\n  /**\n   * Removes properties from a message object that are not defined per EIP-712\n   *\n   * @param {Object} data - typed message object\n   * @returns {Object} - typed message object with only allowed fields\n   */\n  sanitizeData(data) {\n    const sanitizedData = {};\n    for (const key in TYPED_MESSAGE_SCHEMA.properties) {\n      data[key] && (sanitizedData[key] = data[key]);\n    }\n    if (sanitizedData.types) {\n      sanitizedData.types = Object.assign({\n        EIP712Domain: []\n      }, sanitizedData.types);\n    }\n    return sanitizedData;\n  },\n  /**\n   * Returns the hash of a typed message as per EIP-712 for signing\n   *\n   * @param {Object} typedData - Types message data to sign\n   * @returns {string} - sha3 hash for signing\n   */\n  hash(typedData) {\n    let useV4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const sanitizedData = this.sanitizeData(typedData);\n    const parts = [Buffer.from('1901', 'hex')];\n    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4));\n    if (sanitizedData.primaryType !== 'EIP712Domain') {\n      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));\n    }\n    return util.keccak(Buffer.concat(parts));\n  }\n};\nmodule.exports = {\n  TYPED_MESSAGE_SCHEMA,\n  TypedDataUtils,\n  hashForSignTypedDataLegacy: function (msgParams) {\n    return typedSignatureHashLegacy(msgParams.data);\n  },\n  hashForSignTypedData_v3: function (msgParams) {\n    return TypedDataUtils.hash(msgParams.data, false);\n  },\n  hashForSignTypedData_v4: function (msgParams) {\n    return TypedDataUtils.hash(msgParams.data);\n  }\n};\n\n/**\n * @param typedData - Array of data along with types, as per EIP712.\n * @returns Buffer\n */\nfunction typedSignatureHashLegacy(typedData) {\n  const error = new Error('Expect argument to be non-empty array');\n  if (typeof typedData !== 'object' || !typedData.length) throw error;\n  const data = typedData.map(function (e) {\n    return e.type === 'bytes' ? util.toBuffer(e.value) : e.value;\n  });\n  const types = typedData.map(function (e) {\n    return e.type;\n  });\n  const schema = typedData.map(function (e) {\n    if (!e.name) throw error;\n    return e.type + ' ' + e.name;\n  });\n  return abi.soliditySHA3(['bytes32', 'bytes32'], [abi.soliditySHA3(new Array(typedData.length).fill('string'), schema), abi.soliditySHA3(types, data)]);\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}