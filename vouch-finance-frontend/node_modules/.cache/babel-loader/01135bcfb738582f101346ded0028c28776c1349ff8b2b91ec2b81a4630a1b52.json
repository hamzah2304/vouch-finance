{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { useState, useEffect, useCallback } from \"react\";\nimport { useLocalStorage } from \"./hooks\";\nconst error = message => {\n  throw new Error(\"[Bundle error] \" + message);\n};\nexport const useBundle = (auth, api, track) => {\n  const {\n    account: {\n      address,\n      logged\n    }\n  } = auth;\n  const [accountBundle, setAccountBundle] = useState();\n  const [bundleInProgress, setBundleInProgress] = useState();\n  const [restoredAuthAccount, setRestoredAuthAccount] = useState();\n  const [restoreCheck, setRestoreCheck] = useState(false);\n  const [isRestored, setIsRestored] = useState(false);\n  const [storedBundleInProgressAddresses, setStoredBundleInProgressAddresses] = useLocalStorage(\"bundle-in-progress-addresses\", []);\n  const getAddresses = bundle => bundle ? [bundle.primaryAddress, ...bundle.secondaryAddresses].map(_ => _ === null || _ === void 0 ? void 0 : _.toLowerCase()) : null;\n  const bundleAddresses = getAddresses(accountBundle);\n  const bundleInProgressAddresses = getAddresses(bundleInProgress);\n  // Helpers\n  const checkBundleAuthAddress = addresses => {\n    var _a;\n    if (addresses) {\n      if (address && addresses.includes(address) && auth.tokens.getToken(address)) {\n        return address;\n      }\n      const secondary = addresses.map(_ => ({\n        address: _,\n        signature: auth.tokens.getToken(_)\n      }));\n      return ((_a = secondary.find(_ => !!_.signature)) === null || _a === void 0 ? void 0 : _a.address) || false;\n    }\n    return false;\n  };\n  // Name/nickname methods\n  const nameAvailable = useCallback(name => {\n    return api.checkBundleName(name).then(() => false).catch(() => true);\n  }, []);\n  // Common methods\n  const createBundle = useCallback((name, isPublic, anonymous, skipImpersonation) => {\n    if (skipImpersonation) api.skipImpersonationOnNextRequest();\n    return api.createBundle(name, isPublic, anonymous).then(bundle => {\n      setAccountBundle(bundle);\n      setBundleInProgress(bundle);\n      return bundle;\n    });\n  }, []);\n  const updateBundle = useCallback((name, isPublic, anonymous, skipImpersonation) => {\n    if (!bundleInProgress) return error(`Bundle information is not provided`);\n    if (skipImpersonation) api.skipImpersonationOnNextRequest();\n    return api.updateBundle(bundleInProgress.id, name, isPublic, anonymous).then(bundle => {\n      loadBundleAccountStatus();\n      if (!skipImpersonation) {\n        setBundleInProgress(bundle);\n      }\n      return bundle;\n    });\n  }, [bundleInProgress]);\n  const switchAnonymous = useCallback((anonymous, skipImpersonation, bundle) => {\n    let usedBundle = bundleInProgress;\n    if (skipImpersonation) {\n      api.skipImpersonationOnNextRequest();\n      usedBundle = bundle;\n    }\n    if (!usedBundle) return error(`Bundle information is not provided`);\n    return api.updateBundle(usedBundle.id, usedBundle.name, usedBundle.isPublic, anonymous).then(bundle => {\n      loadBundleAccountStatus();\n      if (!skipImpersonation) {\n        setBundleInProgress(bundle);\n      }\n      return bundle;\n    });\n  }, [bundleInProgress]);\n  const deleteBundle = useCallback((bundleId, skipImpersonation) => {\n    if (!bundleInProgress && !bundleId) return error(`Bundle in progress is undefined`);\n    if (skipImpersonation) api.skipImpersonationOnNextRequest();\n    return api.deleteBundle(bundleId || (bundleInProgress === null || bundleInProgress === void 0 ? void 0 : bundleInProgress.id)).then(() => {\n      loadBundleAccountStatus();\n      if (!skipImpersonation) {\n        setBundleInProgress(undefined);\n      }\n    });\n  }, [bundleInProgress]);\n  const calculateBundleScore = useCallback(() => {\n    if (!bundleInProgress) return error(`Bundle information is not provided`);\n    return api.calculateBundleScore(bundleInProgress.id).then(bundle => {\n      loadBundleAccountStatus();\n      setBundleInProgress(bundle);\n      return bundle;\n    }).then(bundle => {\n      if (bundle.score) return bundle;\n      return new Promise(resolve => {\n        let count = 10;\n        let interval; // eslint-disable-line\n        const check = () => api.getBundles().then(_ref => {\n          let [b] = _ref;\n          if (!count--) {\n            clearInterval(interval);\n            error(\"Calculation timeout\");\n          }\n          if (b.score) {\n            clearInterval(interval);\n            setBundleInProgress(b);\n            resolve(undefined);\n          }\n        });\n        setTimeout(check, 1 * 1000);\n        setTimeout(check, 6 * 1000);\n        interval = setInterval(check, 20 * 1000);\n      });\n    });\n  }, [bundleInProgress]);\n  // Bundle addresses\n  const addAddressToBundle = useCallback(skipImpersonation => {\n    if (accountBundle) return error(`Account is part of a bundle`);\n    if (!bundleInProgress) return error(`Bundle in progress is undefined`);\n    if (skipImpersonation) api.skipImpersonationOnNextRequest();\n    const signature = auth.account.signature || auth.tokens.getSignature(auth.account.address);\n    if (!signature) return error(`Signature is not available`);\n    return api.addBundleAddress(bundleInProgress.id, auth.account.address, signature).then(bundle => {\n      setBundleInProgress(bundle);\n      loadBundleAccountStatus(true);\n      track.addAddressToBundle();\n      return bundle;\n    });\n  }, [accountBundle, bundleInProgress, auth.account]);\n  const removeAddressFromBundle = useCallback((address, bundleId, skipImpersonation) => {\n    if (!bundleInProgress) return error(`Account is not part of a bundle`);\n    if (!bundleInProgress && !bundleId) return error(`Bundle in progress is undefined`);\n    if (skipImpersonation) api.skipImpersonationOnNextRequest();\n    return api.removeBundleAddress(bundleId || (bundleInProgress === null || bundleInProgress === void 0 ? void 0 : bundleInProgress.id), address).then(bundle => {\n      loadBundleAccountStatus();\n      if (!bundleId && bundleInProgress) {\n        const newBundleInProgress = Object.assign(Object.assign({}, bundleInProgress), {\n          secondaryAddresses: bundleInProgress.secondaryAddresses.filter(_ => _.toLowerCase() !== address.toLowerCase())\n        });\n        setBundleInProgress(newBundleInProgress);\n      }\n      return bundle;\n    });\n  }, [bundleInProgress, bundleInProgress]);\n  const setPrimaryAddress = useCallback((address, skipImpersonation) => {\n    if (!bundleInProgress) return error(`Bundle in progress is undefined`);\n    if (skipImpersonation) api.skipImpersonationOnNextRequest();\n    return api.setMasterWallet(bundleInProgress.id, address).then(bundle => {\n      loadBundleAccountStatus(true);\n      return bundle;\n    });\n  }, [bundleInProgress]);\n  // Quick bundle creation or addition\n  const quickCreationOrAddition = useCallback((name, isPublic, anonymous) => __awaiter(void 0, void 0, void 0, function* () {\n    const signature = auth.account.signature || auth.tokens.getSignature(auth.account.address);\n    if (!signature) return error(`Signature is not available`);\n    api.skipImpersonationOnNextRequest();\n    const [accountBundle] = yield api.getBundles();\n    if (accountBundle === null || accountBundle === void 0 ? void 0 : accountBundle.isMinted) return error(`Account bundle is already minted`);\n    if (!bundleInProgress && !accountBundle) {\n      api.skipImpersonationOnNextRequest();\n      const bundle = yield api.createBundle(name, isPublic, anonymous);\n      setAccountBundle(bundle);\n      setBundleInProgress(bundle);\n    } else if (bundleInProgress === null || bundleInProgress === void 0 ? void 0 : bundleInProgress.id) {\n      console.log({\n        accountBundle,\n        bundleInProgress\n      });\n      if (!!accountBundle && accountBundle.id !== bundleInProgress.id) {\n        console.log(\"Bundle deletion\");\n        console.log({\n          accountBundle,\n          bundleInProgress\n        });\n        api.skipImpersonationOnNextRequest();\n        yield api.deleteBundle(accountBundle.id);\n      }\n      yield api.addBundleAddress(bundleInProgress.id, auth.account.address, signature).then(bundle => {\n        setBundleInProgress(bundle);\n        loadBundleAccountStatus(true);\n        track.addAddressToBundle();\n        return bundle;\n      });\n    }\n  }), [bundleInProgress, auth.account.address]);\n  // Bundle minting\n  const markAsMint = useCallback((bundleId, skipImpersonation) => {\n    if (!bundleInProgress && !bundleId) return error(`Bundle in progress is undefined`);\n    if (skipImpersonation) api.skipImpersonationOnNextRequest();\n    return api.mintBundle(bundleId || (bundleInProgress === null || bundleInProgress === void 0 ? void 0 : bundleInProgress.id)).then(bundle => {\n      loadBundleAccountStatus();\n      if (!skipImpersonation) {\n        setBundleInProgress(undefined);\n        setRestoredAuthAccount(undefined);\n      }\n      return bundle;\n    });\n  }, [bundleInProgress]);\n  // Bundle in progress methods\n  const useAccountBundle = useCallback(() => {\n    setBundleInProgress(accountBundle);\n    setRestoredAuthAccount(undefined);\n    setIsRestored(false);\n  }, [setBundleInProgress, accountBundle]);\n  const clearBundleInProgress = useCallback(() => {\n    setBundleInProgress(undefined);\n    setRestoredAuthAccount(undefined);\n    setIsRestored(false);\n  }, [setBundleInProgress]);\n  // Load bundle account status\n  const loadBundleAccountStatus = useCallback(function () {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let timeout;\n    if (address && logged || (accountBundle === null || accountBundle === void 0 ? void 0 : accountBundle.isMinted)) {\n      timeout = setTimeout(() => setAccountBundle(undefined), 1000);\n    }\n    if (address && logged) {\n      api.skipImpersonationOnNextRequest();\n      api.getBundles().then(bundles => {\n        if (bundles.length) {\n          clearTimeout(timeout);\n          setAccountBundle(bundles[0]);\n          if ((!bundleInProgress || force) && !bundles[0].isMinted) {\n            setBundleInProgress(bundles[0]);\n          }\n        }\n      });\n    }\n  }, [address, logged, bundleInProgress, accountBundle]);\n  useEffect(() => loadBundleAccountStatus(), [address, logged]);\n  // Store and recover bundle in progress\n  useEffect(() => {\n    const serialize = addresses => (addresses || []).map(_ => _.toLowerCase()).sort().join();\n    const changed = serialize(bundleInProgressAddresses) !== serialize(storedBundleInProgressAddresses);\n    if (bundleInProgressAddresses && changed) {\n      setStoredBundleInProgressAddresses(bundleInProgressAddresses);\n    }\n  }, [bundleInProgressAddresses, storedBundleInProgressAddresses]);\n  useEffect(() => {\n    const restoredAuth = checkBundleAuthAddress(storedBundleInProgressAddresses);\n    if (address && !restoreCheck) {\n      setRestoreCheck(true);\n      if (restoredAuth && restoredAuth !== address) {\n        setRestoredAuthAccount(restoredAuth);\n        // Bypass core flow to be able to restore the bundle using a stored token\n        api.updateImpersonatedToken(auth.tokens.getToken(restoredAuth));\n        api.getBundles().then(bundles => {\n          if (bundles.length) {\n            if (!bundles[0].isMinted) {\n              setIsRestored(true);\n              setBundleInProgress(bundles[0]);\n            } else {\n              setRestoredAuthAccount(undefined);\n            }\n          }\n        });\n      }\n    }\n  }, [address, restoreCheck]);\n  useEffect(() => {\n    setIsRestored(false);\n  }, [address]);\n  // Bundle auth account\n  const bundleAuthAddress = checkBundleAuthAddress(bundleInProgressAddresses || []) || restoredAuthAccount;\n  // Service\n  const aId = accountBundle === null || accountBundle === void 0 ? void 0 : accountBundle.id;\n  const pId = bundleInProgress === null || bundleInProgress === void 0 ? void 0 : bundleInProgress.id;\n  return {\n    account: {\n      address,\n      bundle: accountBundle,\n      bundleAddresses,\n      isInBundleInProgress: (bundleInProgressAddresses || []).includes(address),\n      isPrimaryInOwnBundle: address === (accountBundle === null || accountBundle === void 0 ? void 0 : accountBundle.primaryAddress.toLowerCase()),\n      bundleMismatch: accountBundle && (aId !== null && aId !== void 0 ? aId : pId) !== (pId !== null && pId !== void 0 ? pId : aId),\n      minted: !!(accountBundle === null || accountBundle === void 0 ? void 0 : accountBundle.isMinted)\n    },\n    bundle: bundleInProgress,\n    bundleAddresses: bundleInProgressAddresses,\n    bundleIsRestored: isRestored,\n    isNotRestored: () => setIsRestored(false),\n    bundleAuth: {\n      isAuth: !!bundleAuthAddress,\n      authAccount: bundleAuthAddress,\n      authAccountToken: bundleAuthAddress && auth.tokens.getToken(bundleAuthAddress) || undefined\n    },\n    useAccountBundle,\n    clearBundleInProgress,\n    nameAvailable,\n    quickCreationOrAddition,\n    createBundle,\n    updateBundle,\n    switchAnonymous,\n    deleteBundle,\n    calculateBundleScore,\n    markAsMint,\n    addAddressToBundle,\n    removeAddressFromBundle,\n    setPrimaryAddress\n  };\n};\n//# sourceMappingURL=bundle.hook.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}