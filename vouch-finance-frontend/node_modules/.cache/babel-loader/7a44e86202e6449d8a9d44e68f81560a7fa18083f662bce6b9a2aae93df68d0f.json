{"ast":null,"code":"const e = Symbol(),\n  t = Symbol(),\n  r = \"a\",\n  n = \"w\";\nlet o = (e, t) => new Proxy(e, t);\nconst s = Object.getPrototypeOf,\n  c = new WeakMap(),\n  l = e => e && (c.has(e) ? c.get(e) : s(e) === Object.prototype || s(e) === Array.prototype),\n  f = e => \"object\" == typeof e && null !== e,\n  i = new WeakMap(),\n  a = e => e[t] || e,\n  u = (c, f, p) => {\n    if (!l(c)) return c;\n    const y = a(c),\n      g = (e => Object.isFrozen(e) || Object.values(Object.getOwnPropertyDescriptors(e)).some(e => !e.writable))(y);\n    let h = p && p.get(y);\n    return h && h[1].f === g || (h = ((o, s) => {\n      const c = {\n        f: s\n      };\n      let l = !1;\n      const f = (e, t) => {\n          if (!l) {\n            let s = c[r].get(o);\n            if (s || (s = {}, c[r].set(o, s)), e === n) s[n] = !0;else {\n              let r = s[e];\n              r || (r = new Set(), s[e] = r), r.add(t);\n            }\n          }\n        },\n        i = {\n          get: (e, n) => n === t ? o : (f(\"k\", n), u(Reflect.get(e, n), c[r], c.c)),\n          has: (t, n) => n === e ? (l = !0, c[r].delete(o), !0) : (f(\"h\", n), Reflect.has(t, n)),\n          getOwnPropertyDescriptor: (e, t) => (f(\"o\", t), Reflect.getOwnPropertyDescriptor(e, t)),\n          ownKeys: e => (f(n), Reflect.ownKeys(e))\n        };\n      return s && (i.set = i.deleteProperty = () => !1), [i, c];\n    })(y, g), h[1].p = o(g ? (e => {\n      let t = i.get(e);\n      if (!t) {\n        if (Array.isArray(e)) t = Array.from(e);else {\n          const r = Object.getOwnPropertyDescriptors(e);\n          Object.values(r).forEach(e => {\n            e.configurable = !0;\n          }), t = Object.create(s(e), r);\n        }\n        i.set(e, t);\n      }\n      return t;\n    })(y) : y, h[0]), p && p.set(y, h)), h[1][r] = f, h[1].c = p, h[1].p;\n  },\n  p = (e, t, r, o) => {\n    if (Object.is(e, t)) return !1;\n    if (!f(e) || !f(t)) return !0;\n    const s = r.get(a(e));\n    if (!s) return !0;\n    if (o) {\n      const r = o.get(e);\n      if (r && r.n === t) return r.g;\n      o.set(e, {\n        n: t,\n        g: !1\n      });\n    }\n    let c = null;\n    try {\n      for (const r of s.h || []) if (c = Reflect.has(e, r) !== Reflect.has(t, r), c) return c;\n      if (!0 === s[n]) {\n        if (c = ((e, t) => {\n          const r = Reflect.ownKeys(e),\n            n = Reflect.ownKeys(t);\n          return r.length !== n.length || r.some((e, t) => e !== n[t]);\n        })(e, t), c) return c;\n      } else for (const r of s.o || []) if (c = !!Reflect.getOwnPropertyDescriptor(e, r) != !!Reflect.getOwnPropertyDescriptor(t, r), c) return c;\n      for (const n of s.k || []) if (c = p(e[n], t[n], r, o), c) return c;\n      return null === c && (c = !0), c;\n    } finally {\n      o && o.set(e, {\n        n: t,\n        g: c\n      });\n    }\n  },\n  y = t => !!l(t) && e in t,\n  g = e => l(e) && e[t] || null,\n  h = function (e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n    c.set(e, t);\n  },\n  w = (e, t, r) => {\n    const o = [],\n      s = new WeakSet(),\n      c = (e, l) => {\n        if (s.has(e)) return;\n        f(e) && s.add(e);\n        const i = f(e) && t.get(a(e));\n        if (i) {\n          var u, p;\n          if (null == (u = i.h) || u.forEach(e => {\n            const t = `:has(${String(e)})`;\n            o.push(l ? [...l, t] : [t]);\n          }), !0 === i[n]) {\n            const e = \":ownKeys\";\n            o.push(l ? [...l, e] : [e]);\n          } else {\n            var y;\n            null == (y = i.o) || y.forEach(e => {\n              const t = `:hasOwn(${String(e)})`;\n              o.push(l ? [...l, t] : [t]);\n            });\n          }\n          null == (p = i.k) || p.forEach(t => {\n            r && !(\"value\" in (Object.getOwnPropertyDescriptor(e, t) || {})) || c(e[t], l ? [...l, t] : [t]);\n          });\n        } else l && o.push(l);\n      };\n    return c(e), o;\n  },\n  O = e => {\n    o = e;\n  };\nexport { w as affectedToPathList, u as createProxy, g as getUntracked, p as isChanged, h as markToTrack, O as replaceNewProxy, y as trackMemo };\n//# sourceMappingURL=index.modern.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}