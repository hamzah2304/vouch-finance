{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPriorityConnector = exports.getSelectedConnector = exports.initializeConnector = void 0;\nconst store_1 = require(\"@web3-react/store\");\nconst react_1 = require(\"react\");\nconst zustand_1 = __importDefault(require(\"zustand\"));\nlet DynamicProvider;\nfunction importProvider() {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (DynamicProvider === undefined) {\n      try {\n        const {\n          Web3Provider\n        } = yield Promise.resolve().then(() => __importStar(require('@ethersproject/providers')));\n        DynamicProvider = Web3Provider;\n      } catch (_a) {\n        console.debug('@ethersproject/providers not available');\n        DynamicProvider = null;\n      }\n    }\n  });\n}\n/**\n * Wraps the initialization of a `connector`. Creates a zustand `store` with `actions` bound to it, and then passes\n * these to the connector as specified in `f`. Also creates a variety of `hooks` bound to this `store`.\n *\n * @typeParam T - The type of the `connector` returned from `f`.\n * @param f - A function which is called with `actions` bound to the returned `store`.\n * @returns [connector, hooks, store] - The initialized connector, a variety of hooks, and a zustand store.\n */\nfunction initializeConnector(f) {\n  const [store, actions] = (0, store_1.createWeb3ReactStoreAndActions)();\n  const connector = f(actions);\n  const useConnector = (0, zustand_1.default)(store);\n  const stateHooks = getStateHooks(useConnector);\n  const derivedHooks = getDerivedHooks(stateHooks);\n  const augmentedHooks = getAugmentedHooks(connector, stateHooks, derivedHooks);\n  return [connector, Object.assign(Object.assign(Object.assign({}, stateHooks), derivedHooks), augmentedHooks), store];\n}\nexports.initializeConnector = initializeConnector;\nfunction computeIsActive(_ref) {\n  let {\n    chainId,\n    accounts,\n    activating\n  } = _ref;\n  return Boolean(chainId && accounts && !activating);\n}\n/**\n * Creates a variety of convenience `hooks` that return data associated with a particular passed connector.\n *\n * @param initializedConnectors - Two or more [connector, hooks(, store)] arrays, as returned from initializeConnector.\n * @returns hooks - A variety of convenience hooks that wrap the hooks returned from initializeConnector.\n */\nfunction getSelectedConnector() {\n  for (var _len = arguments.length, initializedConnectors = new Array(_len), _key = 0; _key < _len; _key++) {\n    initializedConnectors[_key] = arguments[_key];\n  }\n  function getIndex(connector) {\n    const index = initializedConnectors.findIndex(_ref2 => {\n      let [initializedConnector] = _ref2;\n      return connector === initializedConnector;\n    });\n    if (index === -1) throw new Error('Connector not found');\n    return index;\n  }\n  function useSelectedStore(connector) {\n    const store = initializedConnectors[getIndex(connector)][2];\n    if (!store) throw new Error('Stores not passed');\n    return store;\n  }\n  // the following code calls hooks in a map a lot, which violates the eslint rule.\n  // this is ok, though, because initializedConnectors never changes, so the same hooks are called each time\n  function useSelectedChainId(connector) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const values = initializedConnectors.map(_ref3 => {\n      let [, {\n        useChainId\n      }] = _ref3;\n      return useChainId();\n    });\n    return values[getIndex(connector)];\n  }\n  function useSelectedAccounts(connector) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const values = initializedConnectors.map(_ref4 => {\n      let [, {\n        useAccounts\n      }] = _ref4;\n      return useAccounts();\n    });\n    return values[getIndex(connector)];\n  }\n  function useSelectedIsActivating(connector) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const values = initializedConnectors.map(_ref5 => {\n      let [, {\n        useIsActivating\n      }] = _ref5;\n      return useIsActivating();\n    });\n    return values[getIndex(connector)];\n  }\n  function useSelectedAccount(connector) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const values = initializedConnectors.map(_ref6 => {\n      let [, {\n        useAccount\n      }] = _ref6;\n      return useAccount();\n    });\n    return values[getIndex(connector)];\n  }\n  function useSelectedIsActive(connector) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const values = initializedConnectors.map(_ref7 => {\n      let [, {\n        useIsActive\n      }] = _ref7;\n      return useIsActive();\n    });\n    return values[getIndex(connector)];\n  }\n  /**\n   * @typeParam T - A type argument must only be provided if one or more of the connectors passed to\n   * getSelectedConnector is using `connector.customProvider`, in which case it must match every possible type of this\n   * property, over all connectors.\n   */\n  function useSelectedProvider(connector, network) {\n    const index = getIndex(connector);\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const values = initializedConnectors.map((_ref8, i) => {\n      let [, {\n        useProvider\n      }] = _ref8;\n      return useProvider(network, i === index);\n    });\n    return values[index];\n  }\n  function useSelectedENSNames(connector, provider) {\n    const index = getIndex(connector);\n    const values = initializedConnectors.map((_ref9, i) => {\n      let [, {\n        useENSNames\n      }] = _ref9;\n      return (\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        useENSNames(i === index ? provider : undefined)\n      );\n    });\n    return values[index];\n  }\n  function useSelectedENSName(connector, provider) {\n    const index = getIndex(connector);\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const values = initializedConnectors.map((_ref10, i) => {\n      let [, {\n        useENSName\n      }] = _ref10;\n      return useENSName(i === index ? provider : undefined);\n    });\n    return values[index];\n  }\n  return {\n    useSelectedStore,\n    useSelectedChainId,\n    useSelectedAccounts,\n    useSelectedIsActivating,\n    useSelectedAccount,\n    useSelectedIsActive,\n    useSelectedProvider,\n    useSelectedENSNames,\n    useSelectedENSName\n  };\n}\nexports.getSelectedConnector = getSelectedConnector;\n/**\n * Creates a variety of convenience `hooks` that return data associated with the first of the `initializedConnectors`\n * that is active.\n *\n * @param initializedConnectors - Two or more [connector, hooks(, store)] arrays, as returned from initializeConnector.\n * @returns hooks - A variety of convenience hooks that wrap the hooks returned from initializeConnector.\n */\nfunction getPriorityConnector() {\n  for (var _len2 = arguments.length, initializedConnectors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    initializedConnectors[_key2] = arguments[_key2];\n  }\n  const {\n    useSelectedStore,\n    useSelectedChainId,\n    useSelectedAccounts,\n    useSelectedIsActivating,\n    useSelectedAccount,\n    useSelectedIsActive,\n    useSelectedProvider,\n    useSelectedENSNames,\n    useSelectedENSName\n  } = getSelectedConnector(...initializedConnectors);\n  function usePriorityConnector() {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const values = initializedConnectors.map(_ref11 => {\n      let [, {\n        useIsActive\n      }] = _ref11;\n      return useIsActive();\n    });\n    const index = values.findIndex(isActive => isActive);\n    return initializedConnectors[index === -1 ? 0 : index][0];\n  }\n  function usePriorityStore() {\n    return useSelectedStore(usePriorityConnector());\n  }\n  function usePriorityChainId() {\n    return useSelectedChainId(usePriorityConnector());\n  }\n  function usePriorityAccounts() {\n    return useSelectedAccounts(usePriorityConnector());\n  }\n  function usePriorityIsActivating() {\n    return useSelectedIsActivating(usePriorityConnector());\n  }\n  function usePriorityAccount() {\n    return useSelectedAccount(usePriorityConnector());\n  }\n  function usePriorityIsActive() {\n    return useSelectedIsActive(usePriorityConnector());\n  }\n  /**\n   * @typeParam T - A type argument must only be provided if one or more of the connectors passed to\n   * getPriorityConnector is using `connector.customProvider`, in which case it must match every possible type of this\n   * property, over all connectors.\n   */\n  function usePriorityProvider(network) {\n    return useSelectedProvider(usePriorityConnector(), network);\n  }\n  function usePriorityENSNames(provider) {\n    return useSelectedENSNames(usePriorityConnector(), provider);\n  }\n  function usePriorityENSName(provider) {\n    return useSelectedENSName(usePriorityConnector(), provider);\n  }\n  return {\n    useSelectedStore,\n    useSelectedChainId,\n    useSelectedAccounts,\n    useSelectedIsActivating,\n    useSelectedAccount,\n    useSelectedIsActive,\n    useSelectedProvider,\n    useSelectedENSNames,\n    useSelectedENSName,\n    usePriorityConnector,\n    usePriorityStore,\n    usePriorityChainId,\n    usePriorityAccounts,\n    usePriorityIsActivating,\n    usePriorityAccount,\n    usePriorityIsActive,\n    usePriorityProvider,\n    usePriorityENSNames,\n    usePriorityENSName\n  };\n}\nexports.getPriorityConnector = getPriorityConnector;\nconst CHAIN_ID = _ref12 => {\n  let {\n    chainId\n  } = _ref12;\n  return chainId;\n};\nconst ACCOUNTS = _ref13 => {\n  let {\n    accounts\n  } = _ref13;\n  return accounts;\n};\nconst ACCOUNTS_EQUALITY_CHECKER = (oldAccounts, newAccounts) => oldAccounts === undefined && newAccounts === undefined || oldAccounts !== undefined && oldAccounts.length === (newAccounts === null || newAccounts === void 0 ? void 0 : newAccounts.length) && oldAccounts.every((oldAccount, i) => oldAccount === newAccounts[i]);\nconst ACTIVATING = _ref14 => {\n  let {\n    activating\n  } = _ref14;\n  return activating;\n};\nfunction getStateHooks(useConnector) {\n  function useChainId() {\n    return useConnector(CHAIN_ID);\n  }\n  function useAccounts() {\n    return useConnector(ACCOUNTS, ACCOUNTS_EQUALITY_CHECKER);\n  }\n  function useIsActivating() {\n    return useConnector(ACTIVATING);\n  }\n  return {\n    useChainId,\n    useAccounts,\n    useIsActivating\n  };\n}\nfunction getDerivedHooks(_ref15) {\n  let {\n    useChainId,\n    useAccounts,\n    useIsActivating\n  } = _ref15;\n  function useAccount() {\n    var _a;\n    return (_a = useAccounts()) === null || _a === void 0 ? void 0 : _a[0];\n  }\n  function useIsActive() {\n    const chainId = useChainId();\n    const accounts = useAccounts();\n    const activating = useIsActivating();\n    return computeIsActive({\n      chainId,\n      accounts,\n      activating\n    });\n  }\n  return {\n    useAccount,\n    useIsActive\n  };\n}\n/**\n * @returns ENSNames - An array of length `accounts.length` which contains entries which are either all `undefined`,\n * indicated that names cannot be fetched because there's no provider, or they're in the process of being fetched,\n * or `string | null`, depending on whether an ENS name has been set for the account in question or not.\n */\nfunction useENS(provider) {\n  let accounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const [ENSNames, setENSNames] = (0, react_1.useState)();\n  (0, react_1.useEffect)(() => {\n    if (provider && accounts.length) {\n      let stale = false;\n      Promise.all(accounts.map(account => provider.lookupAddress(account))).then(ENSNames => {\n        if (stale) return;\n        setENSNames(ENSNames);\n      }).catch(error => {\n        if (stale) return;\n        console.debug('Could not fetch ENS names', error);\n        setENSNames(new Array(accounts.length).fill(null));\n      });\n      return () => {\n        stale = true;\n        setENSNames(undefined);\n      };\n    }\n  }, [provider, accounts]);\n  return ENSNames !== null && ENSNames !== void 0 ? ENSNames : new Array(accounts.length).fill(undefined);\n}\nfunction getAugmentedHooks(connector, _ref16, _ref17) {\n  let {\n    useAccounts,\n    useChainId\n  } = _ref16;\n  let {\n    useAccount,\n    useIsActive\n  } = _ref17;\n  /**\n   * Avoid type erasure by returning the most qualified type if not otherwise set.\n   * Note that this function's return type is `T | undefined`, but there is a code path\n   * that returns a Web3Provider, which could conflict with a user-provided T. So,\n   * it's important that users only provide an override for T if they know that\n   * `connector.customProvider` is going to be defined and of type T.\n   *\n   * @typeParam T - A type argument must only be provided if using `connector.customProvider`, in which case it\n   * must match the type of this property.\n   */\n  function useProvider(network) {\n    let enabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const isActive = useIsActive();\n    const chainId = useChainId();\n    // ensure that Provider is going to be available when loaded if @ethersproject/providers is installed\n    const [loaded, setLoaded] = (0, react_1.useState)(DynamicProvider !== undefined);\n    (0, react_1.useEffect)(() => {\n      if (loaded) return;\n      let stale = false;\n      void importProvider().then(() => {\n        if (stale) return;\n        setLoaded(true);\n      });\n      return () => {\n        stale = true;\n      };\n    }, [loaded]);\n    return (0, react_1.useMemo)(() => {\n      // to ensure connectors remain fresh, we condition re-renders on loaded, isActive and chainId\n      void loaded && isActive && chainId;\n      if (enabled) {\n        if (connector.customProvider) return connector.customProvider;\n        // see tsdoc note above for return type explanation.\n        else if (DynamicProvider && connector.provider) return new DynamicProvider(connector.provider, network);\n      }\n    }, [loaded, enabled, isActive, chainId, network]);\n  }\n  function useENSNames(provider) {\n    const accounts = useAccounts();\n    return useENS(provider, accounts);\n  }\n  function useENSName(provider) {\n    var _a;\n    const account = useAccount();\n    const accounts = (0, react_1.useMemo)(() => account === undefined ? undefined : [account], [account]);\n    return (_a = useENS(provider, accounts)) === null || _a === void 0 ? void 0 : _a[0];\n  }\n  return {\n    useProvider,\n    useENSNames,\n    useENSName\n  };\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}