{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport React, { useState } from \"react\";\nimport { calculateTickByMacroScore, macroScoreRanges, spectralColors } from \"../../utils/ticks\";\nimport * as SC from \"./Gauge.styles\";\n// Config\nconst canvas = 140; // Main value, the rest are relative to this one\nconst strokeWidth = 10; // Gauge stroke\nconst strokeDegrees = 270; // Gauge degrees\nconst gradientWidth = 4; // Percentae of gradient per tick\nconst tickWidth = 3; // Width of ticks\n// End Config\nconst strokeSelector = strokeWidth;\nconst maxMacroScore = macroScoreRanges[macroScoreRanges.length - 1][1];\nconst adjustBase = (360 - strokeDegrees) / 360 * 100 / 2;\nconst adjustPercentage = percentage => percentage * (strokeDegrees / 360) + adjustBase;\nconst GaugeSvgGradient = React.memo((() => {\n  // const colorStepsGradient = macroScoreRanges\n  //   .map(([low, high], i) => ([\n  //     [(low / maxMacroScore * 100) + (gradientWidth / 2), macroScoreColors[i]],\n  //     [(high / maxMacroScore * 100) - (gradientWidth / 2), macroScoreColors[i]],\n  //   ]))\n  //   .flat()\n  //   .map(([position, color]) => `${color} ${adjustPercentage(+position)}%`)\n  //   .join(', ')\n  const colorStepsGradient = spectralColors.map((_, i, _ref) => {\n    let {\n      length\n    } = _ref;\n    return [i / length * 100, (i + 1) / length * 100];\n  }).map((_ref2, i) => {\n    let [low, high] = _ref2;\n    return [[low + gradientWidth / 2, spectralColors[i]], [high - gradientWidth / 2, spectralColors[i]]];\n  }).flat().map(_ref3 => {\n    let [position, color] = _ref3;\n    return `${color} ${adjustPercentage(+position)}%`;\n  }).join(\", \");\n  return props => {\n    return React.createElement(\"g\", Object.assign({}, props), React.createElement(\"foreignObject\", {\n      width: canvas,\n      height: canvas\n    }, React.createElement(SC.GradientContainer, {\n      style: {\n        width: canvas * 2,\n        height: canvas * 2,\n        background: `conic-gradient(${colorStepsGradient})`\n      }\n    })));\n  };\n})());\nconst GaugeTicksMask = React.memo((() => {\n  const ticks = macroScoreRanges.map(_ref4 => {\n    let [low] = _ref4;\n    return low / maxMacroScore * 100;\n  }).map(adjustPercentage).reverse();\n  return _a => {\n    var {\n        tick\n      } = _a,\n      props = __rest(_a, [\"tick\"]);\n    return React.createElement(\"g\", Object.assign({}, props), ticks.slice(tick ? tick - 1 : 0).map((position, i) => React.createElement(\"rect\", {\n      key: i,\n      x: (canvas - tickWidth) / 2,\n      y: canvas - strokeWidth - 1,\n      width: tickWidth,\n      height: strokeWidth + 2,\n      fill: \"black\",\n      style: {\n        transform: `rotate(${position * 360 / 100}deg)`,\n        transformOrigin: `center`\n      }\n    })));\n  };\n})());\nconst Gauge = props => {\n  const {\n    size,\n    score: rawScore,\n    grade,\n    gradeColor\n  } = props;\n  const score = rawScore || 0;\n  const tick = calculateTickByMacroScore(score);\n  const [randomId] = useState(Math.random().toFixed(8).substr(2));\n  const getId = id => `gauge-${randomId}-${id}`;\n  const center = canvas / 2;\n  const radius = (canvas - strokeWidth) / 2;\n  const transition = \"all 0.6s ease\";\n  const ellipseProps = {\n    cx: center,\n    cy: center,\n    rx: radius,\n    ry: radius\n  };\n  const ellipseCommon = {\n    strokeWidth,\n    stroke: \"white\",\n    strokeLinecap: \"round\",\n    transformOrigin: \"center\",\n    transition\n  };\n  return React.createElement(SC.Container, null, React.createElement(SC.ValueSelector, {\n    style: {\n      transition\n    },\n    canvas: canvas,\n    size: size,\n    strokeWidth: strokeWidth,\n    progress: adjustPercentage(score / maxMacroScore * 100)\n  }), React.createElement(\"svg\", {\n    height: size,\n    width: size,\n    viewBox: `0 0 ${canvas} ${canvas}`\n  }, React.createElement(\"rect\", {\n    height: canvas,\n    width: canvas,\n    fill: \"#e0e7ef\",\n    mask: `url(#${getId(\"gauge\")})`\n  }), React.createElement(GaugeSvgGradient, {\n    mask: `url(#${getId(\"progress\")})`\n  }), React.createElement(\"foreignObject\", {\n    width: canvas,\n    height: canvas\n  }, React.createElement(SC.ValueWrapper, {\n    color: gradeColor,\n    noHover: rawScore === null\n  }, React.createElement(SC.ScoreCalculated, null, rawScore === null ? \"?\" : ~~score), React.createElement(SC.Grade, null, \"Grade\", React.createElement(\"strong\", null, grade)))), React.createElement(\"defs\", null, React.createElement(\"mask\", {\n    id: getId(\"gauge\")\n  }, React.createElement(\"ellipse\", Object.assign({}, ellipseProps, {\n    style: Object.assign(Object.assign({}, ellipseCommon), {\n      strokeDasharray: radius * Math.PI * 2,\n      strokeDashoffset: radius * Math.PI * ((360 - strokeDegrees) / 360 * 2),\n      transform: `rotate(${90 + (360 - strokeDegrees) / 2}deg)`\n    })\n  })), React.createElement(GaugeTicksMask, {\n    tick: tick\n  })), React.createElement(\"mask\", {\n    id: getId(\"progress\")\n  }, React.createElement(\"ellipse\", Object.assign({}, ellipseProps, {\n    style: Object.assign(Object.assign({}, ellipseCommon), {\n      strokeDasharray: radius * Math.PI * 2,\n      strokeDashoffset: radius * Math.PI * ((360 - strokeDegrees * Math.min(score / maxMacroScore, 1)) / 360 * 2),\n      transform: `rotate(${90 + (360 - strokeDegrees) / 2}deg)`\n    })\n  })), React.createElement(GaugeTicksMask, null), React.createElement(\"ellipse\", {\n    cx: canvas / 2,\n    cy: canvas - strokeSelector / 2,\n    rx: strokeSelector / 2,\n    ry: strokeSelector / 2,\n    fill: \"white\",\n    style: {\n      transition,\n      transformOrigin: \"center\",\n      transform: `rotate(${adjustPercentage(score / maxMacroScore * 100) / 100 * 360 + 4}deg)`\n    }\n  })))));\n};\n// export default React.memo(Gauge)\nexport default Gauge;\n//# sourceMappingURL=Gauge.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}