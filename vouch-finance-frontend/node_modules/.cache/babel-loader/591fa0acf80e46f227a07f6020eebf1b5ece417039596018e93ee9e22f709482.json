{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SafeAppProvider = void 0;\nconst events_1 = require(\"events\");\nconst utils_1 = require(\"./utils\");\n// The API is based on Ethereum JavaScript API Provider Standard. Link: https://eips.ethereum.org/EIPS/eip-1193\nclass SafeAppProvider extends events_1.EventEmitter {\n  constructor(safe, sdk) {\n    super();\n    this.submittedTxs = new Map();\n    this.safe = safe;\n    this.sdk = sdk;\n  }\n  async connect() {\n    this.emit('connect', {\n      chainId: this.chainId\n    });\n    return;\n  }\n  async disconnect() {\n    return;\n  }\n  get chainId() {\n    return this.safe.chainId;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async request(request) {\n    const {\n      method,\n      params = []\n    } = request;\n    switch (method) {\n      case 'eth_accounts':\n        return [this.safe.safeAddress];\n      case 'net_version':\n      case 'eth_chainId':\n        return `0x${this.chainId.toString(16)}`;\n      case 'personal_sign':\n        {\n          const [message, address] = params;\n          if (this.safe.safeAddress.toLowerCase() !== address.toLowerCase()) {\n            throw new Error('The address or message hash is invalid');\n          }\n          await this.sdk.txs.signMessage(message);\n          return '0x';\n        }\n      case 'eth_sign':\n        {\n          const [address, messageHash] = params;\n          if (this.safe.safeAddress.toLowerCase() !== address.toLowerCase() || !messageHash.startsWith('0x')) {\n            throw new Error('The address or message hash is invalid');\n          }\n          await this.sdk.txs.signMessage(messageHash);\n          return '0x';\n        }\n      case 'eth_sendTransaction':\n        const tx = Object.assign({\n          value: '0',\n          data: '0x'\n        }, params[0]);\n        const resp = await this.sdk.txs.send({\n          txs: [tx]\n        });\n        // Store fake transaction\n        this.submittedTxs.set(resp.safeTxHash, {\n          from: this.safe.safeAddress,\n          hash: resp.safeTxHash,\n          gas: 0,\n          gasPrice: '0x00',\n          nonce: 0,\n          input: tx.data,\n          value: tx.value,\n          to: tx.to,\n          blockHash: null,\n          blockNumber: null,\n          transactionIndex: null\n        });\n        return resp.safeTxHash;\n      case 'eth_blockNumber':\n        const block = await this.sdk.eth.getBlockByNumber(['latest']);\n        return block.number;\n      case 'eth_getBalance':\n        return this.sdk.eth.getBalance([(0, utils_1.getLowerCase)(params[0]), params[1]]);\n      case 'eth_getCode':\n        return this.sdk.eth.getCode([(0, utils_1.getLowerCase)(params[0]), params[1]]);\n      case 'eth_getTransactionCount':\n        return this.sdk.eth.getTransactionCount([(0, utils_1.getLowerCase)(params[0]), params[1]]);\n      case 'eth_getStorageAt':\n        return this.sdk.eth.getStorageAt([(0, utils_1.getLowerCase)(params[0]), params[1], params[2]]);\n      case 'eth_getBlockByNumber':\n        return this.sdk.eth.getBlockByNumber([params[0], params[1]]);\n      case 'eth_getBlockByHash':\n        return this.sdk.eth.getBlockByHash([params[0], params[1]]);\n      case 'eth_getTransactionByHash':\n        let txHash = params[0];\n        try {\n          const resp = await this.sdk.txs.getBySafeTxHash(txHash);\n          txHash = resp.txHash || txHash;\n        } catch (e) {}\n        // Use fake transaction if we don't have a real tx hash\n        if (this.submittedTxs.has(txHash)) {\n          return this.submittedTxs.get(txHash);\n        }\n        return this.sdk.eth.getTransactionByHash([txHash]).then(tx => {\n          // We set the tx hash to the one requested, as some provider assert this\n          if (tx) {\n            tx.hash = params[0];\n          }\n          return tx;\n        });\n      case 'eth_getTransactionReceipt':\n        {\n          let txHash = params[0];\n          try {\n            const resp = await this.sdk.txs.getBySafeTxHash(txHash);\n            txHash = resp.txHash || txHash;\n          } catch (e) {}\n          return this.sdk.eth.getTransactionReceipt([txHash]).then(tx => {\n            // We set the tx hash to the one requested, as some provider assert this\n            if (tx) {\n              tx.transactionHash = params[0];\n            }\n            return tx;\n          });\n        }\n      case 'eth_estimateGas':\n        {\n          return this.sdk.eth.getEstimateGas(params[0]);\n        }\n      case 'eth_call':\n        {\n          return this.sdk.eth.call([params[0], params[1]]);\n        }\n      case 'eth_getLogs':\n        return this.sdk.eth.getPastLogs([params[0]]);\n      case 'eth_gasPrice':\n        return this.sdk.eth.getGasPrice();\n      default:\n        throw Error(`\"${request.method}\" not implemented`);\n    }\n  }\n  // this method is needed for ethers v4\n  // https://github.com/ethers-io/ethers.js/blob/427e16826eb15d52d25c4f01027f8db22b74b76c/src.ts/providers/web3-provider.ts#L41-L55\n  send(request, callback) {\n    if (!request) callback('Undefined request');\n    this.request(request).then(result => callback(null, {\n      jsonrpc: '2.0',\n      id: request.id,\n      result\n    })).catch(error => callback(error, null));\n  }\n}\nexports.SafeAppProvider = SafeAppProvider;\n//# sourceMappingURL=provider.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}