{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { useCallback } from \"react\";\nimport { useLocalStorage } from \"./hooks\";\nimport { isApiError } from \"./api\";\nconst error = message => {\n  throw new Error(\"[Auth error] \" + message);\n};\nexport const useAuth = (forceUpdate, coreWeb3, api, track, config) => {\n  const {\n    ready,\n    account,\n    provider\n  } = coreWeb3;\n  const [jwtTokens, setJwtTokens, freshJwtTokens] = useLocalStorage(\"jwt\", {});\n  const addToken = (address, token, signature) => setJwtTokens(Object.assign(Object.assign({}, jwtTokens), {\n    [address.toLowerCase()]: {\n      token,\n      signature\n    }\n  }));\n  const getToken = function () {\n    let address = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _a, _b;\n    return (_b = (_a = freshJwtTokens()) === null || _a === void 0 ? void 0 : _a[address.toLowerCase()]) === null || _b === void 0 ? void 0 : _b.token;\n  };\n  const getSignature = function () {\n    let address = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var _a, _b;\n    return (_b = (_a = freshJwtTokens()) === null || _a === void 0 ? void 0 : _a[address.toLowerCase()]) === null || _b === void 0 ? void 0 : _b.signature;\n  };\n  const removeToken = function () {\n    let address = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    return setJwtTokens(Object.assign(Object.assign({}, jwtTokens), {\n      [address.toLowerCase()]: undefined\n    }));\n  };\n  // Sign raw message\n  const signMessage = useCallback((library, account, primaryAddress) => __awaiter(void 0, void 0, void 0, function* () {\n    const chainId = config.chainId;\n    const nfcContractAddress = config.nfcContract;\n    if (!chainId || !nfcContractAddress) {\n      return error(\"Contract address or chainId not defined\");\n    }\n    try {\n      const signer = yield library.getSigner();\n      const signature = yield signer._signTypedData({\n        name: \"Spectral\",\n        version: \"1\",\n        chainId: config.chainId,\n        verifyingContract: config.nfcContract\n      }, {\n        Value: [{\n          name: \"content\",\n          type: \"string\"\n        }]\n      }, {\n        content: \"This is Spectral Team. We are verifying ownership of the wallet.\"\n      });\n      if (!signature) {\n        return error(\"Invalid signature\");\n      }\n      return signature;\n    } catch (e) {\n      throw e.code;\n    }\n  }), []);\n  // Check that all the information is ready to sign\n  const signAccount = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n    if (!ready) {\n      return error(\"Web3 provider not ready\");\n    }\n    if (!account) {\n      return error(\"Wallet not connected\");\n    }\n    try {\n      const signResponse = yield signMessage(provider, account, account);\n      return signResponse;\n    } catch (error) {\n      throw new Error(error);\n    }\n  }), [ready, provider, account]);\n  // Auth login\n  const login = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n    if (account) {\n      const currentToken = getToken(account);\n      if (currentToken) {\n        return;\n      }\n      try {\n        const sign = yield signAccount();\n        const {\n          token\n        } = yield api.login(account, sign, config.partner);\n        track.login();\n        addToken(account, token, sign);\n        forceUpdate();\n      } catch (e) {\n        if (isApiError(e)) {\n          console.warn(\"TODO: show a global warning\", e.response);\n        } else {\n          throw new Error(\"Error from the core\");\n        }\n      }\n    }\n  }), [account, jwtTokens]);\n  // Auth logut\n  const logout = useCallback(() => {\n    if (account) {\n      removeToken(account);\n      forceUpdate();\n    }\n  }, [account, jwtTokens]);\n  // Service\n  const accountJwt = getToken(account);\n  return {\n    account: {\n      address: account,\n      token: accountJwt,\n      logged: !!accountJwt,\n      signature: getSignature(account)\n    },\n    tokens: {\n      addToken,\n      getToken,\n      getSignature,\n      removeToken\n    },\n    login,\n    logout\n  };\n};\n//# sourceMappingURL=auth.hook.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}