{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar Semaphore = /** @class */function () {\n  function Semaphore(_maxConcurrency) {\n    this._maxConcurrency = _maxConcurrency;\n    this._queue = [];\n    if (_maxConcurrency <= 0) {\n      throw new Error('semaphore must be initialized to a positive value');\n    }\n    this._value = _maxConcurrency;\n  }\n  Semaphore.prototype.acquire = function () {\n    var _this = this;\n    var locked = this.isLocked();\n    var ticket = new Promise(function (r) {\n      return _this._queue.push(r);\n    });\n    if (!locked) this._dispatch();\n    return ticket;\n  };\n  Semaphore.prototype.runExclusive = function (callback) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var _a, value, release;\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this.acquire()];\n          case 1:\n            _a = _b.sent(), value = _a[0], release = _a[1];\n            _b.label = 2;\n          case 2:\n            _b.trys.push([2,, 4, 5]);\n            return [4 /*yield*/, callback(value)];\n          case 3:\n            return [2 /*return*/, _b.sent()];\n          case 4:\n            release();\n            return [7 /*endfinally*/];\n          case 5:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  Semaphore.prototype.isLocked = function () {\n    return this._value <= 0;\n  };\n  Semaphore.prototype.release = function () {\n    if (this._maxConcurrency > 1) {\n      throw new Error('this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead');\n    }\n    if (this._currentReleaser) {\n      var releaser = this._currentReleaser;\n      this._currentReleaser = undefined;\n      releaser();\n    }\n  };\n  Semaphore.prototype._dispatch = function () {\n    var _this = this;\n    var nextConsumer = this._queue.shift();\n    if (!nextConsumer) return;\n    var released = false;\n    this._currentReleaser = function () {\n      if (released) return;\n      released = true;\n      _this._value++;\n      _this._dispatch();\n    };\n    nextConsumer([this._value--, this._currentReleaser]);\n  };\n  return Semaphore;\n}();\nexports.default = Semaphore;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}