{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Resolution = void 0;\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\nvar Zns_1 = __importDefault(require(\"./Zns\"));\nvar Uns_1 = __importDefault(require(\"./Uns\"));\nvar UdApi_1 = __importDefault(require(\"./UdApi\"));\nvar publicTypes_1 = require(\"./types/publicTypes\");\nvar resolutionError_1 = __importStar(require(\"./errors/resolutionError\"));\nvar DnsUtils_1 = __importDefault(require(\"./utils/DnsUtils\"));\nvar utils_1 = require(\"./utils\");\nvar Eip1993Factories_1 = require(\"./utils/Eip1993Factories\");\nvar Networking_1 = __importDefault(require(\"./utils/Networking\"));\nvar prepareAndValidate_1 = require(\"./utils/prepareAndValidate\");\nvar namehash_1 = require(\"./utils/namehash\");\n/**\n * Blockchain domain Resolution library - Resolution.\n * @example\n * ```\n * import Resolution from '@unstoppabledomains/resolution';\n *\n * let resolution = new Resolution({ blockchain: {\n *        uns: {\n *           url: \"https://mainnet.infura.io/v3/c4bb906ed6904c42b19c95825fe55f39\",\n *           network: \"mainnet\"\n *        }\n *      }\n *   });\n *\n * let domain = \"brad.zil\";\n * resolution.addr(domain, \"eth\").then(addr => console.log(addr));;\n * ```\n */\nvar Resolution = /** @class */function () {\n  function Resolution(_a) {\n    var _b;\n    var _c = _a === void 0 ? {} : _a,\n      _d = _c.sourceConfig,\n      sourceConfig = _d === void 0 ? undefined : _d;\n    var uns = isApi(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.uns) ? new UdApi_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.uns) : new Uns_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.uns);\n    var zns = isApi(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.zns) ? new UdApi_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.zns) : new Zns_1.default(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.zns);\n    // If both UNS and ZNS use the same UdApi providers, we don't want to call the API twice as it would return same\n    // responses. It should be enough to compare just the URLs, as the network param isn't actually used in the calls.\n    var equalUdApiProviders = uns instanceof UdApi_1.default && zns instanceof UdApi_1.default && uns.url === zns.url;\n    // If a user configures the lib with an API source, we still want to initialise native blockchain services to access\n    // some non-async methods such as namehash, as they are unavailable in the UdApi service.\n    this.serviceMap = (_b = {}, _b[publicTypes_1.NamingServiceName.UNS] = {\n      usedServices: [uns],\n      native: isApi(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.uns) ? new Uns_1.default() : uns\n    }, _b[publicTypes_1.NamingServiceName.ZNS] = {\n      usedServices: equalUdApiProviders ? [uns] : [uns, zns],\n      native: isApi(sourceConfig === null || sourceConfig === void 0 ? void 0 : sourceConfig.zns) ? new Zns_1.default() : zns\n    }, _b);\n  }\n  /**\n   * AutoConfigure the blockchain network for UNS\n   * We make a \"net_version\" JSON RPC call to the blockchain either via url or with the help of given provider.\n   * @param sourceConfig - configuration object for uns\n   * @returns configured Resolution object\n   */\n  Resolution.autoNetwork = function (sourceConfig) {\n    return __awaiter(this, void 0, void 0, function () {\n      var resolution, uns;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            resolution = new this();\n            if (!sourceConfig.uns) return [3 /*break*/, 2];\n            return [4 /*yield*/, Uns_1.default.autoNetwork(sourceConfig.uns)];\n          case 1:\n            uns = _a.sent();\n            resolution.serviceMap[publicTypes_1.NamingServiceName.UNS] = {\n              usedServices: [uns],\n              native: uns\n            };\n            _a.label = 2;\n          case 2:\n            return [2 /*return*/, resolution];\n        }\n      });\n    });\n  };\n  /**\n   * Creates a resolution with configured infura id for uns\n   * @param infura - infura project id\n   * @param networks - an optional object that describes what network to use when connecting UNS default is mainnet\n   */\n  Resolution.infura = function (infura, networks) {\n    var _a, _b, _c, _d;\n    return new this({\n      sourceConfig: {\n        uns: {\n          locations: {\n            Layer1: {\n              url: (0, utils_1.signedLink)(infura, ((_a = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _a === void 0 ? void 0 : _a.locations.Layer1.network) || 'mainnet', 'infura'),\n              network: ((_b = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _b === void 0 ? void 0 : _b.locations.Layer1.network) || 'mainnet'\n            },\n            Layer2: {\n              url: (0, utils_1.signedLink)(infura, ((_c = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _c === void 0 ? void 0 : _c.locations.Layer2.network) || 'polygon-mainnet', 'infura'),\n              network: ((_d = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _d === void 0 ? void 0 : _d.locations.Layer2.network) || 'polygon-mainnet'\n            }\n          }\n        }\n      }\n    });\n  };\n  /**\n   * Creates a resolution with configured alchemy API keys for uns\n   * @param alchemy - alchemy API keys\n   * @param networks - an optional object that describes what network to use when connecting UNS default is mainnet\n   */\n  Resolution.alchemy = function (alchemy, networks) {\n    var _a, _b, _c, _d;\n    return new this({\n      sourceConfig: {\n        uns: {\n          locations: {\n            Layer1: {\n              url: (0, utils_1.signedLink)(alchemy, ((_a = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _a === void 0 ? void 0 : _a.locations.Layer1.network) || 'mainnet'),\n              network: ((_b = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _b === void 0 ? void 0 : _b.locations.Layer1.network) || 'mainnet'\n            },\n            Layer2: {\n              url: (0, utils_1.signedLink)(alchemy, ((_c = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _c === void 0 ? void 0 : _c.locations.Layer2.network) || 'polygon-mainnet'),\n              network: ((_d = networks === null || networks === void 0 ? void 0 : networks.uns) === null || _d === void 0 ? void 0 : _d.locations.Layer2.network) || 'polygon-mainnet'\n            }\n          }\n        }\n      }\n    });\n  };\n  /**\n   * Creates a resolution instance with configured provider\n   * @param networks - an object that describes what network to use when connecting UNS or ZNS default is mainnet\n   * @see https://eips.ethereum.org/EIPS/eip-1193\n   */\n  Resolution.fromResolutionProvider = function (networks) {\n    if (networks.uns) {\n      return this.fromEthereumEip1193Provider({\n        uns: networks.uns\n      });\n    }\n    if (networks.zns) {\n      return this.fromZilliqaProvider(networks.zns.provider, networks);\n    }\n    throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.ServiceProviderError, {\n      providerMessage: 'Must specify network for uns or zns'\n    });\n  };\n  /**\n   * Creates a resolution instance with configured provider\n   * @param networks - an object that describes what network to use when connecting UNS default is mainnet\n   * @see https://eips.ethereum.org/EIPS/eip-1193\n   */\n  Resolution.fromEthereumEip1193Provider = function (networks) {\n    var sourceConfig = {};\n    if (networks.uns) {\n      sourceConfig.uns = {\n        locations: {\n          Layer1: {\n            provider: networks.uns.locations.Layer1.provider,\n            network: networks.uns.locations.Layer1.network || 'mainnet'\n          },\n          Layer2: {\n            provider: networks.uns.locations.Layer2.provider,\n            network: networks.uns.locations.Layer2.network || 'polygon-mainnet'\n          }\n        }\n      };\n    }\n    return new this({\n      sourceConfig: sourceConfig\n    });\n  };\n  /**\n   * Creates a resolution instance with configured provider\n   * @param provider - any provider compatible with EIP-1193\n   * @param networks - an optional object that describes what network to use when connecting ZNS default is mainnet\n   * @see https://eips.ethereum.org/EIPS/eip-1193\n   */\n  Resolution.fromZilliqaProvider = function (provider, networks) {\n    var _a;\n    return new this({\n      sourceConfig: {\n        zns: {\n          provider: provider,\n          network: ((_a = networks === null || networks === void 0 ? void 0 : networks.zns) === null || _a === void 0 ? void 0 : _a.network) || 'mainnet'\n        }\n      }\n    });\n  };\n  /**\n   * Create a resolution instance from web3 0.x version provider\n   * @param networks - Ethereum network configuration with 0.x version provider from web3 ( must implement sendAsync(payload, callback) )\n   * @see https://github.com/ethereum/web3.js/blob/0.20.7/lib/web3/httpprovider.js#L116\n   */\n  Resolution.fromWeb3Version0Provider = function (networks) {\n    return this.fromEthereumEip1193Provider({\n      uns: networks.uns ? {\n        locations: {\n          Layer1: {\n            network: networks.uns.locations.Layer1.network,\n            provider: Eip1993Factories_1.Eip1993Factories.fromWeb3Version0Provider(networks.uns.locations.Layer1.provider)\n          },\n          Layer2: {\n            network: networks.uns.locations.Layer2.network,\n            provider: Eip1993Factories_1.Eip1993Factories.fromWeb3Version0Provider(networks.uns.locations.Layer2.provider)\n          }\n        }\n      } : undefined\n    });\n  };\n  /**\n   * Create a resolution instance from web3 1.x version provider\n   * @param networks - an optional object with 1.x version provider from web3 ( must implement send(payload, callback) ) that describes what network to use when connecting UNS default is mainnet\n   * @see https://github.com/ethereum/web3.js/blob/1.x/packages/web3-core-helpers/types/index.d.ts#L165\n   * @see https://github.com/ethereum/web3.js/blob/1.x/packages/web3-providers-http/src/index.js#L95\n   */\n  Resolution.fromWeb3Version1Provider = function (networks) {\n    return this.fromEthereumEip1193Provider({\n      uns: networks.uns ? {\n        locations: {\n          Layer1: {\n            network: networks.uns.locations.Layer1.network,\n            provider: Eip1993Factories_1.Eip1993Factories.fromWeb3Version1Provider(networks.uns.locations.Layer1.provider)\n          },\n          Layer2: {\n            network: networks.uns.locations.Layer2.network,\n            provider: Eip1993Factories_1.Eip1993Factories.fromWeb3Version1Provider(networks.uns.locations.Layer2.provider)\n          }\n        }\n      } : undefined\n    });\n  };\n  /**\n   * Creates instance of resolution from provider that implements Ethers Provider#call interface.\n   * This wrapper support only `eth_call` method for now, which is enough for all the current Resolution functionality\n   * @param networks - an object that describes what network to use when connecting UNS default is mainnet\n   * @see https://github.com/ethers-io/ethers.js/blob/v4-legacy/providers/abstract-provider.d.ts#L91\n   * @see https://github.com/ethers-io/ethers.js/blob/v5.0.4/packages/abstract-provider/src.ts/index.ts#L224\n   * @see https://docs.ethers.io/ethers.js/v5-beta/api-providers.html#jsonrpcprovider-inherits-from-provider\n   * @see https://github.com/ethers-io/ethers.js/blob/master/packages/providers/src.ts/json-rpc-provider.ts\n   */\n  Resolution.fromEthersProvider = function (networks) {\n    return this.fromEthereumEip1193Provider({\n      uns: networks.uns ? {\n        locations: {\n          Layer1: {\n            network: networks.uns.locations.Layer1.network,\n            provider: Eip1993Factories_1.Eip1993Factories.fromEthersProvider(networks.uns.locations.Layer1.provider)\n          },\n          Layer2: {\n            network: networks.uns.locations.Layer2.network,\n            provider: Eip1993Factories_1.Eip1993Factories.fromEthersProvider(networks.uns.locations.Layer2.provider)\n          }\n        }\n      } : undefined\n    });\n  };\n  /**\n   * Resolves given domain name to a specific currency address if exists\n   * @async\n   * @param domain - domain name to be resolved\n   * @param ticker - currency ticker like BTC, ETH, ZIL\n   * @throws [[ResolutionError]] if address is not found\n   * @returns A promise that resolves in an address\n   */\n  Resolution.prototype.addr = function (domain, ticker) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this.record(domain, \"crypto.\".concat(ticker.toUpperCase(), \".address\"))];\n      });\n    });\n  };\n  /**\n   * Read multi-chain currency address if exists\n   * @async\n   * @param domain - domain name to be resolved\n   * @param ticker - currency ticker (USDT, FTM, etc.)\n   * @param chain - chain version, usually means blockchain ( ERC20, BEP2, OMNI, etc. )\n   * @throws [[ResolutionError]] if address is not found\n   * @returns A promise that resolves in an adress\n   */\n  Resolution.prototype.multiChainAddr = function (domain, ticker, chain) {\n    return __awaiter(this, void 0, void 0, function () {\n      var recordKey;\n      return __generator(this, function (_a) {\n        domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);\n        recordKey = \"crypto.\".concat(ticker.toUpperCase(), \".version.\").concat(chain.toUpperCase(), \".address\");\n        return [2 /*return*/, this.callServiceForDomain(domain, function (service) {\n          return service.record(domain, recordKey);\n        })];\n      });\n    });\n  };\n  /**\n   * Resolves given domain name to a verified twitter handle\n   * @async\n   * @param domain - domain name to be resolved\n   * @throws [[ResolutionError]] if twitter is not found\n   * @returns A promise that resolves in a verified twitter handle\n   */\n  Resolution.prototype.twitter = function (domain) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);\n        return [2 /*return*/, this.callServiceForDomain(domain, function (service) {\n          return service.twitter(domain);\n        })];\n      });\n    });\n  };\n  /**\n   * Resolve a chat id from the domain record\n   * @param domain - domain name to be resolved\n   * @throws [[ResolutionError]]\n   * @returns A promise that resolves in chatId\n   */\n  Resolution.prototype.chatId = function (domain) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this.record(domain, 'gundb.username.value')];\n      });\n    });\n  };\n  /**\n   * Resolve a gundb public key from the domain record\n   * @param domain - domain name to be resolved\n   * @throws [[ResolutionError]]\n   * @returns a promise that resolves in gundb public key\n   */\n  Resolution.prototype.chatPk = function (domain) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this.record(domain, 'gundb.public_key.value')];\n      });\n    });\n  };\n  /**\n   * Resolves the IPFS hash configured for domain records on ZNS\n   * @param domain - domain name\n   * @throws [[ResolutionError]]\n   */\n  Resolution.prototype.ipfsHash = function (domain) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);\n        return [2 /*return*/, this.getPreferableNewRecord(domain, 'dweb.ipfs.hash', 'ipfs.html.value')];\n      });\n    });\n  };\n  /**\n   * Resolves the httpUrl attached to domain\n   * @param domain - domain name\n   */\n  Resolution.prototype.httpUrl = function (domain) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);\n        return [2 /*return*/, this.getPreferableNewRecord(domain, 'browser.redirect_url', 'ipfs.redirect_domain.value')];\n      });\n    });\n  };\n  /**\n   * Resolves the ipfs email field from whois configurations\n   * @param domain - domain name\n   * @throws [[ResolutionError]]\n   * @returns A Promise that resolves in an email address configured for this domain whois\n   */\n  Resolution.prototype.email = function (domain) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this.record(domain, 'whois.email.value')];\n      });\n    });\n  };\n  /**\n   * @returns the resolver address for a specific domain\n   * @param domain - domain to look for\n   */\n  Resolution.prototype.resolver = function (domain) {\n    return __awaiter(this, void 0, void 0, function () {\n      var resolver;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);\n            return [4 /*yield*/, this.callServiceForDomain(domain, function (service) {\n              return service.resolver(domain);\n            })];\n          case 1:\n            resolver = _a.sent();\n            if (!resolver) {\n              throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnspecifiedResolver, {\n                domain: domain\n              });\n            }\n            return [2 /*return*/, resolver];\n        }\n      });\n    });\n  };\n  /**\n   * @param domain - domain name\n   * @returns An owner address of the domain\n   */\n  Resolution.prototype.owner = function (domain) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);\n        return [2 /*return*/, this.callServiceForDomain(domain, function (service) {\n          return service.owner(domain);\n        })];\n      });\n    });\n  };\n  /**\n   * @param domain - domain name\n   * @param recordKey - a name of a record to be resolved\n   * @returns A record value promise for a given record name\n   */\n  Resolution.prototype.record = function (domain, recordKey) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);\n        return [2 /*return*/, this.callServiceForDomain(domain, function (service) {\n          return service.record(domain, recordKey);\n        })];\n      });\n    });\n  };\n  /**\n   * @param domain domain name\n   * @param keys Array of record keys to be resolved\n   * @returns A Promise with key-value mapping of domain records\n   */\n  Resolution.prototype.records = function (domain, keys) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);\n        return [2 /*return*/, this.callServiceForDomain(domain, function (service) {\n          return service.records(domain, keys);\n        })];\n      });\n    });\n  };\n  /**\n   * @param domain domain name\n   * @returns A Promise of whether or not the domain belongs to a wallet\n   */\n  Resolution.prototype.isRegistered = function (domain) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);\n        return [2 /*return*/, this.callServiceForDomainBoolean(domain, function (service) {\n          return service.isRegistered(domain);\n        }, {\n          throwIfUnsupportedDomain: true,\n          expectedValue: true\n        })];\n      });\n    });\n  };\n  /**\n   * @param domain domain name\n   * @returns A Promise of whether or not the domain is available\n   */\n  Resolution.prototype.isAvailable = function (domain) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);\n        return [2 /*return*/, this.callServiceForDomainBoolean(domain, function (service) {\n          return service.isAvailable(domain);\n        }, {\n          throwIfUnsupportedDomain: true,\n          expectedValue: false\n        })];\n      });\n    });\n  };\n  /**\n   * @returns Produces a namehash from supported naming service in hex format with 0x prefix.\n   * Corresponds to ERC721 token id in case of Ethereum based naming service like UNS.\n   * @param domain domain name to be converted\n   * @param namingService \"UNS\" or \"ZNS\" (uses keccak256 or sha256 algorithm respectively)\n   * @param options formatting options\n   * @throws [[ResolutionError]] with UnsupportedDomain error code if domain extension is unknown\n   */\n  Resolution.prototype.namehash = function (domain, namingService, options) {\n    if (options === void 0) {\n      options = publicTypes_1.NamehashOptionsDefault;\n    }\n    var service = this.serviceMap[namingService];\n    if (!service) {\n      throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedService, {\n        namingService: namingService\n      });\n    }\n    domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);\n    return this.formatNamehash(service.native.namehash(domain), options);\n  };\n  /**\n   * @returns a namehash of a subdomain with name label\n   * @param parent namehash of a parent domain\n   * @param label subdomain name\n   * @param namingService \"UNS\" or \"ZNS\" (uses keccak256 or sha256 algorithm respectively)\n   * @param options formatting options\n   */\n  Resolution.prototype.childhash = function (parent, label, namingService, options) {\n    if (options === void 0) {\n      options = publicTypes_1.NamehashOptionsDefault;\n    }\n    var service = this.serviceMap[namingService];\n    if (!service) {\n      throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedService, {\n        namingService: namingService\n      });\n    }\n    return this.formatNamehash(service.native.childhash(parent, label), options);\n  };\n  Resolution.prototype.formatNamehash = function (hash, options) {\n    hash = hash.replace('0x', '');\n    if (options.format === 'dec') {\n      return new bn_js_1.default(hash, 'hex').toString(10);\n    } else {\n      return options.prefix ? '0x' + hash : hash;\n    }\n  };\n  /**\n   * Checks weather the domain name matches the hash\n   * @param domain - domain name to check against\n   * @param hash - hash obtained from the blockchain\n   * @param namingService - \"UNS\" or \"ZNS\" (uses keccak256 or sha256 algorithm respectively)\n   */\n  Resolution.prototype.isValidHash = function (domain, hash, namingService) {\n    var service = this.serviceMap[namingService];\n    if (!service) {\n      throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedService, {\n        namingService: namingService\n      });\n    }\n    domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);\n    return service.native.namehash(domain) === hash;\n  };\n  /**\n   * Checks if the domain name is valid according to naming service rules\n   * for valid domain names.\n   * @param domain - domain name to be checked\n   */\n  Resolution.prototype.isSupportedDomain = function (domain) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);\n        return [2 /*return*/, this.callServiceForDomainBoolean(domain, function (service) {\n          return service.isSupportedDomain(domain);\n        }, {\n          throwIfUnsupportedDomain: false,\n          expectedValue: true\n        })];\n      });\n    });\n  };\n  /**\n   * Returns all record keys of the domain.\n   * This method is strongly unrecommended for production use due to lack of support for many ethereum service providers and low performance\n   * @param domain - domain name\n   * @deprecated\n   */\n  Resolution.prototype.allRecords = function (domain) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);\n        return [2 /*return*/, this.callServiceForDomain(domain, function (service) {\n          return service.allRecords(domain);\n        })];\n      });\n    });\n  };\n  Resolution.prototype.dns = function (domain, types) {\n    return __awaiter(this, void 0, void 0, function () {\n      var dnsUtils, dnsRecordKeys, blockchainData;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            dnsUtils = new DnsUtils_1.default();\n            domain = (0, prepareAndValidate_1.prepareAndValidateDomain)(domain);\n            dnsRecordKeys = this.getDnsRecordKeys(types);\n            return [4 /*yield*/, this.callServiceForDomain(domain, function (service) {\n              return service.records(domain, dnsRecordKeys);\n            })];\n          case 1:\n            blockchainData = _a.sent();\n            return [2 /*return*/, dnsUtils.toList(blockchainData)];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieves the tokenURI from the registry smart contract.\n   * @returns the ERC721Metadata#tokenURI contract method result\n   * @param domain - domain name\n   */\n  Resolution.prototype.tokenURI = function (domain) {\n    return __awaiter(this, void 0, void 0, function () {\n      var namehash;\n      return __generator(this, function (_a) {\n        namehash = this.namehash(domain, publicTypes_1.NamingServiceName.UNS);\n        return [2 /*return*/, this.callServiceForDomain(domain, function (service) {\n          return service.getTokenUri(namehash);\n        })];\n      });\n    });\n  };\n  /**\n   * Retrieves the data from the endpoint provided by tokenURI from the registry smart contract.\n   * @returns the JSON response of the token URI endpoint\n   * @param domain - domain name\n   */\n  Resolution.prototype.tokenURIMetadata = function (domain) {\n    return __awaiter(this, void 0, void 0, function () {\n      var tokenUri;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.tokenURI(domain)];\n          case 1:\n            tokenUri = _a.sent();\n            return [2 /*return*/, this.getMetadataFromTokenURI(tokenUri)];\n        }\n      });\n    });\n  };\n  /**\n   * Retrieves address of registry contract used for domain\n   * @param domain - domain name\n   * @returns Registry contract address\n   */\n  Resolution.prototype.registryAddress = function (domain) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2 /*return*/, this.callServiceForDomain(domain, function (service) {\n          return service.registryAddress(domain);\n        })];\n      });\n    });\n  };\n  /**\n   * Retrieves the domain name from tokenId by parsing registry smart contract event logs.\n   * @throws {ResolutionError} if returned domain name doesn't match the original namhash.\n   * @returns the domain name retrieved from token metadata\n   * @param hash - domain hash\n   * @param service - nameservice which is used for lookup\n   */\n  Resolution.prototype.unhash = function (hash, service) {\n    return __awaiter(this, void 0, void 0, function () {\n      var services, method;\n      return __generator(this, function (_a) {\n        hash = (0, namehash_1.fromDecStringToHex)(hash);\n        services = this.serviceMap[service].usedServices;\n        method = services[services.length - 1];\n        return [2 /*return*/, method.getDomainFromTokenId(hash)];\n      });\n    });\n  };\n  /**\n   * Retrieves address of registry contract used for domain\n   * @param domains - domain name\n   * @returns Promise<Locations> - A map of domain name and Location (a set of attributes like blockchain,\n   */\n  Resolution.prototype.locations = function (domains) {\n    return __awaiter(this, void 0, void 0, function () {\n      var zilDomains, unsPromise, znsServices, znsService, znsPromise, unsLocations, emptyZilEntries, znsLocations, _i, emptyZilEntries_1, domain;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            zilDomains = domains.filter(function (domain) {\n              return domain.endsWith('.zil');\n            });\n            unsPromise = this.serviceMap.UNS.usedServices[0].locations(domains);\n            if (!zilDomains.length) {\n              return [2 /*return*/, unsPromise];\n            }\n            znsServices = this.serviceMap.ZNS.usedServices;\n            znsService = znsServices[znsServices.length - 1];\n            znsPromise = (0, utils_1.wrapResult)(function () {\n              return znsService.locations(zilDomains);\n            });\n            return [4 /*yield*/, unsPromise];\n          case 1:\n            unsLocations = _a.sent();\n            emptyZilEntries = Object.entries(unsLocations).filter(function (_a) {\n              var domain = _a[0],\n                location = _a[1];\n              return domain.endsWith('.zil') && !location;\n            });\n            if (!emptyZilEntries.length) {\n              return [2 /*return*/, unsLocations];\n            }\n            return [4 /*yield*/, znsPromise.then(utils_1.unwrapResult)];\n          case 2:\n            znsLocations = _a.sent();\n            for (_i = 0, emptyZilEntries_1 = emptyZilEntries; _i < emptyZilEntries_1.length; _i++) {\n              domain = emptyZilEntries_1[_i][0];\n              unsLocations[domain] = znsLocations[domain];\n            }\n            return [2 /*return*/, unsLocations];\n        }\n      });\n    });\n  };\n  /**\n   * Returns the token ID that is the primary resolution of the provided address\n   * @param address - owner's address\n   * @returns Promise<tokenId> - token ID that is the primary resolution of the provided address\n   */\n  Resolution.prototype.reverseTokenId = function (address, options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var tokenId;\n      return __generator(this, function (_a) {\n        tokenId = this.reverseGetTokenId(address, options === null || options === void 0 ? void 0 : options.location);\n        return [2 /*return*/, tokenId];\n      });\n    });\n  };\n  /**\n   * Returns the domain that is the primary resolution of the provided address\n   * @param address - owner's address\n   * @returns Promise<URL> - domain URL that is the primary resolution of the provided addresss\n   */\n  Resolution.prototype.reverse = function (address, options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var tokenId;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.reverseGetTokenId(address, options === null || options === void 0 ? void 0 : options.location)];\n          case 1:\n            tokenId = _a.sent();\n            if (tokenId) {\n              return [2 /*return*/, this.unhash(tokenId, publicTypes_1.NamingServiceName.UNS)];\n            }\n            return [2 /*return*/, null];\n        }\n      });\n    });\n  };\n  Resolution.prototype.getMetadataFromTokenURI = function (tokenUri) {\n    return __awaiter(this, void 0, void 0, function () {\n      var resp, _a, _b;\n      var _c;\n      return __generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            return [4 /*yield*/, Networking_1.default.fetch(tokenUri, {})];\n          case 1:\n            resp = _d.sent();\n            if (resp.ok) {\n              return [2 /*return*/, resp.json()];\n            }\n            _a = resolutionError_1.default.bind;\n            _b = [void 0, resolutionError_1.ResolutionErrorCode.ServiceProviderError];\n            _c = {};\n            return [4 /*yield*/, resp.text()];\n          case 2:\n            throw new (_a.apply(resolutionError_1.default, _b.concat([(_c.providerMessage = _d.sent(), _c.method = 'UDAPI', _c.methodName = 'tokenURIMetadata', _c)])))();\n        }\n      });\n    });\n  };\n  Resolution.prototype.getDnsRecordKeys = function (types) {\n    var records = ['dns.ttl'];\n    types.forEach(function (type) {\n      records.push(\"dns.\".concat(type));\n      records.push(\"dns.\".concat(type, \".ttl\"));\n    });\n    return records;\n  };\n  Resolution.prototype.getPreferableNewRecord = function (domain, newRecord, oldRecord) {\n    return __awaiter(this, void 0, void 0, function () {\n      var records;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.records(domain, [newRecord, oldRecord])];\n          case 1:\n            records = _a.sent();\n            if (!records[newRecord] && !records[oldRecord]) {\n              throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.RecordNotFound, {\n                recordName: newRecord,\n                domain: domain\n              });\n            }\n            return [2 /*return*/, records[newRecord] || records[oldRecord]];\n        }\n      });\n    });\n  };\n  Resolution.prototype.callServiceForDomain = function (domain, func) {\n    return __awaiter(this, void 0, void 0, function () {\n      var serviceName, servicePromises, _i, servicePromises_1, servicePromise, serviceCallResult;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            serviceName = (0, utils_1.findNamingServiceName)(domain);\n            if (!serviceName) {\n              throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedDomain, {\n                domain: domain\n              });\n            }\n            servicePromises = this.serviceMap[serviceName].usedServices.map(function (service) {\n              return (0, utils_1.wrapResult)(function () {\n                return func(service);\n              });\n            });\n            _i = 0, servicePromises_1 = servicePromises;\n            _a.label = 1;\n          case 1:\n            if (!(_i < servicePromises_1.length)) return [3 /*break*/, 4];\n            servicePromise = servicePromises_1[_i];\n            return [4 /*yield*/, servicePromise];\n          case 2:\n            serviceCallResult = _a.sent();\n            if (serviceCallResult.error !== null) {\n              if (!(serviceCallResult.error instanceof resolutionError_1.default && serviceCallResult.error.code === resolutionError_1.ResolutionErrorCode.UnregisteredDomain)) {\n                throw serviceCallResult.error;\n              }\n            } else {\n              return [2 /*return*/, serviceCallResult.result];\n            }\n            _a.label = 3;\n          case 3:\n            _i++;\n            return [3 /*break*/, 1];\n          case 4:\n            throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnregisteredDomain, {\n              domain: domain\n            });\n        }\n      });\n    });\n  };\n  // Expects that a called method never throws the `ResolutionErrorCode.UnregisteredDomain` (it doesn't handle it).\n  Resolution.prototype.callServiceForDomainBoolean = function (domain, func, options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var serviceName, servicePromises, _i, servicePromises_2, servicePromise, _a, result, error;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            serviceName = (0, utils_1.findNamingServiceName)(domain);\n            if (!serviceName) {\n              if (!options.throwIfUnsupportedDomain) {\n                return [2 /*return*/, !options.expectedValue];\n              }\n              throw new resolutionError_1.default(resolutionError_1.ResolutionErrorCode.UnsupportedDomain, {\n                domain: domain\n              });\n            }\n            servicePromises = this.serviceMap[serviceName].usedServices.map(function (service) {\n              return (0, utils_1.wrapResult)(function () {\n                return func(service);\n              });\n            });\n            _i = 0, servicePromises_2 = servicePromises;\n            _b.label = 1;\n          case 1:\n            if (!(_i < servicePromises_2.length)) return [3 /*break*/, 4];\n            servicePromise = servicePromises_2[_i];\n            return [4 /*yield*/, servicePromise];\n          case 2:\n            _a = _b.sent(), result = _a.result, error = _a.error;\n            if (error) {\n              if (!(error instanceof resolutionError_1.default && error.code === resolutionError_1.ResolutionErrorCode.UnregisteredDomain)) {\n                throw error;\n              }\n            } else if (result === options.expectedValue) {\n              // If the result is not the one which is expected, we don't want to return it immediately.\n              return [2 /*return*/, result];\n            }\n            _b.label = 3;\n          case 3:\n            _i++;\n            return [3 /*break*/, 1];\n          case 4:\n            return [2 /*return*/, !options.expectedValue];\n        }\n      });\n    });\n  };\n  Resolution.prototype.reverseGetTokenId = function (address, location) {\n    return __awaiter(this, void 0, void 0, function () {\n      var service, tokenId;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            service = this.serviceMap['UNS'].native;\n            return [4 /*yield*/, service.reverseOf(address, location)];\n          case 1:\n            tokenId = _a.sent();\n            return [2 /*return*/, tokenId];\n        }\n      });\n    });\n  };\n  return Resolution;\n}();\nexports.Resolution = Resolution;\nexports.default = Resolution;\nfunction isApi(obj) {\n  return obj && obj.api;\n}","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}