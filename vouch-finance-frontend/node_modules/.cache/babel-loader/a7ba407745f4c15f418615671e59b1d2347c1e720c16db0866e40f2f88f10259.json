{"ast":null,"code":"import { ChaCha20Poly1305 as W } from \"@stablelib/chacha20poly1305\";\nimport { HKDF as Ge } from \"@stablelib/hkdf\";\nimport { randomBytes as J } from \"@stablelib/random\";\nimport { SHA256 as ze, hash as Q } from \"@stablelib/sha256\";\nimport * as Z from \"@stablelib/x25519\";\nimport { toString as d, fromString as l, concat as X } from \"uint8arrays\";\nimport { detect as Ye } from \"detect-browser\";\nimport { toMiliseconds as $, FIVE_MINUTES as ee, fromMiliseconds as We } from \"@walletconnect/time\";\nimport { getDocument as Je, getNavigator as ne, getLocation as te } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata as Qe } from \"@walletconnect/window-metadata\";\nimport * as P from \"query-string\";\nimport { RELAY_JSONRPC as Ze } from \"@walletconnect/relay-api\";\nconst U = \":\";\nfunction re(e) {\n  const [n, t] = e.split(U);\n  return {\n    namespace: n,\n    reference: t\n  };\n}\nfunction oe(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = e;\n  return [n, t].join(U);\n}\nfunction j(e) {\n  const [n, t, r] = e.split(U);\n  return {\n    namespace: n,\n    reference: t,\n    address: r\n  };\n}\nfunction se(e) {\n  const {\n    namespace: n,\n    reference: t,\n    address: r\n  } = e;\n  return [n, t, r].join(U);\n}\nfunction V(e, n) {\n  const t = [];\n  return e.forEach(r => {\n    const o = n(r);\n    t.includes(o) || t.push(o);\n  }), t;\n}\nfunction ie(e) {\n  const {\n    address: n\n  } = j(e);\n  return n;\n}\nfunction ce(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = j(e);\n  return oe({\n    namespace: n,\n    reference: t\n  });\n}\nfunction Xe(e, n) {\n  const {\n    namespace: t,\n    reference: r\n  } = re(n);\n  return se({\n    namespace: t,\n    reference: r,\n    address: e\n  });\n}\nfunction en(e) {\n  return V(e, ie);\n}\nfunction ae(e) {\n  return V(e, ce);\n}\nfunction nn(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...o.accounts);\n  }), t;\n}\nfunction tn(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...ae(o.accounts));\n  }), t;\n}\nfunction rn(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...S(r, o));\n  }), t;\n}\nfunction S(e, n) {\n  return e.includes(\":\") ? [e] : n.chains || [];\n}\nconst R = e => e?.split(\":\"),\n  ue = e => {\n    const n = e && R(e);\n    if (n) return n[3];\n  },\n  on = e => {\n    const n = e && R(e);\n    if (n) return n[2] + \":\" + n[3];\n  },\n  de = e => {\n    const n = e && R(e);\n    if (n) return n.pop();\n  },\n  sn = (e, n) => {\n    const t = `${e.domain} wants you to sign in with your Ethereum account:`,\n      r = de(n),\n      o = e.statement,\n      s = `URI: ${e.aud}`,\n      i = `Version: ${e.version}`,\n      c = `Chain ID: ${ue(n)}`,\n      f = `Nonce: ${e.nonce}`,\n      g = `Issued At: ${e.iat}`,\n      O = e.resources && e.resources.length > 0 ? `Resources:\n${e.resources.map(p => `- ${p}`).join(`\n`)}` : void 0;\n    return [t, r, \"\", o, \"\", s, i, c, f, g, O].filter(p => p != null).join(`\n`);\n  },\n  M = \"base10\",\n  a = \"base16\",\n  _ = \"base64pad\",\n  A = \"utf8\",\n  K = 0,\n  N = 1,\n  cn = 0,\n  le = 1,\n  k = 12,\n  L = 32;\nfunction an() {\n  const e = Z.generateKeyPair();\n  return {\n    privateKey: d(e.secretKey, a),\n    publicKey: d(e.publicKey, a)\n  };\n}\nfunction un() {\n  const e = J(L);\n  return d(e, a);\n}\nfunction dn(e, n) {\n  const t = Z.sharedKey(l(e, a), l(n, a)),\n    r = new Ge(ze, t).expand(L);\n  return d(r, a);\n}\nfunction ln(e) {\n  const n = Q(l(e, a));\n  return d(n, a);\n}\nfunction fn(e) {\n  const n = Q(l(e, A));\n  return d(n, a);\n}\nfunction fe(e) {\n  return l(`${e}`, M);\n}\nfunction I(e) {\n  return Number(d(e, M));\n}\nfunction pn(e) {\n  const n = fe(typeof e.type < \"u\" ? e.type : K);\n  if (I(n) === N && typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n  const t = typeof e.senderPublicKey < \"u\" ? l(e.senderPublicKey, a) : void 0,\n    r = typeof e.iv < \"u\" ? l(e.iv, a) : J(k),\n    o = new W(l(e.symKey, a)).seal(r, l(e.message, A));\n  return pe({\n    type: n,\n    sealed: o,\n    iv: r,\n    senderPublicKey: t\n  });\n}\nfunction mn(e) {\n  const n = new W(l(e.symKey, a)),\n    {\n      sealed: t,\n      iv: r\n    } = x(e.encoded),\n    o = n.open(r, t);\n  if (o === null) throw new Error(\"Failed to decrypt\");\n  return d(o, A);\n}\nfunction pe(e) {\n  if (I(e.type) === N) {\n    if (typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n    return d(X([e.type, e.senderPublicKey, e.iv, e.sealed]), _);\n  }\n  return d(X([e.type, e.iv, e.sealed]), _);\n}\nfunction x(e) {\n  const n = l(e, _),\n    t = n.slice(cn, le),\n    r = le;\n  if (I(t) === N) {\n    const c = r + L,\n      f = c + k,\n      g = n.slice(r, c),\n      O = n.slice(c, f),\n      p = n.slice(f);\n    return {\n      type: t,\n      sealed: p,\n      iv: O,\n      senderPublicKey: g\n    };\n  }\n  const o = r + k,\n    s = n.slice(r, o),\n    i = n.slice(o);\n  return {\n    type: t,\n    sealed: i,\n    iv: s\n  };\n}\nfunction yn(e, n) {\n  const t = x(e);\n  return me({\n    type: I(t.type),\n    senderPublicKey: typeof t.senderPublicKey < \"u\" ? d(t.senderPublicKey, a) : void 0,\n    receiverPublicKey: n?.receiverPublicKey\n  });\n}\nfunction me(e) {\n  const n = e?.type || K;\n  if (n === N) {\n    if (typeof e?.senderPublicKey > \"u\") throw new Error(\"missing sender public key\");\n    if (typeof e?.receiverPublicKey > \"u\") throw new Error(\"missing receiver public key\");\n  }\n  return {\n    type: n,\n    senderPublicKey: e?.senderPublicKey,\n    receiverPublicKey: e?.receiverPublicKey\n  };\n}\nfunction En(e) {\n  return e.type === N && typeof e.senderPublicKey == \"string\" && typeof e.receiverPublicKey == \"string\";\n}\nvar gn = Object.defineProperty,\n  ye = Object.getOwnPropertySymbols,\n  hn = Object.prototype.hasOwnProperty,\n  Nn = Object.prototype.propertyIsEnumerable,\n  Ee = (e, n, t) => n in e ? gn(e, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : e[n] = t,\n  ge = (e, n) => {\n    for (var t in n || (n = {})) hn.call(n, t) && Ee(e, t, n[t]);\n    if (ye) for (var t of ye(n)) Nn.call(n, t) && Ee(e, t, n[t]);\n    return e;\n  };\nconst he = \"ReactNative\",\n  v = {\n    reactNative: \"react-native\",\n    node: \"node\",\n    browser: \"browser\",\n    unknown: \"unknown\"\n  },\n  w = \" \",\n  vn = \":\",\n  Ne = \"/\",\n  F = 2,\n  bn = 1e3,\n  ve = \"js\";\nfunction H() {\n  return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n}\nfunction be() {\n  return !Je() && !!ne() && navigator.product === he;\n}\nfunction Oe() {\n  return !H() && !!ne();\n}\nfunction q() {\n  return be() ? v.reactNative : H() ? v.node : Oe() ? v.browser : v.unknown;\n}\nfunction Se(e, n) {\n  let t = P.parse(e);\n  return t = ge(ge({}, t), n), e = P.stringify(t), e;\n}\nfunction On() {\n  return Qe() || {\n    name: \"\",\n    description: \"\",\n    url: \"\",\n    icons: [\"\"]\n  };\n}\nfunction Sn(e, n) {\n  var t;\n  const r = q(),\n    o = {\n      protocol: e,\n      version: n,\n      env: r\n    };\n  return r === \"browser\" && (o.host = ((t = te()) == null ? void 0 : t.host) || \"unknown\"), o;\n}\nfunction Ie() {\n  const e = Ye();\n  if (e === null) return \"unknown\";\n  const n = e.os ? e.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  return e.type === \"browser\" ? [n, e.name, e.version].join(\"-\") : [n, e.version].join(\"-\");\n}\nfunction Te() {\n  var e;\n  const n = q();\n  return n === v.browser ? [n, ((e = te()) == null ? void 0 : e.host) || \"unknown\"].join(\":\") : n;\n}\nfunction Pe(e, n, t) {\n  const r = Ie(),\n    o = Te();\n  return [[e, n].join(\"-\"), [ve, t].join(\"-\"), r, o].join(\"/\");\n}\nfunction In(_ref) {\n  let {\n    protocol: e,\n    version: n,\n    relayUrl: t,\n    sdkVersion: r,\n    auth: o,\n    projectId: s\n  } = _ref;\n  const i = t.split(\"?\"),\n    c = Pe(e, n, r),\n    f = {\n      auth: o,\n      ua: c,\n      projectId: s\n    },\n    g = Se(i[1] || \"\", f);\n  return i[0] + \"?\" + g;\n}\nfunction Tn(e) {\n  let n = (e.match(/^[^:]+(?=:\\/\\/)/gi) || [])[0];\n  const t = typeof n < \"u\" ? e.split(\"://\")[1] : e;\n  return n = n === \"wss\" ? \"https\" : \"http\", [n, t].join(\"://\");\n}\nfunction Pn(e, n, t) {\n  if (!e[n] || typeof e[n] !== t) throw new Error(`Missing or invalid \"${n}\" param`);\n}\nfunction Ue(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : F;\n  return Re(e.split(Ne), n);\n}\nfunction Un(e) {\n  return Ue(e).join(w);\n}\nfunction m(e, n) {\n  return e.filter(t => n.includes(t)).length === e.length;\n}\nfunction Re(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : F;\n  return e.slice(Math.max(e.length - n, 0));\n}\nfunction Rn(e) {\n  return Object.fromEntries(e.entries());\n}\nfunction _n(e) {\n  return new Map(Object.entries(e));\n}\nfunction An(e, n) {\n  const t = {};\n  return Object.keys(e).forEach(r => {\n    t[r] = n(e[r]);\n  }), t;\n}\nconst wn = e => e;\nfunction _e(e) {\n  return e.trim().replace(/^\\w/, n => n.toUpperCase());\n}\nfunction Cn(e) {\n  return e.split(w).map(n => _e(n)).join(w);\n}\nfunction Dn() {\n  let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ee;\n  let n = arguments.length > 1 ? arguments[1] : undefined;\n  const t = $(e || ee);\n  let r, o, s;\n  return {\n    resolve: i => {\n      s && r && (clearTimeout(s), r(i));\n    },\n    reject: i => {\n      s && o && (clearTimeout(s), o(i));\n    },\n    done: () => new Promise((i, c) => {\n      s = setTimeout(() => {\n        c(new Error(n));\n      }, t), r = i, o = c;\n    })\n  };\n}\nfunction $n(e, n) {\n  return new Promise(async (t, r) => {\n    const o = setTimeout(() => r(), n),\n      s = await e;\n    clearTimeout(o), t(s);\n  });\n}\nfunction B(e, n) {\n  if (typeof n == \"string\" && n.startsWith(`${e}:`)) return n;\n  if (e.toLowerCase() === \"topic\") {\n    if (typeof n != \"string\") throw new Error('Value must be \"string\" for expirer target type: topic');\n    return `topic:${n}`;\n  } else if (e.toLowerCase() === \"id\") {\n    if (typeof n != \"number\") throw new Error('Value must be \"number\" for expirer target type: id');\n    return `id:${n}`;\n  }\n  throw new Error(`Unknown expirer target type: ${e}`);\n}\nfunction jn(e) {\n  return B(\"topic\", e);\n}\nfunction Vn(e) {\n  return B(\"id\", e);\n}\nfunction Mn(e) {\n  const [n, t] = e.split(\":\"),\n    r = {\n      id: void 0,\n      topic: void 0\n    };\n  if (n === \"topic\" && typeof t == \"string\") r.topic = t;else if (n === \"id\" && Number.isInteger(Number(t))) r.id = Number(t);else throw new Error(`Invalid target, expected id:number or topic:string, got ${n}:${t}`);\n  return r;\n}\nfunction Kn(e, n) {\n  return We((n || Date.now()) + $(e));\n}\nfunction kn(e) {\n  return Date.now() >= $(e);\n}\nfunction Ln(e, n) {\n  return `${e}${n ? `:${n}` : \"\"}`;\n}\nconst Ae = \"irn\";\nfunction xn(e) {\n  return e?.relay || {\n    protocol: Ae\n  };\n}\nfunction Fn(e) {\n  const n = Ze[e];\n  if (typeof n > \"u\") throw new Error(`Relay Protocol not supported: ${e}`);\n  return n;\n}\nvar Hn = Object.defineProperty,\n  we = Object.getOwnPropertySymbols,\n  qn = Object.prototype.hasOwnProperty,\n  Bn = Object.prototype.propertyIsEnumerable,\n  Ce = (e, n, t) => n in e ? Hn(e, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : e[n] = t,\n  Gn = (e, n) => {\n    for (var t in n || (n = {})) qn.call(n, t) && Ce(e, t, n[t]);\n    if (we) for (var t of we(n)) Bn.call(n, t) && Ce(e, t, n[t]);\n    return e;\n  };\nfunction De(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"-\";\n  const t = {},\n    r = \"relay\" + n;\n  return Object.keys(e).forEach(o => {\n    if (o.startsWith(r)) {\n      const s = o.replace(r, \"\"),\n        i = e[o];\n      t[s] = i;\n    }\n  }), t;\n}\nfunction zn(e) {\n  const n = e.indexOf(\":\"),\n    t = e.indexOf(\"?\") !== -1 ? e.indexOf(\"?\") : void 0,\n    r = e.substring(0, n),\n    o = e.substring(n + 1, t).split(\"@\"),\n    s = typeof t < \"u\" ? e.substring(t) : \"\",\n    i = P.parse(s);\n  return {\n    protocol: r,\n    topic: o[0],\n    version: parseInt(o[1], 10),\n    symKey: i.symKey,\n    relay: De(i)\n  };\n}\nfunction $e(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"-\";\n  const t = \"relay\",\n    r = {};\n  return Object.keys(e).forEach(o => {\n    const s = t + n + o;\n    e[o] && (r[s] = e[o]);\n  }), r;\n}\nfunction Yn(e) {\n  return `${e.protocol}:${e.topic}@${e.version}?` + P.stringify(Gn({\n    symKey: e.symKey\n  }, $e(e.relay)));\n}\nfunction b(e) {\n  const n = [];\n  return e.forEach(t => {\n    const [r, o] = t.split(\":\");\n    n.push(`${r}:${o}`);\n  }), n;\n}\nfunction je(e) {\n  const n = [];\n  return Object.values(e).forEach(t => {\n    n.push(...b(t.accounts));\n  }), n;\n}\nfunction Ve(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    b(r.accounts).includes(n) && t.push(...r.methods);\n  }), t;\n}\nfunction Me(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    b(r.accounts).includes(n) && t.push(...r.events);\n  }), t;\n}\nfunction Wn(e, n) {\n  const t = qe(e, n);\n  if (t) throw new Error(t.message);\n  const r = {};\n  for (const [o, s] of Object.entries(e)) r[o] = {\n    methods: s.methods,\n    events: s.events,\n    chains: s.accounts.map(i => `${i.split(\":\")[0]}:${i.split(\":\")[1]}`)\n  };\n  return r;\n}\nconst Jn = {\n    INVALID_METHOD: {\n      message: \"Invalid method.\",\n      code: 1001\n    },\n    INVALID_EVENT: {\n      message: \"Invalid event.\",\n      code: 1002\n    },\n    INVALID_UPDATE_REQUEST: {\n      message: \"Invalid update request.\",\n      code: 1003\n    },\n    INVALID_EXTEND_REQUEST: {\n      message: \"Invalid extend request.\",\n      code: 1004\n    },\n    INVALID_SESSION_SETTLE_REQUEST: {\n      message: \"Invalid session settle request.\",\n      code: 1005\n    },\n    UNAUTHORIZED_METHOD: {\n      message: \"Unauthorized method.\",\n      code: 3001\n    },\n    UNAUTHORIZED_EVENT: {\n      message: \"Unauthorized event.\",\n      code: 3002\n    },\n    UNAUTHORIZED_UPDATE_REQUEST: {\n      message: \"Unauthorized update request.\",\n      code: 3003\n    },\n    UNAUTHORIZED_EXTEND_REQUEST: {\n      message: \"Unauthorized extend request.\",\n      code: 3004\n    },\n    USER_REJECTED: {\n      message: \"User rejected.\",\n      code: 5e3\n    },\n    USER_REJECTED_CHAINS: {\n      message: \"User rejected chains.\",\n      code: 5001\n    },\n    USER_REJECTED_METHODS: {\n      message: \"User rejected methods.\",\n      code: 5002\n    },\n    USER_REJECTED_EVENTS: {\n      message: \"User rejected events.\",\n      code: 5003\n    },\n    UNSUPPORTED_CHAINS: {\n      message: \"Unsupported chains.\",\n      code: 5100\n    },\n    UNSUPPORTED_METHODS: {\n      message: \"Unsupported methods.\",\n      code: 5101\n    },\n    UNSUPPORTED_EVENTS: {\n      message: \"Unsupported events.\",\n      code: 5102\n    },\n    UNSUPPORTED_ACCOUNTS: {\n      message: \"Unsupported accounts.\",\n      code: 5103\n    },\n    UNSUPPORTED_NAMESPACE_KEY: {\n      message: \"Unsupported namespace key.\",\n      code: 5104\n    },\n    USER_DISCONNECTED: {\n      message: \"User disconnected.\",\n      code: 6e3\n    },\n    SESSION_SETTLEMENT_FAILED: {\n      message: \"Session settlement failed.\",\n      code: 7e3\n    },\n    WC_METHOD_UNSUPPORTED: {\n      message: \"Unsupported wc_ method.\",\n      code: 10001\n    }\n  },\n  Qn = {\n    NOT_INITIALIZED: {\n      message: \"Not initialized.\",\n      code: 1\n    },\n    NO_MATCHING_KEY: {\n      message: \"No matching key.\",\n      code: 2\n    },\n    RESTORE_WILL_OVERRIDE: {\n      message: \"Restore will override.\",\n      code: 3\n    },\n    RESUBSCRIBED: {\n      message: \"Resubscribed.\",\n      code: 4\n    },\n    MISSING_OR_INVALID: {\n      message: \"Missing or invalid.\",\n      code: 5\n    },\n    EXPIRED: {\n      message: \"Expired.\",\n      code: 6\n    },\n    UNKNOWN_TYPE: {\n      message: \"Unknown type.\",\n      code: 7\n    },\n    MISMATCHED_TOPIC: {\n      message: \"Mismatched topic.\",\n      code: 8\n    },\n    NON_CONFORMING_NAMESPACES: {\n      message: \"Non conforming namespaces.\",\n      code: 9\n    }\n  };\nfunction y(e, n) {\n  const {\n    message: t,\n    code: r\n  } = Qn[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\nfunction h(e, n) {\n  const {\n    message: t,\n    code: r\n  } = Jn[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\nfunction T(e, n) {\n  return Array.isArray(e) ? typeof n < \"u\" && e.length ? e.every(n) : !0 : !1;\n}\nfunction G(e) {\n  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;\n}\nfunction E(e) {\n  return typeof e > \"u\";\n}\nfunction u(e, n) {\n  return n && E(e) ? !0 : typeof e == \"string\" && Boolean(e.trim().length);\n}\nfunction C(e, n) {\n  return n && E(e) ? !0 : typeof e == \"number\" && !isNaN(e);\n}\nfunction Zn(e, n) {\n  const {\n      requiredNamespaces: t\n    } = n,\n    r = Object.keys(e.namespaces),\n    o = Object.keys(t);\n  let s = !0;\n  return m(o, r) ? (r.forEach(i => {\n    const {\n        accounts: c,\n        methods: f,\n        events: g\n      } = e.namespaces[i],\n      O = b(c),\n      p = t[i];\n    (!m(S(i, p), O) || !m(p.methods, f) || !m(p.events, g)) && (s = !1);\n  }), s) : !1;\n}\nfunction D(e) {\n  return u(e, !1) && e.includes(\":\") ? e.split(\":\").length === 2 : !1;\n}\nfunction Ke(e) {\n  if (u(e, !1) && e.includes(\":\")) {\n    const n = e.split(\":\");\n    if (n.length === 3) {\n      const t = n[0] + \":\" + n[1];\n      return !!n[2] && D(t);\n    }\n  }\n  return !1;\n}\nfunction Xn(e) {\n  if (u(e, !1)) try {\n    return typeof new URL(e) < \"u\";\n  } catch {\n    return !1;\n  }\n  return !1;\n}\nfunction et(e) {\n  var n;\n  return (n = e?.proposer) == null ? void 0 : n.publicKey;\n}\nfunction nt(e) {\n  return e?.topic;\n}\nfunction tt(e, n) {\n  let t = null;\n  return u(e?.publicKey, !1) || (t = y(\"MISSING_OR_INVALID\", `${n} controller public key should be a string`)), t;\n}\nfunction z(e) {\n  let n = !0;\n  return T(e) ? e.length && (n = e.every(t => u(t, !1))) : n = !1, n;\n}\nfunction ke(e, n, t) {\n  let r = null;\n  return T(n) ? n.forEach(o => {\n    r || (!D(o) || !o.includes(e)) && (r = h(\"UNSUPPORTED_CHAINS\", `${t}, chain ${o} should be a string and conform to \"namespace:chainId\" format`));\n  }) : r = h(\"UNSUPPORTED_CHAINS\", `${t}, chains ${n} should be an array of strings conforming to \"namespace:chainId\" format`), r;\n}\nfunction Le(e, n) {\n  let t = null;\n  return Object.entries(e).forEach(_ref2 => {\n    let [r, o] = _ref2;\n    if (t) return;\n    const s = ke(r, S(r, o), `${n} requiredNamespace`);\n    s && (t = s);\n  }), t;\n}\nfunction xe(e, n) {\n  let t = null;\n  return T(e) ? e.forEach(r => {\n    t || Ke(r) || (t = h(\"UNSUPPORTED_ACCOUNTS\", `${n}, account ${r} should be a string and conform to \"namespace:chainId:address\" format`));\n  }) : t = h(\"UNSUPPORTED_ACCOUNTS\", `${n}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`), t;\n}\nfunction Fe(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = xe(r?.accounts, `${n} namespace`);\n    o && (t = o);\n  }), t;\n}\nfunction He(e, n) {\n  let t = null;\n  return z(e?.methods) ? z(e?.events) || (t = h(\"UNSUPPORTED_EVENTS\", `${n}, events should be an array of strings or empty array for no events`)) : t = h(\"UNSUPPORTED_METHODS\", `${n}, methods should be an array of strings or empty array for no methods`), t;\n}\nfunction Y(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = He(r, `${n}, namespace`);\n    o && (t = o);\n  }), t;\n}\nfunction rt(e, n, t) {\n  let r = null;\n  if (e && G(e)) {\n    const o = Y(e, n);\n    o && (r = o);\n    const s = Le(e, n);\n    s && (r = s);\n  } else r = y(\"MISSING_OR_INVALID\", `${n}, ${t} should be an object with data`);\n  return r;\n}\nfunction qe(e, n) {\n  let t = null;\n  if (e && G(e)) {\n    const r = Y(e, n);\n    r && (t = r);\n    const o = Fe(e, n);\n    o && (t = o);\n  } else t = y(\"MISSING_OR_INVALID\", `${n}, namespaces should be an object with data`);\n  return t;\n}\nfunction Be(e) {\n  return u(e.protocol, !0);\n}\nfunction ot(e, n) {\n  let t = !1;\n  return n && !e ? t = !0 : e && T(e) && e.length && e.forEach(r => {\n    t = Be(r);\n  }), t;\n}\nfunction st(e) {\n  return typeof e == \"number\";\n}\nfunction it(e) {\n  return typeof e < \"u\" && typeof e !== null;\n}\nfunction ct(e) {\n  return !(!e || typeof e != \"object\" || !e.code || !C(e.code, !1) || !e.message || !u(e.message, !1));\n}\nfunction at(e) {\n  return !(E(e) || !u(e.method, !1));\n}\nfunction ut(e) {\n  return !(E(e) || E(e.result) && E(e.error) || !C(e.id, !1) || !u(e.jsonrpc, !1));\n}\nfunction dt(e) {\n  return !(E(e) || !u(e.name, !1));\n}\nfunction lt(e, n) {\n  return !(!D(n) || !je(e).includes(n));\n}\nfunction ft(e, n, t) {\n  return u(t, !1) ? Ve(e, n).includes(t) : !1;\n}\nfunction pt(e, n, t) {\n  return u(t, !1) ? Me(e, n).includes(t) : !1;\n}\nfunction mt(e, n, t, r) {\n  let o = null;\n  const s = Object.keys(e),\n    i = Object.keys(n);\n  return m(s, i) ? s.forEach(c => {\n    if (o) return;\n    const f = b(n[c].accounts);\n    m(S(c, e[c]), f) ? m(e[c].methods, n[c].methods) ? m(e[c].events, n[c].events) || (o = y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces events don't satisfy namespace events for ${c}`)) : o = y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces methods don't satisfy namespace methods for ${c}`) : o = y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces accounts don't satisfy namespace chains for ${c}`);\n  }) : o = y(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces keys don't satisfy ${r}`), o;\n}\nfunction yt(e, n) {\n  return C(e, !1) && e <= n.max && e >= n.min;\n}\nexport { M as BASE10, a as BASE16, _ as BASE64, vn as COLON, F as DEFAULT_DEPTH, w as EMPTY_SPACE, v as ENV_MAP, bn as ONE_THOUSAND, he as REACT_NATIVE_PRODUCT, Ae as RELAYER_DEFAULT_PROTOCOL, ve as SDK_TYPE, Ne as SLASH, K as TYPE_0, N as TYPE_1, A as UTF8, Se as appendToQueryString, Pn as assertType, Kn as calcExpiry, Cn as capitalize, _e as capitalizeWord, Dn as createDelayedPromise, $n as createExpiringPromise, I as decodeTypeByte, mn as decrypt, dn as deriveSymKey, x as deserialize, fe as encodeTypeByte, pn as encrypt, Ln as engineEvent, wn as enumify, se as formatAccountId, Xe as formatAccountWithChain, oe as formatChainId, B as formatExpirerTarget, Vn as formatIdTarget, sn as formatMessage, Un as formatMessageContext, $e as formatRelayParams, In as formatRelayRpcUrl, jn as formatTopicTarget, Pe as formatUA, Yn as formatUri, an as generateKeyPair, un as generateRandomBytes32, b as getAccountsChains, nn as getAccountsFromNamespaces, ie as getAddressFromAccount, en as getAddressesFromAccounts, On as getAppMetadata, ce as getChainFromAccount, ae as getChainsFromAccounts, S as getChainsFromNamespace, tn as getChainsFromNamespaces, rn as getChainsFromRequiredNamespaces, de as getDidAddress, R as getDidAddressSegments, ue as getDidChainId, q as getEnvironment, Tn as getHttpUrl, y as getInternalError, Te as getJavascriptID, Ie as getJavascriptOS, Re as getLastItems, on as getNamespacedDidChainId, je as getNamespacesChains, Me as getNamespacesEventsForChainId, Ve as getNamespacesMethodsForChainId, Sn as getRelayClientMetadata, Fn as getRelayProtocolApi, xn as getRelayProtocolName, Wn as getRequiredNamespacesFromNamespaces, h as getSdkError, V as getUniqueValues, m as hasOverlap, ln as hashKey, fn as hashMessage, Oe as isBrowser, mt as isConformingNamespaces, kn as isExpired, H as isNode, et as isProposalStruct, be as isReactNative, Zn as isSessionCompatible, nt as isSessionStruct, En as isTypeOneEnvelope, E as isUndefined, Ke as isValidAccountId, xe as isValidAccounts, He as isValidActions, T as isValidArray, D as isValidChainId, ke as isValidChains, tt as isValidController, ct as isValidErrorReason, dt as isValidEvent, st as isValidId, Fe as isValidNamespaceAccounts, Y as isValidNamespaceActions, Le as isValidNamespaceChains, z as isValidNamespaceMethodsOrEvents, qe as isValidNamespaces, lt as isValidNamespacesChainId, pt as isValidNamespacesEvent, ft as isValidNamespacesRequest, C as isValidNumber, G as isValidObject, it as isValidParams, Be as isValidRelay, ot as isValidRelays, at as isValidRequest, yt as isValidRequestExpiry, rt as isValidRequiredNamespaces, ut as isValidResponse, u as isValidString, Xn as isValidUrl, An as mapEntries, Rn as mapToObj, _n as objToMap, j as parseAccountId, re as parseChainId, Ue as parseContextNames, Mn as parseExpirerTarget, De as parseRelayParams, zn as parseUri, pe as serialize, yn as validateDecoding, me as validateEncoding };\n//# sourceMappingURL=index.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}