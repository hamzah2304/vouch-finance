{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { noChange } from '../lit-html.js';\nimport { directive, Directive, PartType } from '../directive.js';\nclass ClassMapDirective extends Directive {\n  constructor(partInfo) {\n    var _a;\n    super(partInfo);\n    if (partInfo.type !== PartType.ATTRIBUTE || partInfo.name !== 'class' || ((_a = partInfo.strings) === null || _a === void 0 ? void 0 : _a.length) > 2) {\n      throw new Error('`classMap()` can only be used in the `class` attribute ' + 'and must be the only part in the attribute.');\n    }\n  }\n  render(classInfo) {\n    // Add spaces to ensure separation from static classes\n    return ' ' + Object.keys(classInfo).filter(key => classInfo[key]).join(' ') + ' ';\n  }\n  update(part, _ref) {\n    let [classInfo] = _ref;\n    var _a, _b;\n    // Remember dynamic classes on the first render\n    if (this._previousClasses === undefined) {\n      this._previousClasses = new Set();\n      if (part.strings !== undefined) {\n        this._staticClasses = new Set(part.strings.join(' ').split(/\\s/).filter(s => s !== ''));\n      }\n      for (const name in classInfo) {\n        if (classInfo[name] && !((_a = this._staticClasses) === null || _a === void 0 ? void 0 : _a.has(name))) {\n          this._previousClasses.add(name);\n        }\n      }\n      return this.render(classInfo);\n    }\n    const classList = part.element.classList;\n    // Remove old classes that no longer apply\n    // We use forEach() instead of for-of so that we don't require down-level\n    // iteration.\n    this._previousClasses.forEach(name => {\n      if (!(name in classInfo)) {\n        classList.remove(name);\n        this._previousClasses.delete(name);\n      }\n    });\n    // Add or remove classes based on their classMap value\n    for (const name in classInfo) {\n      // We explicitly want a loose truthy check of `value` because it seems\n      // more convenient that '' and 0 are skipped.\n      const value = !!classInfo[name];\n      if (value !== this._previousClasses.has(name) && !((_b = this._staticClasses) === null || _b === void 0 ? void 0 : _b.has(name))) {\n        if (value) {\n          classList.add(name);\n          this._previousClasses.add(name);\n        } else {\n          classList.remove(name);\n          this._previousClasses.delete(name);\n        }\n      }\n    }\n    return noChange;\n  }\n}\n/**\n * A directive that applies dynamic CSS classes.\n *\n * This must be used in the `class` attribute and must be the only part used in\n * the attribute. It takes each property in the `classInfo` argument and adds\n * the property name to the element's `classList` if the property value is\n * truthy; if the property value is falsey, the property name is removed from\n * the element's `class`.\n *\n * For example `{foo: bar}` applies the class `foo` if the value of `bar` is\n * truthy.\n *\n * @param classInfo\n */\nexport const classMap = directive(ClassMapDirective);\n//# sourceMappingURL=class-map.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}