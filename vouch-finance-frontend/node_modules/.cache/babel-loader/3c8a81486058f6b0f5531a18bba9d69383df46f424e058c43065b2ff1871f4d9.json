{"ast":null,"code":"\"use strict\";\n\n/**\n * All functionality below came from here https://github.com/Zilliqa/Zilliqa-JavaScript-Library/tree/dev/packages/zilliqa-js-crypto/src\n */\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromBech32Address = exports.toBech32Address = exports.toChecksumAddress = void 0;\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\nvar sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\nvar enc_hex_1 = __importDefault(require(\"crypto-js/enc-hex\"));\nvar CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nvar GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n// HRP is the human-readable part of zilliqa bech32 addresses\nvar HRP = 'zil';\nvar tHRP = 'tzil';\nfunction isByteString(str, len) {\n  return !!str.replace('0x', '').match(\"^[0-9a-fA-F]{\".concat(len, \"}$\"));\n}\nfunction isAddress(address) {\n  return isByteString(address, 40);\n}\n/**\n * convertBits\n *\n * groups buffers of a certain width to buffers of the desired width.\n *\n * For example, converts byte buffers to buffers of maximum 5 bit numbers,\n * padding those numbers as necessary. Necessary for encoding Ethereum-style\n * addresses as bech32 ones.\n * @param {Buffer} data\n * @param {number} fromWidth\n * @param {number} toWidth\n * @param {boolean} pad\n * @returns {Buffer|null}\n */\nfunction convertBits(data, fromWidth, toWidth, pad) {\n  if (pad === void 0) {\n    pad = true;\n  }\n  var acc = 0;\n  var bits = 0;\n  var ret = [];\n  var maxv = (1 << toWidth) - 1;\n  // tslint:disable-next-line\n  for (var p = 0; p < data.length; ++p) {\n    var value = data[p];\n    if (value < 0 || value >> fromWidth !== 0) {\n      return null;\n    }\n    acc = acc << fromWidth | value;\n    bits += fromWidth;\n    while (bits >= toWidth) {\n      bits -= toWidth;\n      ret.push(acc >> bits & maxv);\n    }\n  }\n  if (pad) {\n    if (bits > 0) {\n      ret.push(acc << toWidth - bits & maxv);\n    }\n  } else if (bits >= fromWidth || acc << toWidth - bits & maxv) {\n    return null;\n  }\n  return Buffer.from(ret);\n}\nfunction hrpExpand(hrp) {\n  var ret = [];\n  var p;\n  for (p = 0; p < hrp.length; ++p) {\n    ret.push(hrp.charCodeAt(p) >> 5);\n  }\n  ret.push(0);\n  for (p = 0; p < hrp.length; ++p) {\n    ret.push(hrp.charCodeAt(p) & 31);\n  }\n  return Buffer.from(ret);\n}\nfunction polymod(values) {\n  var chk = 1;\n  // tslint:disable-next-line\n  for (var p = 0; p < values.length; ++p) {\n    var top_1 = chk >> 25;\n    chk = (chk & 0x1ffffff) << 5 ^ values[p];\n    for (var i = 0; i < 5; ++i) {\n      if (top_1 >> i & 1) {\n        chk ^= GENERATOR[i];\n      }\n    }\n  }\n  return chk;\n}\nfunction createChecksum(hrp, data) {\n  var values = Buffer.concat([Buffer.from(hrpExpand(hrp)), data, Buffer.from([0, 0, 0, 0, 0, 0])]);\n  // var values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);\n  var mod = polymod(values) ^ 1;\n  var ret = [];\n  for (var p = 0; p < 6; ++p) {\n    ret.push(mod >> 5 * (5 - p) & 31);\n  }\n  return Buffer.from(ret);\n}\nfunction verifyChecksum(hrp, data) {\n  return polymod(Buffer.concat([hrpExpand(hrp), data])) === 1;\n}\nfunction encode(hrp, data) {\n  var combined = Buffer.concat([data, createChecksum(hrp, data)]);\n  var ret = hrp + '1';\n  // tslint:disable-next-line\n  for (var p = 0; p < combined.length; ++p) {\n    ret += CHARSET.charAt(combined[p]);\n  }\n  return ret;\n}\nfunction decode(bechString) {\n  var p;\n  var hasLower = false;\n  var hasUpper = false;\n  for (p = 0; p < bechString.length; ++p) {\n    if (bechString.charCodeAt(p) < 33 || bechString.charCodeAt(p) > 126) {\n      return null;\n    }\n    if (bechString.charCodeAt(p) >= 97 && bechString.charCodeAt(p) <= 122) {\n      hasLower = true;\n    }\n    if (bechString.charCodeAt(p) >= 65 && bechString.charCodeAt(p) <= 90) {\n      hasUpper = true;\n    }\n  }\n  if (hasLower && hasUpper) {\n    return null;\n  }\n  bechString = bechString.toLowerCase();\n  var pos = bechString.lastIndexOf('1');\n  if (pos < 1 || pos + 7 > bechString.length || bechString.length > 90) {\n    return null;\n  }\n  var hrp = bechString.substring(0, pos);\n  var data = [];\n  for (p = pos + 1; p < bechString.length; ++p) {\n    var d = CHARSET.indexOf(bechString.charAt(p));\n    if (d === -1) {\n      return null;\n    }\n    data.push(d);\n  }\n  if (!verifyChecksum(hrp, Buffer.from(data))) {\n    return null;\n  }\n  return {\n    hrp: hrp,\n    data: Buffer.from(data.slice(0, data.length - 6))\n  };\n}\n/**\n * toChecksumAddress\n *\n * takes hex-encoded string and returns the corresponding address\n * @param {string} address\n * @returns {string}\n */\nvar toChecksumAddress = function (address) {\n  if (!isAddress(address)) {\n    throw new Error(\"\".concat(address, \" is not a valid base 16 address\"));\n  }\n  address = address.toLowerCase().replace('0x', '');\n  var hash = enc_hex_1.default.stringify((0, sha256_1.default)(enc_hex_1.default.parse(address)));\n  var v = new bn_js_1.default(hash, 'hex', 'be');\n  var ret = '0x';\n  for (var i = 0; i < address.length; i++) {\n    if ('0123456789'.indexOf(address[i]) !== -1) {\n      ret += address[i];\n    } else {\n      ret += v.and(new bn_js_1.default(2).pow(new bn_js_1.default(255 - 6 * i))).gte(new bn_js_1.default(1)) ? address[i].toUpperCase() : address[i].toLowerCase();\n    }\n  }\n  return ret;\n};\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * toBech32Address\n *\n * Encodes a canonical 20-byte Ethereum-style address as a bech32 zilliqa\n * address.\n *\n * The expected format is zil1<address><checksum> where address and checksum\n * are the result of bech32 encoding a Buffer containing the address bytes.\n * @param {string} address 20 byte canonical address\n * @param {boolean} testnet\n * @returns {string} 38 char bech32 encoded zilliqa address\n */\nfunction toBech32Address(address, testnet) {\n  if (testnet === void 0) {\n    testnet = false;\n  }\n  if (!isAddress(address)) {\n    throw new Error('Invalid address format.');\n  }\n  var addrBz = convertBits(Buffer.from(address.replace('0x', ''), 'hex'), 8, 5);\n  if (addrBz === null) {\n    throw new Error('Could not convert byte Buffer to 5-bit Buffer');\n  }\n  return encode(testnet ? tHRP : HRP, addrBz);\n}\nexports.toBech32Address = toBech32Address;\n/**\n * fromBech32Address\n * @param {string} address - a valid Zilliqa bech32 address\n * @param {boolean} testnet\n * @returns {string} a canonical 20-byte Ethereum-style address\n */\nfunction fromBech32Address(address, testnet) {\n  if (testnet === void 0) {\n    testnet = false;\n  }\n  var res = decode(address);\n  if (res === null) {\n    throw new Error('Invalid bech32 address');\n  }\n  var hrp = res.hrp,\n    data = res.data;\n  var shouldBe = testnet ? tHRP : HRP;\n  if (hrp !== shouldBe) {\n    throw new Error(\"Expected hrp to be \".concat(shouldBe, \" but got \").concat(hrp));\n  }\n  var buf = convertBits(data, 5, 8, false);\n  if (buf === null) {\n    throw new Error('Could not convert buffer to bytes');\n  }\n  return (0, exports.toChecksumAddress)(buf.toString('hex'));\n}\nexports.fromBech32Address = fromBech32Address;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}