{"ast":null,"code":"import { logger, timestampWithMs } from '@sentry/utils';\nimport { SpanRecorder } from './span.js';\nimport { Transaction } from './transaction.js';\nconst DEFAULT_IDLE_TIMEOUT = 1000;\nconst DEFAULT_FINAL_TIMEOUT = 30000;\nconst DEFAULT_HEARTBEAT_INTERVAL = 5000;\n\n/**\n * @inheritDoc\n */\nclass IdleTransactionSpanRecorder extends SpanRecorder {\n  constructor(_pushActivity, _popActivity, transactionSpanId, maxlen) {\n    super(maxlen);\n    this._pushActivity = _pushActivity;\n    this._popActivity = _popActivity;\n    this.transactionSpanId = transactionSpanId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  add(span) {\n    // We should make sure we do not push and pop activities for\n    // the transaction that this span recorder belongs to.\n    if (span.spanId !== this.transactionSpanId) {\n      // We patch span.finish() to pop an activity after setting an endTimestamp.\n      span.finish = endTimestamp => {\n        span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();\n        this._popActivity(span.spanId);\n      };\n\n      // We should only push new activities if the span does not have an end timestamp.\n      if (span.endTimestamp === undefined) {\n        this._pushActivity(span.spanId);\n      }\n    }\n    super.add(span);\n  }\n}\n\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\nclass IdleTransaction extends Transaction {\n  // Activities store a list of active spans\n  __init() {\n    this.activities = {};\n  }\n\n  // Track state of activities in previous heartbeat\n\n  // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n  __init2() {\n    this._heartbeatCounter = 0;\n  }\n\n  // We should not use heartbeat if we finished a transaction\n  __init3() {\n    this._finished = false;\n  }\n  __init4() {\n    this._beforeFinishCallbacks = [];\n  }\n\n  /**\n   * Timer that tracks Transaction idleTimeout\n   */\n\n  constructor(transactionContext, _idleHub) {\n    let _idleTimeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_IDLE_TIMEOUT;\n    let _finalTimeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_FINAL_TIMEOUT;\n    let _heartbeatInterval = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : DEFAULT_HEARTBEAT_INTERVAL;\n    let _onScope = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n    super(transactionContext, _idleHub);\n    this._idleHub = _idleHub;\n    this._idleTimeout = _idleTimeout;\n    this._finalTimeout = _finalTimeout;\n    this._heartbeatInterval = _heartbeatInterval;\n    this._onScope = _onScope;\n    IdleTransaction.prototype.__init.call(this);\n    IdleTransaction.prototype.__init2.call(this);\n    IdleTransaction.prototype.__init3.call(this);\n    IdleTransaction.prototype.__init4.call(this);\n    if (_onScope) {\n      // There should only be one active transaction on the scope\n      clearActiveTransaction(_idleHub);\n\n      // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`);\n      _idleHub.configureScope(scope => scope.setSpan(this));\n    }\n    this._startIdleTimeout();\n    setTimeout(() => {\n      if (!this._finished) {\n        this.setStatus('deadline_exceeded');\n        this.finish();\n      }\n    }, this._finalTimeout);\n  }\n\n  /** {@inheritDoc} */\n  finish() {\n    let endTimestamp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : timestampWithMs();\n    this._finished = true;\n    this.activities = {};\n    if (this.spanRecorder) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);\n      for (const callback of this._beforeFinishCallbacks) {\n        callback(this, endTimestamp);\n      }\n      this.spanRecorder.spans = this.spanRecorder.spans.filter(span => {\n        // If we are dealing with the transaction itself, we just return it\n        if (span.spanId === this.spanId) {\n          return true;\n        }\n\n        // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n        if (!span.endTimestamp) {\n          span.endTimestamp = endTimestamp;\n          span.setStatus('cancelled');\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n        }\n        const keepSpan = span.startTimestamp < endTimestamp;\n        if (!keepSpan) {\n          (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] discarding Span since it happened after Transaction was finished', JSON.stringify(span, undefined, 2));\n        }\n        return keepSpan;\n      });\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] flushing IdleTransaction');\n    } else {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] No active IdleTransaction');\n    }\n\n    // if `this._onScope` is `true`, the transaction put itself on the scope when it started\n    if (this._onScope) {\n      clearActiveTransaction(this._idleHub);\n    }\n    return super.finish(endTimestamp);\n  }\n\n  /**\n   * Register a callback function that gets excecuted before the transaction finishes.\n   * Useful for cleanup or if you want to add any additional spans based on current context.\n   *\n   * This is exposed because users have no other way of running something before an idle transaction\n   * finishes.\n   */\n  registerBeforeFinishCallback(callback) {\n    this._beforeFinishCallbacks.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  initSpanRecorder(maxlen) {\n    if (!this.spanRecorder) {\n      const pushActivity = id => {\n        if (this._finished) {\n          return;\n        }\n        this._pushActivity(id);\n      };\n      const popActivity = id => {\n        if (this._finished) {\n          return;\n        }\n        this._popActivity(id);\n      };\n      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);\n\n      // Start heartbeat so that transactions do not run forever.\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('Starting heartbeat');\n      this._pingHeartbeat();\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * Cancels the existing idletimeout, if there is one\n   */\n  _cancelIdleTimeout() {\n    if (this._idleTimeoutID) {\n      clearTimeout(this._idleTimeoutID);\n      this._idleTimeoutID = undefined;\n    }\n  }\n\n  /**\n   * Creates an idletimeout\n   */\n  _startIdleTimeout(endTimestamp) {\n    this._cancelIdleTimeout();\n    this._idleTimeoutID = setTimeout(() => {\n      if (!this._finished && Object.keys(this.activities).length === 0) {\n        this.finish(endTimestamp);\n      }\n    }, this._idleTimeout);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  _pushActivity(spanId) {\n    this._cancelIdleTimeout();\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] pushActivity: ${spanId}`);\n    this.activities[spanId] = true;\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  _popActivity(spanId) {\n    if (this.activities[spanId]) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] popActivity ${spanId}`);\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this.activities[spanId];\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n    if (Object.keys(this.activities).length === 0) {\n      // We need to add the timeout here to have the real endtimestamp of the transaction\n      // Remember timestampWithMs is in seconds, timeout is in ms\n      const endTimestamp = timestampWithMs() + this._idleTimeout / 1000;\n      this._startIdleTimeout(endTimestamp);\n    }\n  }\n\n  /**\n   * Checks when entries of this.activities are not changing for 3 beats.\n   * If this occurs we finish the transaction.\n   */\n  _beat() {\n    // We should not be running heartbeat if the idle transaction is finished.\n    if (this._finished) {\n      return;\n    }\n    const heartbeatString = Object.keys(this.activities).join('');\n    if (heartbeatString === this._prevHeartbeatString) {\n      this._heartbeatCounter++;\n    } else {\n      this._heartbeatCounter = 1;\n    }\n    this._prevHeartbeatString = heartbeatString;\n    if (this._heartbeatCounter >= 3) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] Transaction finished because of no change for 3 heart beats');\n      this.setStatus('deadline_exceeded');\n      this.finish();\n    } else {\n      this._pingHeartbeat();\n    }\n  }\n\n  /**\n   * Pings the heartbeat\n   */\n  _pingHeartbeat() {\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);\n    setTimeout(() => {\n      this._beat();\n    }, this._heartbeatInterval);\n  }\n}\n\n/**\n * Reset transaction on scope to `undefined`\n */\nfunction clearActiveTransaction(hub) {\n  const scope = hub.getScope();\n  if (scope) {\n    const transaction = scope.getTransaction();\n    if (transaction) {\n      scope.setSpan(undefined);\n    }\n  }\n}\nexport { DEFAULT_FINAL_TIMEOUT, DEFAULT_HEARTBEAT_INTERVAL, DEFAULT_IDLE_TIMEOUT, IdleTransaction, IdleTransactionSpanRecorder };\n//# sourceMappingURL=idletransaction.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}