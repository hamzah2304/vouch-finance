{"ast":null,"code":"import { concat } from \"uint8arrays/concat\";\nimport { toString } from \"uint8arrays/to-string\";\nimport { fromString } from \"uint8arrays/from-string\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { DATA_ENCODING, DID_DELIMITER, DID_METHOD, DID_PREFIX, JSON_ENCODING, JWT_DELIMITER, JWT_ENCODING, MULTICODEC_ED25519_BASE, MULTICODEC_ED25519_ENCODING, MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_LENGTH } from \"./constants\";\nexport function decodeJSON(str) {\n  return safeJsonParse(toString(fromString(str, JWT_ENCODING), JSON_ENCODING));\n}\nexport function encodeJSON(val) {\n  return toString(fromString(safeJsonStringify(val), JSON_ENCODING), JWT_ENCODING);\n}\nexport function encodeIss(publicKey) {\n  const header = fromString(MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_ENCODING);\n  const multicodec = MULTICODEC_ED25519_BASE + toString(concat([header, publicKey]), MULTICODEC_ED25519_ENCODING);\n  return [DID_PREFIX, DID_METHOD, multicodec].join(DID_DELIMITER);\n}\nexport function decodeIss(issuer) {\n  const [prefix, method, multicodec] = issuer.split(DID_DELIMITER);\n  if (prefix !== DID_PREFIX || method !== DID_METHOD) {\n    throw new Error(`Issuer must be a DID with method \"key\"`);\n  }\n  const base = multicodec.slice(0, 1);\n  if (base !== MULTICODEC_ED25519_BASE) {\n    throw new Error(`Issuer must be a key in mulicodec format`);\n  }\n  const bytes = fromString(multicodec.slice(1), MULTICODEC_ED25519_ENCODING);\n  const type = toString(bytes.slice(0, 2), MULTICODEC_ED25519_ENCODING);\n  if (type !== MULTICODEC_ED25519_HEADER) {\n    throw new Error(`Issuer must be a public key with type \"Ed25519\"`);\n  }\n  const publicKey = bytes.slice(2);\n  if (publicKey.length !== MULTICODEC_ED25519_LENGTH) {\n    throw new Error(`Issuer must be a public key with length 32 bytes`);\n  }\n  return publicKey;\n}\nexport function encodeSig(bytes) {\n  return toString(bytes, JWT_ENCODING);\n}\nexport function decodeSig(encoded) {\n  return fromString(encoded, JWT_ENCODING);\n}\nexport function encodeData(params) {\n  return fromString([encodeJSON(params.header), encodeJSON(params.payload)].join(JWT_DELIMITER), DATA_ENCODING);\n}\nexport function decodeData(data) {\n  const params = toString(data, DATA_ENCODING).split(JWT_DELIMITER);\n  const header = decodeJSON(params[0]);\n  const payload = decodeJSON(params[1]);\n  return {\n    header,\n    payload\n  };\n}\nexport function encodeJWT(params) {\n  return [encodeJSON(params.header), encodeJSON(params.payload), encodeSig(params.signature)].join(JWT_DELIMITER);\n}\nexport function decodeJWT(jwt) {\n  const params = jwt.split(JWT_DELIMITER);\n  const header = decodeJSON(params[0]);\n  const payload = decodeJSON(params[1]);\n  const signature = decodeSig(params[2]);\n  const data = fromString(params.slice(0, 2).join(JWT_DELIMITER), DATA_ENCODING);\n  return {\n    header,\n    payload,\n    signature,\n    data\n  };\n}\n//# sourceMappingURL=utils.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}