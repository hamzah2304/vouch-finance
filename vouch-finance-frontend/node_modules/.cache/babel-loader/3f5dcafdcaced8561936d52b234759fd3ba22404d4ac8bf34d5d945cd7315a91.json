{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unwrapResult = exports.wrapResult = exports.EthereumNetworksInverted = exports.EthereumNetworks = exports.findNamingServiceName = exports.domainExtensionToNamingServiceName = exports.constructRecords = exports.isNullAddress = exports.hexToBytes = exports.signedLink = void 0;\nvar publicTypes_1 = require(\"../types/publicTypes\");\nvar types_1 = require(\"../types\");\nvar ProviderURLMap = {\n  infura: {\n    mainnet: 'https://mainnet.infura.io/v3/',\n    rinkeby: 'https://rinkeby.infura.io/v3/',\n    goerli: 'https://goerli.infura.io/v3/',\n    'polygon-mainnet': 'https://polygon-mainnet.infura.io/v3/',\n    'polygon-mumbai': 'https://polygon-mumbai.infura.io/v3/'\n  },\n  alchemy: {\n    mainnet: 'https://eth-mainnet.alchemyapi.io/v2/',\n    rinkeby: 'https://eth-rinkeby.alchemyapi.io/v2/',\n    goerli: 'https://eth-goerli.alchemyapi.io/v2/',\n    'polygon-mainnet': 'https://polygon-mainnet.g.alchemy.com/v2/',\n    'polygon-mumbai': 'https://polygon-mumbai.g.alchemy.com/v2/'\n  }\n};\nfunction signedLink(key, network, provider) {\n  if (network === void 0) {\n    network = 'mainnet';\n  }\n  if (provider === void 0) {\n    provider = 'alchemy';\n  }\n  var url = ProviderURLMap[provider][network];\n  return \"\".concat(url).concat(key);\n}\nexports.signedLink = signedLink;\nfunction hexToBytes(hexString) {\n  var hex = hexString.replace(/^0x/i, '');\n  var bytes = [];\n  for (var c = 0; c < hex.length; c += 2) {\n    bytes.push(parseInt(hex.substr(c, 2), 16));\n  }\n  return bytes;\n}\nexports.hexToBytes = hexToBytes;\nfunction isNullAddress(key) {\n  if (!key) {\n    return true;\n  }\n  return Object.values(types_1.NullAddresses).includes(key);\n}\nexports.isNullAddress = isNullAddress;\nfunction constructRecords(keys, values) {\n  var records = {};\n  keys.forEach(function (key, index) {\n    records[key] = (values instanceof Array ? values[index] : values === null || values === void 0 ? void 0 : values[key]) || '';\n  });\n  return records;\n}\nexports.constructRecords = constructRecords;\nexports.domainExtensionToNamingServiceName = {\n  crypto: publicTypes_1.NamingServiceName.UNS,\n  zil: publicTypes_1.NamingServiceName.ZNS\n};\nvar findNamingServiceName = function (domain) {\n  var extension = domain.split('.').pop();\n  if (!extension) {\n    return '';\n  } else if (extension in exports.domainExtensionToNamingServiceName) {\n    return exports.domainExtensionToNamingServiceName[extension];\n  } else {\n    return exports.domainExtensionToNamingServiceName.crypto;\n  }\n};\nexports.findNamingServiceName = findNamingServiceName;\nexports.EthereumNetworks = {\n  mainnet: 1,\n  ropsten: 3,\n  rinkeby: 4,\n  goerli: 5,\n  'polygon-mainnet': 137,\n  'polygon-mumbai': 80001\n};\nexports.EthereumNetworksInverted = {\n  1: 'mainnet',\n  3: 'ropsten',\n  4: 'rinkeby',\n  5: 'goerli',\n  137: 'polygon-mainnet',\n  80001: 'polygon-mumbai'\n};\nvar wrapResult = function (func) {\n  var callResult;\n  // Catch immediately in case it's not an async call.\n  try {\n    callResult = func();\n  } catch (error) {\n    return Promise.resolve({\n      result: null,\n      error: error\n    });\n  }\n  // `Promise.resolve` will convert both promise-like objects and plain values to promises.\n  var promise = callResult instanceof Promise ? callResult : Promise.resolve(callResult);\n  // We wrap results and errors to avoid unhandled promise rejections in case we won't `await` every promise\n  // and return earlier.\n  return promise.then(function (result) {\n    return {\n      result: result,\n      error: null\n    };\n  }, function (error) {\n    return {\n      result: null,\n      error: error\n    };\n  });\n};\nexports.wrapResult = wrapResult;\nvar unwrapResult = function (wrappedResult) {\n  if (wrappedResult.error !== null) {\n    throw wrappedResult.error;\n  }\n  return wrappedResult.result;\n};\nexports.unwrapResult = unwrapResult;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}