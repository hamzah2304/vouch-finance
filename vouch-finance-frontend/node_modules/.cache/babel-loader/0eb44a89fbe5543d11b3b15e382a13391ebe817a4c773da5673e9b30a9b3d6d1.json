{"ast":null,"code":"import { logger, extractTraceparentData, baggageHeaderToDynamicSamplingContext, getDomElement } from '@sentry/utils';\nimport { startIdleTransaction } from '../hubextensions.js';\nimport { DEFAULT_IDLE_TIMEOUT, DEFAULT_FINAL_TIMEOUT, DEFAULT_HEARTBEAT_INTERVAL } from '../idletransaction.js';\nimport '@sentry/core';\nimport { registerBackgroundTabDetection } from './backgroundtab.js';\nimport { startTrackingWebVitals, startTrackingLongTasks, addPerformanceEntries } from './metrics/index.js';\nimport { defaultRequestInstrumentationOptions, instrumentOutgoingRequests } from './request.js';\nimport { instrumentRoutingWithDefaults } from './router.js';\nimport { WINDOW } from './types.js';\nconst BROWSER_TRACING_INTEGRATION_ID = 'BrowserTracing';\n\n/** Options for Browser Tracing integration */\n\nconst DEFAULT_BROWSER_TRACING_OPTIONS = {\n  idleTimeout: DEFAULT_IDLE_TIMEOUT,\n  finalTimeout: DEFAULT_FINAL_TIMEOUT,\n  heartbeatInterval: DEFAULT_HEARTBEAT_INTERVAL,\n  markBackgroundTransactions: true,\n  routingInstrumentation: instrumentRoutingWithDefaults,\n  startTransactionOnLocationChange: true,\n  startTransactionOnPageLoad: true,\n  enableLongTask: true,\n  _experiments: {},\n  ...defaultRequestInstrumentationOptions\n};\n\n/**\n * The Browser Tracing integration automatically instruments browser pageload/navigation\n * actions as transactions, and captures requests, metrics and errors as spans.\n *\n * The integration can be configured with a variety of options, and can be extended to use\n * any routing library. This integration uses {@see IdleTransaction} to create transactions.\n */\nclass BrowserTracing {\n  // This class currently doesn't have a static `id` field like the other integration classes, because it prevented\n  // @sentry/tracing from being treeshaken. Tree shakers do not like static fields, because they behave like side effects.\n  // TODO: Come up with a better plan, than using static fields on integration classes, and use that plan on all\n  // integrations.\n\n  /** Browser Tracing integration options */\n\n  /**\n   * @inheritDoc\n   */\n  __init() {\n    this.name = BROWSER_TRACING_INTEGRATION_ID;\n  }\n  constructor(_options) {\n    BrowserTracing.prototype.__init.call(this);\n    this.options = {\n      ...DEFAULT_BROWSER_TRACING_OPTIONS,\n      ..._options\n    };\n\n    // Special case: enableLongTask can be set in _experiments\n    // TODO (v8): Remove this in v8\n    if (this.options._experiments.enableLongTask !== undefined) {\n      this.options.enableLongTask = this.options._experiments.enableLongTask;\n    }\n\n    // TODO (v8): remove this block after tracingOrigins is removed\n    // Set tracePropagationTargets to tracingOrigins if specified by the user\n    // In case both are specified, tracePropagationTargets takes precedence\n    // eslint-disable-next-line deprecation/deprecation\n    if (_options && !_options.tracePropagationTargets && _options.tracingOrigins) {\n      // eslint-disable-next-line deprecation/deprecation\n      this.options.tracePropagationTargets = _options.tracingOrigins;\n    }\n    startTrackingWebVitals();\n    if (this.options.enableLongTask) {\n      startTrackingLongTasks();\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setupOnce(_, getCurrentHub) {\n    this._getCurrentHub = getCurrentHub;\n    const {\n      routingInstrumentation: instrumentRouting,\n      startTransactionOnLocationChange,\n      startTransactionOnPageLoad,\n      markBackgroundTransactions,\n      traceFetch,\n      traceXHR,\n      tracePropagationTargets,\n      shouldCreateSpanForRequest,\n      _experiments\n    } = this.options;\n    instrumentRouting(context => this._createRouteTransaction(context), startTransactionOnPageLoad, startTransactionOnLocationChange);\n    if (markBackgroundTransactions) {\n      registerBackgroundTabDetection();\n    }\n    if (_experiments.enableInteractions) {\n      this._registerInteractionListener();\n    }\n    instrumentOutgoingRequests({\n      traceFetch,\n      traceXHR,\n      tracePropagationTargets,\n      shouldCreateSpanForRequest\n    });\n  }\n\n  /** Create routing idle transaction. */\n  _createRouteTransaction(context) {\n    if (!this._getCurrentHub) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`[Tracing] Did not create ${context.op} transaction because _getCurrentHub is invalid.`);\n      return undefined;\n    }\n    const {\n      beforeNavigate,\n      idleTimeout,\n      finalTimeout,\n      heartbeatInterval\n    } = this.options;\n    const isPageloadTransaction = context.op === 'pageload';\n    const sentryTraceMetaTagValue = isPageloadTransaction ? getMetaContent('sentry-trace') : null;\n    const baggageMetaTagValue = isPageloadTransaction ? getMetaContent('baggage') : null;\n    const traceParentData = sentryTraceMetaTagValue ? extractTraceparentData(sentryTraceMetaTagValue) : undefined;\n    const dynamicSamplingContext = baggageMetaTagValue ? baggageHeaderToDynamicSamplingContext(baggageMetaTagValue) : undefined;\n    const expandedContext = {\n      ...context,\n      ...traceParentData,\n      metadata: {\n        ...context.metadata,\n        dynamicSamplingContext: traceParentData && !dynamicSamplingContext ? {} : dynamicSamplingContext\n      },\n      trimEnd: true\n    };\n    const modifiedContext = typeof beforeNavigate === 'function' ? beforeNavigate(expandedContext) : expandedContext;\n\n    // For backwards compatibility reasons, beforeNavigate can return undefined to \"drop\" the transaction (prevent it\n    // from being sent to Sentry).\n    const finalContext = modifiedContext === undefined ? {\n      ...expandedContext,\n      sampled: false\n    } : modifiedContext;\n\n    // If `beforeNavigate` set a custom name, record that fact\n    finalContext.metadata = finalContext.name !== expandedContext.name ? {\n      ...finalContext.metadata,\n      source: 'custom'\n    } : finalContext.metadata;\n    this._latestRouteName = finalContext.name;\n    this._latestRouteSource = finalContext.metadata && finalContext.metadata.source;\n    if (finalContext.sampled === false) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] Will not send ${finalContext.op} transaction because of beforeNavigate.`);\n    }\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] Starting ${finalContext.op} transaction on scope`);\n    const hub = this._getCurrentHub();\n    const {\n      location\n    } = WINDOW;\n    const idleTransaction = startIdleTransaction(hub, finalContext, idleTimeout, finalTimeout, true, {\n      location\n    },\n    // for use in the tracesSampler\n    heartbeatInterval);\n    idleTransaction.registerBeforeFinishCallback(transaction => {\n      addPerformanceEntries(transaction);\n    });\n    return idleTransaction;\n  }\n\n  /** Start listener for interaction transactions */\n  _registerInteractionListener() {\n    let inflightInteractionTransaction;\n    const registerInteractionTransaction = () => {\n      const {\n        idleTimeout,\n        finalTimeout,\n        heartbeatInterval\n      } = this.options;\n      const op = 'ui.action.click';\n      if (inflightInteractionTransaction) {\n        inflightInteractionTransaction.finish();\n        inflightInteractionTransaction = undefined;\n      }\n      if (!this._getCurrentHub) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`[Tracing] Did not create ${op} transaction because _getCurrentHub is invalid.`);\n        return undefined;\n      }\n      if (!this._latestRouteName) {\n        (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn(`[Tracing] Did not create ${op} transaction because _latestRouteName is missing.`);\n        return undefined;\n      }\n      const hub = this._getCurrentHub();\n      const {\n        location\n      } = WINDOW;\n      const context = {\n        name: this._latestRouteName,\n        op,\n        trimEnd: true,\n        metadata: {\n          source: this._latestRouteSource || 'url'\n        }\n      };\n      inflightInteractionTransaction = startIdleTransaction(hub, context, idleTimeout, finalTimeout, true, {\n        location\n      },\n      // for use in the tracesSampler\n      heartbeatInterval);\n    };\n    ['click'].forEach(type => {\n      addEventListener(type, registerInteractionTransaction, {\n        once: false,\n        capture: true\n      });\n    });\n  }\n}\n\n/** Returns the value of a meta tag */\nfunction getMetaContent(metaName) {\n  // Can't specify generic to `getDomElement` because tracing can be used\n  // in a variety of environments, have to disable `no-unsafe-member-access`\n  // as a result.\n  const metaTag = getDomElement(`meta[name=${metaName}]`);\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n  return metaTag ? metaTag.getAttribute('content') : null;\n}\nexport { BROWSER_TRACING_INTEGRATION_ID, BrowserTracing, getMetaContent };\n//# sourceMappingURL=browsertracing.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}