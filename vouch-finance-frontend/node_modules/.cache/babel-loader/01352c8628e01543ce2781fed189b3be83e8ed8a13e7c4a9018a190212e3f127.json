{"ast":null,"code":"\"use strict\";\n\n// Copyright (c) 2018-2022 Coinbase, Inc. <https://www.coinbase.com/>\n// Licensed under the Apache License, version 2.0\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletSDKRelay = void 0;\nconst bind_decorator_1 = __importDefault(require(\"bind-decorator\"));\nconst eth_rpc_errors_1 = require(\"eth-rpc-errors\");\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst DiagnosticLogger_1 = require(\"../connection/DiagnosticLogger\");\nconst WalletSDKConnection_1 = require(\"../connection/WalletSDKConnection\");\nconst WalletUIError_1 = require(\"../provider/WalletUIError\");\nconst types_1 = require(\"../types\");\nconst util_1 = require(\"../util\");\nconst aes256gcm = __importStar(require(\"./aes256gcm\"));\nconst Session_1 = require(\"./Session\");\nconst WalletSDKRelayAbstract_1 = require(\"./WalletSDKRelayAbstract\");\nconst Web3Method_1 = require(\"./Web3Method\");\nconst Web3RequestCanceledMessage_1 = require(\"./Web3RequestCanceledMessage\");\nconst Web3RequestMessage_1 = require(\"./Web3RequestMessage\");\nconst Web3Response_1 = require(\"./Web3Response\");\nconst Web3ResponseMessage_1 = require(\"./Web3ResponseMessage\");\nclass WalletSDKRelay extends WalletSDKRelayAbstract_1.WalletSDKRelayAbstract {\n  constructor(options) {\n    var _a;\n    super();\n    this.accountsCallback = null;\n    this.chainCallback = null;\n    this.dappDefaultChainSubject = new rxjs_1.BehaviorSubject(1);\n    this.dappDefaultChain = 1;\n    this.appName = \"\";\n    this.appLogoUrl = null;\n    this.subscriptions = new rxjs_1.Subscription();\n    this.linkAPIUrl = options.linkAPIUrl;\n    this.storage = options.storage;\n    this.options = options;\n    const {\n      session,\n      ui,\n      connection\n    } = this.subscribe();\n    this._session = session;\n    this.connection = connection;\n    this.relayEventManager = options.relayEventManager;\n    if (options.diagnosticLogger && options.eventListener) {\n      throw new Error(\"Can't have both eventListener and diagnosticLogger options, use only diagnosticLogger\");\n    }\n    if (options.eventListener) {\n      this.diagnostic = {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        log: options.eventListener.onEvent\n      };\n    } else {\n      this.diagnostic = options.diagnosticLogger;\n    }\n    this._reloadOnDisconnect = (_a = options.reloadOnDisconnect) !== null && _a !== void 0 ? _a : true;\n    this.ui = ui;\n  }\n  subscribe() {\n    this.subscriptions.add(this.dappDefaultChainSubject.subscribe(chainId => {\n      if (this.dappDefaultChain !== chainId) {\n        this.dappDefaultChain = chainId;\n      }\n    }));\n    const session = Session_1.Session.load(this.storage) || new Session_1.Session(this.storage).save();\n    const connection = new WalletSDKConnection_1.WalletSDKConnection(session.id, session.key, this.linkAPIUrl, this.diagnostic);\n    this.subscriptions.add(connection.sessionConfig$.subscribe({\n      next: sessionConfig => {\n        this.onSessionConfigChanged(sessionConfig);\n      },\n      error: () => {\n        var _a;\n        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n          message: \"error while invoking session config callback\"\n        });\n      }\n    }));\n    this.subscriptions.add(connection.incomingEvent$.pipe((0, operators_1.filter)(m => m.event === \"Web3Response\")).subscribe({\n      next: this.handleIncomingEvent\n    }));\n    this.subscriptions.add(connection.linked$.pipe((0, operators_1.skip)(1), (0, operators_1.tap)(linked => {\n      var _a;\n      this.isLinked = linked;\n      const cachedAddresses = this.storage.getItem(WalletSDKRelayAbstract_1.LOCAL_STORAGE_ADDRESSES_KEY);\n      if (linked) {\n        // Only set linked session variable one way\n        this.session.linked = linked;\n      }\n      this.isUnlinkedErrorState = false;\n      if (cachedAddresses) {\n        const addresses = cachedAddresses.split(\" \");\n        const wasConnectedViaStandalone = this.storage.getItem(\"IsStandaloneSigning\") === \"true\";\n        if (addresses[0] !== \"\" && !linked && this.session.linked && !wasConnectedViaStandalone) {\n          this.isUnlinkedErrorState = true;\n          const sessionIdHash = this.getSessionIdHash();\n          (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.UNLINKED_ERROR_STATE, {\n            sessionIdHash\n          });\n        }\n      }\n    })).subscribe());\n    // if session is marked destroyed, reset and reload\n    this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)(c => !!c.metadata && c.metadata.__destroyed === \"1\")).subscribe(() => {\n      var _a;\n      const alreadyDestroyed = connection.isDestroyed;\n      (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.METADATA_DESTROYED, {\n        alreadyDestroyed,\n        sessionIdHash: this.getSessionIdHash()\n      });\n      return this.resetAndReload();\n    }));\n    this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)(c => c.metadata && c.metadata.WalletUsername !== undefined)).pipe((0, operators_1.mergeMap)(c => aes256gcm.decrypt(c.metadata.WalletUsername, session.secret))).subscribe({\n      next: walletUsername => {\n        this.storage.setItem(WalletSDKRelayAbstract_1.WALLET_USER_NAME_KEY, walletUsername);\n      },\n      error: () => {\n        var _a;\n        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n          message: \"Had error decrypting\",\n          value: \"username\"\n        });\n      }\n    }));\n    this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)(c => c.metadata && c.metadata.AppVersion !== undefined)).pipe((0, operators_1.mergeMap)(c => aes256gcm.decrypt(c.metadata.AppVersion, session.secret))).subscribe({\n      next: appVersion => {\n        this.storage.setItem(WalletSDKRelayAbstract_1.APP_VERSION_KEY, appVersion);\n      },\n      error: () => {\n        var _a;\n        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n          message: \"Had error decrypting\",\n          value: \"appversion\"\n        });\n      }\n    }));\n    this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)(c => c.metadata && c.metadata.ChainId !== undefined && c.metadata.JsonRpcUrl !== undefined)).pipe((0, operators_1.mergeMap)(c => (0, rxjs_1.zip)(aes256gcm.decrypt(c.metadata.ChainId, session.secret), aes256gcm.decrypt(c.metadata.JsonRpcUrl, session.secret)))).pipe((0, operators_1.distinctUntilChanged)()).subscribe({\n      next: _ref => {\n        let [chainId, jsonRpcUrl] = _ref;\n        if (this.chainCallback) {\n          this.chainCallback(chainId, jsonRpcUrl);\n        }\n      },\n      error: () => {\n        var _a;\n        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n          message: \"Had error decrypting\",\n          value: \"chainId|jsonRpcUrl\"\n        });\n      }\n    }));\n    this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)(c => c.metadata && c.metadata.EthereumAddress !== undefined)).pipe((0, operators_1.mergeMap)(c => aes256gcm.decrypt(c.metadata.EthereumAddress, session.secret))).subscribe({\n      next: selectedAddress => {\n        if (this.accountsCallback) {\n          this.accountsCallback([selectedAddress]);\n        }\n        if (WalletSDKRelay.accountRequestCallbackIds.size > 0) {\n          // We get the ethereum address from the metadata.  If for whatever\n          // reason we don't get a response via an explicit web3 message\n          // we can still fulfill the eip1102 request.\n          Array.from(WalletSDKRelay.accountRequestCallbackIds.values()).forEach(id => {\n            const message = (0, Web3ResponseMessage_1.Web3ResponseMessage)({\n              id,\n              response: (0, Web3Response_1.RequestEthereumAccountsResponse)([selectedAddress])\n            });\n            this.invokeCallback(Object.assign(Object.assign({}, message), {\n              id\n            }));\n          });\n          WalletSDKRelay.accountRequestCallbackIds.clear();\n        }\n      },\n      error: () => {\n        var _a;\n        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n          message: \"Had error decrypting\",\n          value: \"selectedAddress\"\n        });\n      }\n    }));\n    this.subscriptions.add(connection.sessionConfig$.pipe((0, operators_1.filter)(c => c.metadata && c.metadata.AppSrc !== undefined)).pipe((0, operators_1.mergeMap)(c => aes256gcm.decrypt(c.metadata.AppSrc, session.secret))).subscribe({\n      next: appSrc => {\n        this.ui.setAppSrc(appSrc);\n      },\n      error: () => {\n        var _a;\n        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n          message: \"Had error decrypting\",\n          value: \"appSrc\"\n        });\n      }\n    }));\n    const ui = this.options.uiConstructor({\n      linkAPIUrl: this.options.linkAPIUrl,\n      version: this.options.version,\n      darkMode: this.options.darkMode,\n      session,\n      connected$: connection.connected$,\n      chainId$: this.dappDefaultChainSubject\n    });\n    connection.connect();\n    return {\n      session,\n      ui,\n      connection\n    };\n  }\n  attachUI() {\n    this.ui.attach();\n  }\n  resetAndReload() {\n    this.connection.setSessionMetadata(\"__destroyed\", \"1\").pipe((0, operators_1.timeout)(1000), (0, operators_1.catchError)(_ => (0, rxjs_1.of)(null))).subscribe(_ => {\n      var _a, _b, _c;\n      const isStandalone = this.ui.isStandalone();\n      try {\n        this.subscriptions.unsubscribe();\n      } catch (err) {\n        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n          message: \"Had error unsubscribing\"\n        });\n      }\n      (_b = this.diagnostic) === null || _b === void 0 ? void 0 : _b.log(DiagnosticLogger_1.EVENTS.SESSION_STATE_CHANGE, {\n        method: \"relay::resetAndReload\",\n        sessionMetadataChange: \"__destroyed, 1\",\n        sessionIdHash: this.getSessionIdHash()\n      });\n      this.connection.destroy();\n      /**\n       * Only clear storage if the session id we have in memory matches the one on disk\n       * Otherwise, in the case where we have 2 tabs, another tab might have cleared\n       * storage already.  In that case if we clear storage again, the user will be in\n       * a state where the first tab allows the user to connect but the session that\n       * was used isn't persisted.  This leaves the user in a state where they aren't\n       * connected to the mobile app.\n       */\n      const storedSession = Session_1.Session.load(this.storage);\n      if ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) === this._session.id) {\n        this.storage.clear();\n      } else if (storedSession) {\n        (_c = this.diagnostic) === null || _c === void 0 ? void 0 : _c.log(DiagnosticLogger_1.EVENTS.SKIPPED_CLEARING_SESSION, {\n          sessionIdHash: this.getSessionIdHash(),\n          storedSessionIdHash: Session_1.Session.hash(storedSession.id)\n        });\n      }\n      if (this._reloadOnDisconnect) {\n        this.ui.reloadUI();\n        return;\n      }\n      if (this.accountsCallback) {\n        this.accountsCallback([], true);\n      }\n      const {\n        session,\n        ui,\n        connection\n      } = this.subscribe();\n      this._session = session;\n      this.connection = connection;\n      this.ui = ui;\n      if (isStandalone && this.ui.setStandalone) this.ui.setStandalone(true);\n      this.attachUI();\n    }, err => {\n      var _a;\n      (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.FAILURE, {\n        method: \"relay::resetAndReload\",\n        message: `failed to reset and reload with ${err}`,\n        sessionIdHash: this.getSessionIdHash()\n      });\n    });\n  }\n  setAppInfo(appName, appLogoUrl) {\n    this.appName = appName;\n    this.appLogoUrl = appLogoUrl;\n  }\n  getStorageItem(key) {\n    return this.storage.getItem(key);\n  }\n  get session() {\n    return this._session;\n  }\n  setStorageItem(key, value) {\n    this.storage.setItem(key, value);\n  }\n  signEthereumMessage(message, address, addPrefix, typedDataJson) {\n    return this.sendRequest({\n      method: Web3Method_1.Web3Method.signEthereumMessage,\n      params: {\n        message: (0, util_1.hexStringFromBuffer)(message, true),\n        address,\n        addPrefix,\n        typedDataJson: typedDataJson || null\n      }\n    });\n  }\n  ethereumAddressFromSignedMessage(message, signature, addPrefix) {\n    return this.sendRequest({\n      method: Web3Method_1.Web3Method.ethereumAddressFromSignedMessage,\n      params: {\n        message: (0, util_1.hexStringFromBuffer)(message, true),\n        signature: (0, util_1.hexStringFromBuffer)(signature, true),\n        addPrefix\n      }\n    });\n  }\n  signEthereumTransaction(params) {\n    return this.sendRequest({\n      method: Web3Method_1.Web3Method.signEthereumTransaction,\n      params: {\n        fromAddress: params.fromAddress,\n        toAddress: params.toAddress,\n        weiValue: (0, util_1.bigIntStringFromBN)(params.weiValue),\n        data: (0, util_1.hexStringFromBuffer)(params.data, true),\n        nonce: params.nonce,\n        gasPriceInWei: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,\n        maxFeePerGas: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,\n        maxPriorityFeePerGas: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,\n        gasLimit: params.gasLimit ? (0, util_1.bigIntStringFromBN)(params.gasLimit) : null,\n        chainId: params.chainId,\n        shouldSubmit: false\n      }\n    });\n  }\n  signAndSubmitEthereumTransaction(params) {\n    return this.sendRequest({\n      method: Web3Method_1.Web3Method.signEthereumTransaction,\n      params: {\n        fromAddress: params.fromAddress,\n        toAddress: params.toAddress,\n        weiValue: (0, util_1.bigIntStringFromBN)(params.weiValue),\n        data: (0, util_1.hexStringFromBuffer)(params.data, true),\n        nonce: params.nonce,\n        gasPriceInWei: params.gasPriceInWei ? (0, util_1.bigIntStringFromBN)(params.gasPriceInWei) : null,\n        maxFeePerGas: params.maxFeePerGas ? (0, util_1.bigIntStringFromBN)(params.maxFeePerGas) : null,\n        maxPriorityFeePerGas: params.maxPriorityFeePerGas ? (0, util_1.bigIntStringFromBN)(params.maxPriorityFeePerGas) : null,\n        gasLimit: params.gasLimit ? (0, util_1.bigIntStringFromBN)(params.gasLimit) : null,\n        chainId: params.chainId,\n        shouldSubmit: true\n      }\n    });\n  }\n  submitEthereumTransaction(signedTransaction, chainId) {\n    return this.sendRequest({\n      method: Web3Method_1.Web3Method.submitEthereumTransaction,\n      params: {\n        signedTransaction: (0, util_1.hexStringFromBuffer)(signedTransaction, true),\n        chainId\n      }\n    });\n  }\n  scanQRCode(regExp) {\n    return this.sendRequest({\n      method: Web3Method_1.Web3Method.scanQRCode,\n      params: {\n        regExp\n      }\n    });\n  }\n  getQRCodeUrl() {\n    return (0, util_1.createQrUrl)(this._session.id, this._session.secret, this.linkAPIUrl, false, this.options.version, this.dappDefaultChain);\n  }\n  genericRequest(data, action) {\n    return this.sendRequest({\n      method: Web3Method_1.Web3Method.generic,\n      params: {\n        action,\n        data\n      }\n    });\n  }\n  sendGenericMessage(request) {\n    return this.sendRequest(request);\n  }\n  sendRequest(request) {\n    let hideSnackbarItem = null;\n    const id = (0, util_1.randomBytesHex)(8);\n    const cancel = error => {\n      this.publishWeb3RequestCanceledEvent(id);\n      this.handleErrorResponse(id, request.method, error);\n      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n    };\n    const promise = new Promise((resolve, reject) => {\n      if (!this.ui.isStandalone()) {\n        hideSnackbarItem = this.ui.showConnecting({\n          isUnlinkedErrorState: this.isUnlinkedErrorState,\n          onCancel: cancel,\n          onResetConnection: this.resetAndReload // eslint-disable-line @typescript-eslint/unbound-method\n        });\n      }\n\n      this.relayEventManager.callbacks.set(id, response => {\n        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n        if (response.errorMessage) {\n          return reject(new Error(response.errorMessage));\n        }\n        resolve(response);\n      });\n      if (this.ui.isStandalone()) {\n        this.sendRequestStandalone(id, request);\n      } else {\n        this.publishWeb3RequestEvent(id, request);\n      }\n    });\n    return {\n      promise,\n      cancel\n    };\n  }\n  setConnectDisabled(disabled) {\n    this.ui.setConnectDisabled(disabled);\n  }\n  setAccountsCallback(accountsCallback) {\n    this.accountsCallback = accountsCallback;\n  }\n  setChainCallback(chainCallback) {\n    this.chainCallback = chainCallback;\n  }\n  setDappDefaultChainCallback(chainId) {\n    this.dappDefaultChainSubject.next(chainId);\n  }\n  publishWeb3RequestEvent(id, request) {\n    var _a;\n    const message = (0, Web3RequestMessage_1.Web3RequestMessage)({\n      id,\n      request\n    });\n    const storedSession = Session_1.Session.load(this.storage);\n    (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.WEB3_REQUEST, {\n      eventId: message.id,\n      method: `relay::${message.request.method}`,\n      sessionIdHash: this.getSessionIdHash(),\n      storedSessionIdHash: storedSession ? Session_1.Session.hash(storedSession.id) : \"\",\n      isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== this._session.id).toString()\n    });\n    this.subscriptions.add(this.publishEvent(\"Web3Request\", message, true).subscribe({\n      next: _ => {\n        var _a;\n        (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.WEB3_REQUEST_PUBLISHED, {\n          eventId: message.id,\n          method: `relay::${message.request.method}`,\n          sessionIdHash: this.getSessionIdHash(),\n          storedSessionIdHash: storedSession ? Session_1.Session.hash(storedSession.id) : \"\",\n          isSessionMismatched: ((storedSession === null || storedSession === void 0 ? void 0 : storedSession.id) !== this._session.id).toString()\n        });\n      },\n      error: err => {\n        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n          id: message.id,\n          response: {\n            method: message.request.method,\n            errorMessage: err.message\n          }\n        }));\n      }\n    }));\n  }\n  publishWeb3RequestCanceledEvent(id) {\n    const message = (0, Web3RequestCanceledMessage_1.Web3RequestCanceledMessage)(id);\n    this.subscriptions.add(this.publishEvent(\"Web3RequestCanceled\", message, false).subscribe());\n  }\n  publishEvent(event, message, callWebhook) {\n    const secret = this.session.secret;\n    return new rxjs_1.Observable(subscriber => {\n      void aes256gcm.encrypt(JSON.stringify(Object.assign(Object.assign({}, message), {\n        origin: location.origin\n      })), secret).then(encrypted => {\n        subscriber.next(encrypted);\n        subscriber.complete();\n      });\n    }).pipe((0, operators_1.mergeMap)(encrypted => {\n      return this.connection.publishEvent(event, encrypted, callWebhook);\n    }));\n  }\n  handleIncomingEvent(event) {\n    try {\n      this.subscriptions.add(aes256gcm.decrypt(event.data, this.session.secret).pipe((0, operators_1.map)(c => JSON.parse(c))).subscribe({\n        next: json => {\n          const message = (0, Web3ResponseMessage_1.isWeb3ResponseMessage)(json) ? json : null;\n          if (!message) {\n            return;\n          }\n          this.handleWeb3ResponseMessage(message);\n        },\n        error: () => {\n          var _a;\n          (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.GENERAL_ERROR, {\n            message: \"Had error decrypting\",\n            value: \"incomingEvent\"\n          });\n        }\n      }));\n    } catch (_a) {\n      return;\n    }\n  }\n  handleWeb3ResponseMessage(message) {\n    var _a;\n    const {\n      response\n    } = message;\n    (_a = this.diagnostic) === null || _a === void 0 ? void 0 : _a.log(DiagnosticLogger_1.EVENTS.WEB3_RESPONSE, {\n      eventId: message.id,\n      method: `relay::${response.method}`,\n      sessionIdHash: this.getSessionIdHash()\n    });\n    if ((0, Web3Response_1.isRequestEthereumAccountsResponse)(response)) {\n      WalletSDKRelay.accountRequestCallbackIds.forEach(id => this.invokeCallback(Object.assign(Object.assign({}, message), {\n        id\n      })));\n      WalletSDKRelay.accountRequestCallbackIds.clear();\n      return;\n    }\n    this.invokeCallback(message);\n  }\n  handleErrorResponse(id, method, error, errorCode) {\n    this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n      id,\n      response: (0, Web3Response_1.ErrorResponse)(method, (error !== null && error !== void 0 ? error : WalletUIError_1.WalletUIError.UserRejectedRequest).message, errorCode)\n    }));\n  }\n  invokeCallback(message) {\n    const callback = this.relayEventManager.callbacks.get(message.id);\n    if (callback) {\n      callback(message.response);\n      this.relayEventManager.callbacks.delete(message.id);\n    }\n  }\n  requestEthereumAccounts() {\n    const request = {\n      method: Web3Method_1.Web3Method.requestEthereumAccounts,\n      params: {\n        appName: this.appName,\n        appLogoUrl: this.appLogoUrl || null\n      }\n    };\n    const hideSnackbarItem = null;\n    const id = (0, util_1.randomBytesHex)(8);\n    const cancel = error => {\n      this.publishWeb3RequestCanceledEvent(id);\n      this.handleErrorResponse(id, request.method, error);\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n    };\n    const promise = new Promise((resolve, reject) => {\n      var _a;\n      this.relayEventManager.callbacks.set(id, response => {\n        this.ui.hideRequestEthereumAccounts();\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n        if (response.errorMessage) {\n          return reject(new Error(response.errorMessage));\n        }\n        resolve(response);\n      });\n      const userAgent = ((_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) || null;\n      if (userAgent && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)) {\n        let location;\n        try {\n          if ((0, util_1.isInIFrame)() && window.top) {\n            location = window.top.location;\n          } else {\n            location = window.location;\n          }\n        } catch (e) {\n          location = window.location;\n        }\n        location.href = `https://www.coinbase.com/connect-dapp?uri=${encodeURIComponent(location.href)}`;\n        return;\n      }\n      if (this.ui.inlineAccountsResponse()) {\n        const onAccounts = accounts => {\n          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n            id,\n            response: (0, Web3Response_1.RequestEthereumAccountsResponse)(accounts)\n          }));\n        };\n        this.ui.requestEthereumAccounts({\n          onCancel: cancel,\n          onAccounts\n        });\n      } else {\n        // Error if user closes TryExtensionLinkDialog without connecting\n        const err = eth_rpc_errors_1.ethErrors.provider.userRejectedRequest(\"User denied account authorization\");\n        this.ui.requestEthereumAccounts({\n          onCancel: () => cancel(err)\n        });\n      }\n      WalletSDKRelay.accountRequestCallbackIds.add(id);\n      if (!this.ui.inlineAccountsResponse() && !this.ui.isStandalone()) {\n        this.publishWeb3RequestEvent(id, request);\n      }\n    });\n    return {\n      promise,\n      cancel\n    };\n  }\n  selectProvider(providerOptions) {\n    const request = {\n      method: Web3Method_1.Web3Method.selectProvider,\n      params: {\n        providerOptions\n      }\n    };\n    const id = (0, util_1.randomBytesHex)(8);\n    const cancel = error => {\n      this.publishWeb3RequestCanceledEvent(id);\n      this.handleErrorResponse(id, request.method, error);\n    };\n    const promise = new Promise((resolve, reject) => {\n      this.relayEventManager.callbacks.set(id, response => {\n        if (response.errorMessage) {\n          return reject(new Error(response.errorMessage));\n        }\n        resolve(response);\n      });\n      const _cancel = _error => {\n        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n          id,\n          response: (0, Web3Response_1.SelectProviderResponse)(types_1.ProviderType.Unselected)\n        }));\n      };\n      const approve = selectedProviderKey => {\n        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n          id,\n          response: (0, Web3Response_1.SelectProviderResponse)(selectedProviderKey)\n        }));\n      };\n      if (this.ui.selectProvider) this.ui.selectProvider({\n        onApprove: approve,\n        onCancel: _cancel,\n        providerOptions\n      });\n    });\n    return {\n      cancel,\n      promise\n    };\n  }\n  watchAsset(type, address, symbol, decimals, image, chainId) {\n    const request = {\n      method: Web3Method_1.Web3Method.watchAsset,\n      params: {\n        type,\n        options: {\n          address,\n          symbol,\n          decimals,\n          image\n        },\n        chainId\n      }\n    };\n    let hideSnackbarItem = null;\n    const id = (0, util_1.randomBytesHex)(8);\n    const cancel = error => {\n      this.publishWeb3RequestCanceledEvent(id);\n      this.handleErrorResponse(id, request.method, error);\n      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n    };\n    if (!this.ui.inlineWatchAsset()) {\n      hideSnackbarItem = this.ui.showConnecting({\n        isUnlinkedErrorState: this.isUnlinkedErrorState,\n        onCancel: cancel,\n        onResetConnection: this.resetAndReload // eslint-disable-line @typescript-eslint/unbound-method\n      });\n    }\n\n    const promise = new Promise((resolve, reject) => {\n      this.relayEventManager.callbacks.set(id, response => {\n        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n        if (response.errorMessage) {\n          return reject(new Error(response.errorMessage));\n        }\n        resolve(response);\n      });\n      const _cancel = _error => {\n        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n          id,\n          response: (0, Web3Response_1.WatchAssetReponse)(false)\n        }));\n      };\n      const approve = () => {\n        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n          id,\n          response: (0, Web3Response_1.WatchAssetReponse)(true)\n        }));\n      };\n      if (this.ui.inlineWatchAsset()) {\n        this.ui.watchAsset({\n          onApprove: approve,\n          onCancel: _cancel,\n          type,\n          address,\n          symbol,\n          decimals,\n          image,\n          chainId\n        });\n      }\n      if (!this.ui.inlineWatchAsset() && !this.ui.isStandalone()) {\n        this.publishWeb3RequestEvent(id, request);\n      }\n    });\n    return {\n      cancel,\n      promise\n    };\n  }\n  addEthereumChain(chainId, rpcUrls, iconUrls, blockExplorerUrls, chainName, nativeCurrency) {\n    const request = {\n      method: Web3Method_1.Web3Method.addEthereumChain,\n      params: {\n        chainId,\n        rpcUrls,\n        blockExplorerUrls,\n        chainName,\n        iconUrls,\n        nativeCurrency\n      }\n    };\n    let hideSnackbarItem = null;\n    const id = (0, util_1.randomBytesHex)(8);\n    const cancel = error => {\n      this.publishWeb3RequestCanceledEvent(id);\n      this.handleErrorResponse(id, request.method, error);\n      hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n    };\n    if (!this.ui.inlineAddEthereumChain(chainId)) {\n      hideSnackbarItem = this.ui.showConnecting({\n        isUnlinkedErrorState: this.isUnlinkedErrorState,\n        onCancel: cancel,\n        onResetConnection: this.resetAndReload // eslint-disable-line @typescript-eslint/unbound-method\n      });\n    }\n\n    const promise = new Promise((resolve, reject) => {\n      this.relayEventManager.callbacks.set(id, response => {\n        hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();\n        if (response.errorMessage) {\n          return reject(new Error(response.errorMessage));\n        }\n        resolve(response);\n      });\n      const _cancel = _error => {\n        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n          id,\n          response: (0, Web3Response_1.AddEthereumChainResponse)({\n            isApproved: false,\n            rpcUrl: \"\"\n          })\n        }));\n      };\n      const approve = rpcUrl => {\n        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n          id,\n          response: (0, Web3Response_1.AddEthereumChainResponse)({\n            isApproved: true,\n            rpcUrl\n          })\n        }));\n      };\n      if (this.ui.inlineAddEthereumChain(chainId)) {\n        this.ui.addEthereumChain({\n          onCancel: _cancel,\n          onApprove: approve,\n          chainId: request.params.chainId,\n          rpcUrls: request.params.rpcUrls,\n          blockExplorerUrls: request.params.blockExplorerUrls,\n          chainName: request.params.chainName,\n          iconUrls: request.params.iconUrls,\n          nativeCurrency: request.params.nativeCurrency\n        });\n      }\n      if (!this.ui.inlineAddEthereumChain(chainId) && !this.ui.isStandalone()) {\n        this.publishWeb3RequestEvent(id, request);\n      }\n    });\n    return {\n      promise,\n      cancel\n    };\n  }\n  switchEthereumChain(chainId, address) {\n    const request = {\n      method: Web3Method_1.Web3Method.switchEthereumChain,\n      params: Object.assign({\n        chainId\n      }, {\n        address\n      })\n    };\n    const id = (0, util_1.randomBytesHex)(8);\n    const cancel = error => {\n      this.publishWeb3RequestCanceledEvent(id);\n      this.handleErrorResponse(id, request.method, error);\n    };\n    const promise = new Promise((resolve, reject) => {\n      this.relayEventManager.callbacks.set(id, response => {\n        if (response.errorMessage && response.errorCode) {\n          return reject(eth_rpc_errors_1.ethErrors.provider.custom({\n            code: response.errorCode,\n            message: `Unrecognized chain ID. Try adding the chain using addEthereumChain first.`\n          }));\n        } else if (response.errorMessage) {\n          return reject(new Error(response.errorMessage));\n        }\n        resolve(response);\n      });\n      const _cancel = error => {\n        if (typeof error === \"number\") {\n          // backward compatibility\n          const errorCode = error;\n          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n            id,\n            response: (0, Web3Response_1.ErrorResponse)(Web3Method_1.Web3Method.switchEthereumChain, WalletUIError_1.WalletUIError.SwitchEthereumChainUnsupportedChainId.message, errorCode)\n          }));\n        } else if (error instanceof WalletUIError_1.WalletUIError) {\n          this.handleErrorResponse(id, Web3Method_1.Web3Method.switchEthereumChain, error, error.errorCode);\n        } else {\n          this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n            id,\n            response: (0, Web3Response_1.SwitchEthereumChainResponse)({\n              isApproved: false,\n              rpcUrl: \"\"\n            })\n          }));\n        }\n      };\n      const approve = rpcUrl => {\n        this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n          id,\n          response: (0, Web3Response_1.SwitchEthereumChainResponse)({\n            isApproved: true,\n            rpcUrl\n          })\n        }));\n      };\n      this.ui.switchEthereumChain({\n        onCancel: _cancel,\n        onApprove: approve,\n        chainId: request.params.chainId,\n        address: request.params.address\n      });\n      if (!this.ui.inlineSwitchEthereumChain() && !this.ui.isStandalone()) {\n        this.publishWeb3RequestEvent(id, request);\n      }\n    });\n    return {\n      promise,\n      cancel\n    };\n  }\n  inlineAddEthereumChain(chainId) {\n    return this.ui.inlineAddEthereumChain(chainId);\n  }\n  getSessionIdHash() {\n    return Session_1.Session.hash(this._session.id);\n  }\n  sendRequestStandalone(id, request) {\n    const _cancel = error => {\n      this.handleErrorResponse(id, request.method, error);\n    };\n    const onSuccess = response => {\n      this.handleWeb3ResponseMessage((0, Web3ResponseMessage_1.Web3ResponseMessage)({\n        id,\n        response\n      }));\n    };\n    switch (request.method) {\n      case Web3Method_1.Web3Method.signEthereumMessage:\n        this.ui.signEthereumMessage({\n          request,\n          onSuccess,\n          onCancel: _cancel\n        });\n        break;\n      case Web3Method_1.Web3Method.signEthereumTransaction:\n        this.ui.signEthereumTransaction({\n          request,\n          onSuccess,\n          onCancel: _cancel\n        });\n        break;\n      case Web3Method_1.Web3Method.submitEthereumTransaction:\n        this.ui.submitEthereumTransaction({\n          request,\n          onSuccess,\n          onCancel: _cancel\n        });\n        break;\n      case Web3Method_1.Web3Method.ethereumAddressFromSignedMessage:\n        this.ui.ethereumAddressFromSignedMessage({\n          request,\n          onSuccess\n        });\n        break;\n      default:\n        _cancel();\n        break;\n    }\n  }\n  onSessionConfigChanged(_nextSessionConfig) {}\n}\nWalletSDKRelay.accountRequestCallbackIds = new Set();\n__decorate([bind_decorator_1.default], WalletSDKRelay.prototype, \"resetAndReload\", null);\n__decorate([bind_decorator_1.default], WalletSDKRelay.prototype, \"handleIncomingEvent\", null);\nexports.WalletSDKRelay = WalletSDKRelay;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}