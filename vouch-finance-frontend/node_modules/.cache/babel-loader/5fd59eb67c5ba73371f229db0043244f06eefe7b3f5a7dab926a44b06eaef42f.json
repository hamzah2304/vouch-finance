{"ast":null,"code":"import { _optionalChain } from '@sentry/utils/esm/buildPolyfills';\nimport { logger, loadModule, fill, arrayify, isThenable } from '@sentry/utils';\nimport { shouldDisableAutoInstrumentation } from './utils/node-utils.js';\n\n/** Tracing integration for Apollo */\nclass Apollo {\n  constructor() {\n    Apollo.prototype.__init.call(this);\n  }\n  /**\n   * @inheritDoc\n   */\n  static __initStatic() {\n    this.id = 'Apollo';\n  }\n\n  /**\n   * @inheritDoc\n   */\n  __init() {\n    this.name = Apollo.id;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setupOnce(_, getCurrentHub) {\n    if (shouldDisableAutoInstrumentation(getCurrentHub)) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('Apollo Integration is skipped because of instrumenter configuration.');\n      return;\n    }\n    const pkg = loadModule('apollo-server-core');\n    if (!pkg) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.error('Apollo Integration was unable to require apollo-server-core package.');\n      return;\n    }\n\n    /**\n     * Iterate over resolvers of the ApolloServer instance before schemas are constructed.\n     */\n    fill(pkg.ApolloServerBase.prototype, 'constructSchema', function (orig) {\n      return function () {\n        if (!this.config.resolvers) {\n          if (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) {\n            if (this.config.schema) {\n              logger.warn('Apollo integration is not able to trace `ApolloServer` instances constructed via `schema` property.');\n            } else if (this.config.modules) {\n              logger.warn('Apollo integration is not able to trace `ApolloServer` instances constructed via `modules` property.');\n            }\n            logger.error('Skipping tracing as no resolvers found on the `ApolloServer` instance.');\n          }\n          return orig.call(this);\n        }\n        const resolvers = arrayify(this.config.resolvers);\n        this.config.resolvers = resolvers.map(model => {\n          Object.keys(model).forEach(resolverGroupName => {\n            Object.keys(model[resolverGroupName]).forEach(resolverName => {\n              if (typeof model[resolverGroupName][resolverName] !== 'function') {\n                return;\n              }\n              wrapResolver(model, resolverGroupName, resolverName, getCurrentHub);\n            });\n          });\n          return model;\n        });\n        return orig.call(this);\n      };\n    });\n  }\n}\nApollo.__initStatic();\n\n/**\n * Wrap a single resolver which can be a parent of other resolvers and/or db operations.\n */\nfunction wrapResolver(model, resolverGroupName, resolverName, getCurrentHub) {\n  fill(model[resolverGroupName], resolverName, function (orig) {\n    return function () {\n      const scope = getCurrentHub().getScope();\n      const parentSpan = _optionalChain([scope, 'optionalAccess', _2 => _2.getSpan, 'call', _3 => _3()]);\n      const span = _optionalChain([parentSpan, 'optionalAccess', _4 => _4.startChild, 'call', _5 => _5({\n        description: `${resolverGroupName}.${resolverName}`,\n        op: 'graphql.resolve'\n      })]);\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      const rv = orig.call(this, ...args);\n      if (isThenable(rv)) {\n        return rv.then(res => {\n          _optionalChain([span, 'optionalAccess', _6 => _6.finish, 'call', _7 => _7()]);\n          return res;\n        });\n      }\n      _optionalChain([span, 'optionalAccess', _8 => _8.finish, 'call', _9 => _9()]);\n      return rv;\n    };\n  });\n}\nexport { Apollo };\n//# sourceMappingURL=apollo.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}