{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { objCamelCase } from \"./api.utils\";\nexport const toUrl = params => {\n  let string = new URLSearchParams(params).toString();\n  if (string) {\n    string = \"?\" + string;\n  }\n  return string;\n};\nexport class ApiError extends Error {\n  constructor(response) {\n    super(JSON.stringify(response));\n    this.response = response;\n    Object.setPrototypeOf(this, ApiError.prototype);\n  }\n}\nexport const isApiError = klass => klass instanceof ApiError;\nexport class API {\n  constructor(apiName, baseUrl) {\n    this.apiName = apiName;\n    this.baseUrl = baseUrl;\n    this.skipImpersonation = false;\n  }\n  updateToken(token) {\n    this.token = token;\n  }\n  updateImpersonatedToken(token) {\n    this.impersonatedToken = token;\n  }\n  skipImpersonationOnNextRequest() {\n    this.skipImpersonation = true;\n  }\n  // Public\n  get(path, options) {\n    return this.fetch(path, \"GET\", options);\n  }\n  post(path, body, options) {\n    return this.fetch(path, \"POST\", body, options);\n  }\n  put(path, body, options) {\n    return this.fetch(path, \"PUT\", body, options);\n  }\n  delete(path, body, options) {\n    return this.fetch(path, \"DELETE\", body, options);\n  }\n  // Protected\n  getAuth(path, options) {\n    return this.authBuilder(path, \"GET\", options);\n  }\n  postAuth(path, body, options) {\n    return this.authBuilder(path, \"POST\", body, options);\n  }\n  putAuth(path, body, options) {\n    return this.authBuilder(path, \"PUT\", body, options);\n  }\n  deleteAuth(path, body, options) {\n    return this.authBuilder(path, \"DELETE\", body, options);\n  }\n  // Common\n  authBuilder() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const [path, method, body, options] = args;\n    return this.fetch(path, method, body, options, true);\n  }\n  fetch(path) {\n    let method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"GET\";\n    let body = arguments.length > 2 ? arguments[2] : undefined;\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let auth = arguments.length > 4 ? arguments[4] : undefined;\n    options.headers = options.headers || {};\n    if (method !== \"GET\") {\n      options.method = method;\n      if (body) {\n        Object.assign(options.headers, {\n          \"Content-type\": \"application/json\"\n        });\n        options.body = JSON.stringify(body);\n      }\n    }\n    if (auth) {\n      const token = !this.skipImpersonation && this.impersonatedToken || this.token;\n      options.headers.authorization = `Bearer ${token}`;\n    }\n    this.skipImpersonation = false;\n    const controller = new AbortController();\n    options.signal = controller.signal;\n    const promise = fetch(this.baseUrl + path, options).then(res => __awaiter(this, void 0, void 0, function* () {\n      if (res.ok) {\n        try {\n          return yield res.json();\n        } catch (_a) {\n          return {};\n        }\n      }\n      throw new ApiError(yield res.json());\n    })).then(objCamelCase).catch(error => {\n      console.error(`[${this.apiName}, ${method}, ${path}]\\n`, error);\n      throw error;\n    });\n    const abortable = p => {\n      p.abort = () => controller.abort();\n      const initialThen = p.then.bind(p);\n      p.then = function () {\n        const result = initialThen(...arguments);\n        return abortable(result);\n      };\n      return p;\n    };\n    return abortable(promise);\n  }\n}\n//# sourceMappingURL=api.abstract.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}