{"ast":null,"code":"import { getCurrentHub } from '@sentry/core';\nimport { timestampInSeconds, logger, dropUndefinedKeys } from '@sentry/utils';\nimport { Span, SpanRecorder } from './span.js';\n\n/** JSDoc */\nclass Transaction extends Span {\n  /**\n   * The reference to the current hub.\n   */\n\n  __init() {\n    this._measurements = {};\n  }\n  __init2() {\n    this._contexts = {};\n  }\n  __init3() {\n    this._frozenDynamicSamplingContext = undefined;\n  }\n\n  /**\n   * This constructor should never be called manually. Those instrumenting tracing should use\n   * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n  constructor(transactionContext, hub) {\n    super(transactionContext);\n    Transaction.prototype.__init.call(this);\n    Transaction.prototype.__init2.call(this);\n    Transaction.prototype.__init3.call(this);\n    this._hub = hub || getCurrentHub();\n    this._name = transactionContext.name || '';\n    this.metadata = {\n      source: 'custom',\n      ...transactionContext.metadata,\n      spanMetadata: {},\n      changes: [],\n      propagations: 0\n    };\n    this._trimEnd = transactionContext.trimEnd;\n\n    // this is because transactions are also spans, and spans have a transaction pointer\n    this.transaction = this;\n\n    // If Dynamic Sampling Context is provided during the creation of the transaction, we freeze it as it usually means\n    // there is incoming Dynamic Sampling Context. (Either through an incoming request, a baggage meta-tag, or other means)\n    const incomingDynamicSamplingContext = this.metadata.dynamicSamplingContext;\n    if (incomingDynamicSamplingContext) {\n      // We shallow copy this in case anything writes to the original reference of the passed in `dynamicSamplingContext`\n      this._frozenDynamicSamplingContext = {\n        ...incomingDynamicSamplingContext\n      };\n    }\n  }\n\n  /** Getter for `name` property */\n  get name() {\n    return this._name;\n  }\n\n  /** Setter for `name` property, which also sets `source` as custom */\n  set name(newName) {\n    this.setName(newName);\n  }\n\n  /**\n   * JSDoc\n   */\n  setName(name) {\n    let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'custom';\n    // `source` could change without the name changing if we discover that an unparameterized route is actually\n    // parameterized by virtue of having no parameters in its path\n    if (name !== this.name || source !== this.metadata.source) {\n      this.metadata.changes.push({\n        // log previous source\n        source: this.metadata.source,\n        timestamp: timestampInSeconds(),\n        propagations: this.metadata.propagations\n      });\n    }\n    this._name = name;\n    this.metadata.source = source;\n  }\n\n  /**\n   * Attaches SpanRecorder to the span itself\n   * @param maxlen maximum number of spans that can be recorded\n   */\n  initSpanRecorder() {\n    let maxlen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1000;\n    if (!this.spanRecorder) {\n      this.spanRecorder = new SpanRecorder(maxlen);\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setContext(key, context) {\n    if (context === null) {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this._contexts[key];\n    } else {\n      this._contexts[key] = context;\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setMeasurement(name, value) {\n    let unit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    this._measurements[name] = {\n      value,\n      unit\n    };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  setMetadata(newMetadata) {\n    this.metadata = {\n      ...this.metadata,\n      ...newMetadata\n    };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  finish(endTimestamp) {\n    // This transaction is already finished, so we should not flush it again.\n    if (this.endTimestamp !== undefined) {\n      return undefined;\n    }\n    if (!this.name) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n      this.name = '<unlabeled transaction>';\n    }\n\n    // just sets the end timestamp\n    super.finish(endTimestamp);\n    if (this.sampled !== true) {\n      // At this point if `sampled !== true` we want to discard the transaction.\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Tracing] Discarding transaction because its trace was not chosen to be sampled.');\n      const client = this._hub.getClient();\n      if (client) {\n        client.recordDroppedEvent('sample_rate', 'transaction');\n      }\n      return undefined;\n    }\n    const finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(s => s !== this && s.endTimestamp) : [];\n    if (this._trimEnd && finishedSpans.length > 0) {\n      this.endTimestamp = finishedSpans.reduce((prev, current) => {\n        if (prev.endTimestamp && current.endTimestamp) {\n          return prev.endTimestamp > current.endTimestamp ? prev : current;\n        }\n        return prev;\n      }).endTimestamp;\n    }\n    const metadata = this.metadata;\n    const transaction = {\n      contexts: {\n        ...this._contexts,\n        // We don't want to override trace context\n        trace: this.getTraceContext()\n      },\n      spans: finishedSpans,\n      start_timestamp: this.startTimestamp,\n      tags: this.tags,\n      timestamp: this.endTimestamp,\n      transaction: this.name,\n      type: 'transaction',\n      sdkProcessingMetadata: {\n        ...metadata,\n        dynamicSamplingContext: this.getDynamicSamplingContext()\n      },\n      ...(metadata.source && {\n        transaction_info: {\n          source: metadata.source,\n          changes: metadata.changes,\n          propagations: metadata.propagations\n        }\n      })\n    };\n    const hasMeasurements = Object.keys(this._measurements).length > 0;\n    if (hasMeasurements) {\n      (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log('[Measurements] Adding measurements to transaction', JSON.stringify(this._measurements, undefined, 2));\n      transaction.measurements = this._measurements;\n    }\n    (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__) && logger.log(`[Tracing] Finishing ${this.op} transaction: ${this.name}.`);\n    return this._hub.captureEvent(transaction);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  toContext() {\n    const spanContext = super.toContext();\n    return dropUndefinedKeys({\n      ...spanContext,\n      name: this.name,\n      trimEnd: this._trimEnd\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  updateWithContext(transactionContext) {\n    super.updateWithContext(transactionContext);\n    this.name = transactionContext.name || '';\n    this._trimEnd = transactionContext.trimEnd;\n    return this;\n  }\n\n  /**\n   * @inheritdoc\n   *\n   * @experimental\n   */\n  getDynamicSamplingContext() {\n    if (this._frozenDynamicSamplingContext) {\n      return this._frozenDynamicSamplingContext;\n    }\n    const hub = this._hub || getCurrentHub();\n    const client = hub && hub.getClient();\n    if (!client) return {};\n    const {\n      environment,\n      release\n    } = client.getOptions() || {};\n    const {\n      publicKey: public_key\n    } = client.getDsn() || {};\n    const maybeSampleRate = this.metadata.sampleRate;\n    const sample_rate = maybeSampleRate !== undefined ? maybeSampleRate.toString() : undefined;\n    const scope = hub.getScope();\n    const {\n      segment: user_segment\n    } = scope && scope.getUser() || {};\n    const source = this.metadata.source;\n\n    // We don't want to have a transaction name in the DSC if the source is \"url\" because URLs might contain PII\n    const transaction = source && source !== 'url' ? this.name : undefined;\n    const dsc = dropUndefinedKeys({\n      environment,\n      release,\n      transaction,\n      user_segment,\n      public_key,\n      trace_id: this.traceId,\n      sample_rate\n    });\n\n    // Uncomment if we want to make DSC immutable\n    // this._frozenDynamicSamplingContext = dsc;\n\n    return dsc;\n  }\n}\nexport { Transaction };\n//# sourceMappingURL=transaction.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}