{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IScoracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\ninterface IScoracle {\n    struct ScoreData {\n        uint40 lastUpdated;\n        uint216 score;\n        bytes extraData;\n    }\n\n    //===============Events===============\n\n    /**\n     * @dev emitted upon callback function of chainlink call. emits the address that was updated, the time it was updatedand the tick that was returned\n     * @param addressToScore The address whose score is being updated\n     * @param lastUpdated Timestamp of last update\n     * @param score The new score\n     * @param extraData Extra data to the type of score request\n     **/\n    event ScoreUpdated(\n        address indexed addressToScore,\n        uint256 lastUpdated,\n        uint256 score,\n        bytes extraData\n    );\n\n    /**\n     * @dev Added a new score type\n     * @param scoreTypeJobId The new adapter job id\n     * @param scoreTypeName The new score type name\n     **/\n    event ScoreTypeAdded(bytes32 indexed scoreTypeJobId, string scoreTypeName);\n\n    /**\n     * @dev Deactivated a score type\n     * @param scoreTypeJobId The new adapter job id\n     **/\n    event ScoreTypeDeactivated(bytes32 indexed scoreTypeJobId);\n\n    /**\n     * @dev Updated the chainlink node address\n     * @param chainlinkNode The new chainlink node address\n     **/\n    event ChainlinkNodeUpdated(address indexed chainlinkNode);\n\n    /**\n     * @dev Updated the chainlink oracle address\n     * @param chainlinkOracle The new chainlink oracle address\n     **/\n    event ChainlinkOracleUpdated(address indexed chainlinkOracle);\n\n    /**\n     * @dev Updated the base fee\n     * @param baseFee Base fee updated\n     **/\n    event BaseFeeUpdated(uint256 baseFee);\n\n    /**\n     * @dev Updated the chainlink fee\n     * @param chainlinkFee The new chainlink fee\n     **/\n    event ChainlinkFeeUpdated(uint256 chainlinkFee);\n\n    //===============Main Functions===============\n\n    function scoreRequest(\n        address addressToScore,\n        bytes32 _scoreTypeJobId,\n        bytes memory _userSignature\n    ) external payable;\n\n    //===============Governance/Admin Functions===============\n\n    function addScoreType(bytes32 _scoreTypeJobId, string memory _scoreTypeName) external;\n\n    function deactivateScoreType(bytes32 _scoreTypeJobId) external;\n\n    function updateChainlinkNode(address chainlinkNode) external;\n\n    function updateChainlinkOracle(address chainlinkOracle) external;\n\n    function updateBaseFee(uint256 baseFee) external;\n\n    function updateChainlinkFee(uint256 chainlinkFee) external;\n\n    function depositLINK(uint256 amount) external;\n\n    function withdrawLINK(uint256 amount) external;\n\n    function withdrawETH(uint256 amount) external;\n\n    //===============Get Functions===============\n\n    function getScore(\n        address _user,\n        bytes32 _scoreTypeJobId\n    ) external view returns (ScoreData memory scoreData);\n\n    function checkScoreTypeExists(\n        bytes32 _scoreTypeJobId\n    ) external view returns (bool, string memory, bytes32);\n\n    function getChainlinkNode() external view returns (address);\n\n    function getChainlinkOracle() external view returns (address);\n\n    function getBaseFee() external view returns (uint256);\n\n    function getChainlinkFee() external view returns (uint256);\n\n    function getScoreBounds() external view returns (uint256, uint256);\n}\n"
    },
    "contracts/MyContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.11;\n\nimport \"./interfaces/IScoracle.sol\";\n\ncontract MyContract {\n    address constant SCORACLE_ADDRESS = 0xe953f329041dA0D5Cf23159abc4b45f6fbf8Ab17;\n\n    constructor() {}\n\n    function calculateMacroScore(bytes32 _scoreTypeJobId, bytes memory _userSignature) external {\n        IScoracle scoracle = IScoracle(SCORACLE_ADDRESS);\n        scoracle.scoreRequest(msg.sender, _scoreTypeJobId, _userSignature);\n    }\n\n    function prequalifyUser(\n        bytes32 _scoreTypeJobId\n    ) public view returns (bool prequalified, uint256 score) {\n        IScoracle scoracle = IScoracle(SCORACLE_ADDRESS);\n\n        // Scoracle's getScore will read an already calculated score from the Scoracle contract's state.\n        IScoracle.ScoreData memory scoreData = scoracle.getScore(msg.sender, _scoreTypeJobId);\n\n        prequalified = (scoreData.score > 650) ? true : false;\n\n        return (prequalified, scoreData.score);\n    }\n}\n"
    },
    "contracts/NFC.sol": {
      "content": "// // SPDX-License-Identifier: MIT\n// pragma solidity 0.8.11;\n\n// import \"./interfaces/INFC.sol\";\n// import \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n// import \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\n// import \"@openzeppelin/contracts/utils/Strings.sol\";\n\n// import \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n// import \"@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol\";\n\n// struct NFCData {\n//     address[] accounts;\n//     string customUri;\n// }\n\n// contract NFC is ERC721Upgradeable, EIP712Upgradeable, OwnableUpgradeable, INFC {\n//     using ECDSA for bytes32;\n//     using Strings for uint256;\n\n//     mapping(uint256 => NFCData) private _lookup;\n//     mapping(address => uint256) private _reverseLookup;\n//     uint256 public counter;\n//     string internal __baseURI;\n\n//     function initialize() public initializer {\n//         __Ownable_init();\n//         __ERC721_init(\"Non Fungible Credit\", \"NFC\");\n//         __EIP712_init(\"Spectral\", \"1\");\n//         counter = 1;\n//     }\n\n//     function mint() public returns (uint256) {\n//         require(!isInNFC(msg.sender), \"NFC_ALREADY_EXISTS\");\n//         uint256 currentCounter = counter++;\n//         NFCData storage nfcData = _lookup[currentCounter];\n//         _reverseLookup[msg.sender] = currentCounter;\n//         nfcData.accounts.push(msg.sender);\n//         _mint(msg.sender, currentCounter);\n//         emit NFCCreated(currentCounter, nfcData.accounts);\n//         return currentCounter;\n//     }\n\n//     function addAccounts(address[] memory accounts, bytes[] memory signatures) public {\n//         require(accounts.length == signatures.length, \"ARRAY_LENGTH_MISMATCH\");\n//         uint256 id = getNFCId(msg.sender);\n//         NFCData storage nfcData = _lookup[id];\n//         for (uint256 i = 0; i < accounts.length; i++) {\n//             address account = accounts[i];\n//             require(!isInNFC(account), _errorMsg(\"ALREADY_IN_NFC\", account));\n//             require(\n//                 verify(account, _hash(), signatures[i]),\n//                 _errorMsg(\"INVALID_SIGNATURE\", account)\n//             );\n//             _reverseLookup[account] = id;\n//             nfcData.accounts.push(account);\n//         }\n//         emit AccountsAdded(id, accounts);\n//     }\n\n//     function mintAndAdd(\n//         address[] memory accounts,\n//         bytes[] memory signatures\n//     ) external returns (uint256 id) {\n//         id = mint();\n//         addAccounts(accounts, signatures);\n//     }\n\n//     function merge(uint256[] memory ids, bytes[] memory signatures) external {\n//         require(ids.length == signatures.length, \"ARRAY_LENGTH_MISMATCH\");\n//         uint256 mergeIntoId = getNFCId(msg.sender);\n//         NFCData storage nfcData = _lookup[mergeIntoId];\n//         for (uint256 i = 0; i < ids.length; i++) {\n//             uint256 id = ids[i];\n//             address signer = ECDSA.recover(_hash(), signatures[i]);\n//             require(_reverseLookup[signer] == id, _errorMsg(\"SIGNER_NOT_IN_NFC\", id));\n//             address[] memory accounts = _lookup[id].accounts;\n//             for (uint256 j = 0; j < accounts.length; j++) {\n//                 nfcData.accounts.push(accounts[j]);\n//                 _reverseLookup[accounts[j]] = mergeIntoId;\n//             }\n//             // cannot delete storage variable https://ethereum.stackexchange.com/a/35993\n//             delete _lookup[ids[i]];\n//             _burn(ids[i]);\n//             emit NFCMerged(mergeIntoId, ids);\n//         }\n//     }\n\n//     function getAddresses(uint256 id) external view returns (address[] memory) {\n//         return _lookup[id].accounts;\n//     }\n\n//     function getNFCId(address account) public view returns (uint256) {\n//         uint256 id = _reverseLookup[account];\n//         require(id != 0, \"NFC_NOT_FOUND\");\n//         return id;\n//     }\n\n//     function isInNFC(address account) public view returns (bool) {\n//         return _reverseLookup[account] != 0;\n//     }\n\n//     function _errorMsg(string memory err, address account) private pure returns (string memory) {\n//         return string(abi.encodePacked(err, \": \", uint256(uint160(account)).toHexString(20)));\n//     }\n\n//     function _errorMsg(string memory err, uint256 id) private pure returns (string memory) {\n//         return string(abi.encodePacked(err, \": \", id.toString()));\n//     }\n\n//     function _beforeTokenTransfer(address from, address to, uint256) internal pure override {\n//         require(from == address(0) || to == address(0), \"NFC_NOT_TRANSFERABLE\");\n//     }\n\n//     function _baseURI() internal view virtual override returns (string memory) {\n//         return __baseURI;\n//     }\n\n//     function setBaseURI(string calldata baseURI) external onlyOwner {\n//         __baseURI = baseURI;\n//         emit BaseURIUpdated(baseURI);\n//     }\n\n//     function setCustomURI(string calldata _customUri) external {\n//         uint256 tokenId = getNFCId(msg.sender);\n//         NFCData storage nfcData = _lookup[tokenId];\n//         nfcData.customUri = _customUri;\n//         emit CustomURIUpdated(tokenId, _customUri);\n//     }\n\n//     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n//         if (tokenId == 0) {\n//             return \"\";\n//         }\n//         string memory uri = _lookup[tokenId].customUri;\n//         if (bytes(uri).length != 0) {\n//             return uri;\n//         }\n//         return super.tokenURI(tokenId);\n//     }\n\n//     function _hash() internal view returns (bytes32) {\n//         string memory content = \"This is Spectral Team. We are verifying ownership of the wallet.\";\n//         return\n//             _hashTypedDataV4(\n//                 keccak256(abi.encode(keccak256(\"Value(string content)\"), keccak256(bytes(content))))\n//             );\n//     }\n\n//     function verification(bytes memory _signature) external view returns (address) {\n//         return ECDSA.recover(_hash(), _signature);\n//     }\n\n//     function verify(\n//         address _signer,\n//         bytes32 _digest,\n//         bytes memory _signature\n//     ) internal view returns (bool) {\n//         return ECDSA.recover(_digest, _signature) == _signer;\n//     }\n\n//     uint256[50] private __gap;\n// }\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}